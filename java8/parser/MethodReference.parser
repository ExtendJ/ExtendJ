/*
type_arguments can contain wild cards, have to be checked with semantic analysis instead
*/

Expr primary_no_new_array = method_reference;

Expr method_reference = 
	primary.p DOUBLECOLON type_arguments.a? IDENTIFIER.i
		{: return new ExprMethodReference(a, i, p); :}
;

Expr method_reference = 
	name.n DOT SUPER DOUBLECOLON type_arguments.a? IDENTIFIER.i
		{: SuperAccess s = new SuperAccess();
           s.setStart(SUPER.getStart());
           s.setEnd(SUPER.getEnd()); 
		   return new ExprMethodReference(a, i, n.qualifiesAccess(s)); :}
	| SUPER DOUBLECOLON type_arguments.a? IDENTIFIER.i
		{: SuperAccess s = new SuperAccess();
		   s.setStart(SUPER.getStart());
		   s.setEnd(SUPER.getEnd());
		   return new ExprMethodReference(a, i, s); :}
; 

Expr method_reference = 
	nongeneric_array_type.r DOUBLECOLON type_arguments.a? IDENTIFIER.i
		{: return new TypeMethodReference(a, i, r); :}
	| name.n LTTYPE type_argument_list_1.a1 dims.d? DOUBLECOLON type_arguments.a2? IDENTIFIER.i
		{: return new TypeMethodReference(a2, i, new ParTypeAccess(n, a1).addArrayDims(d)); :}
;

Expr method_reference = 
	name.n DOUBLECOLON type_arguments.a? IDENTIFIER.i
		{: return new AmbiguousMethodReference(a, i, n); :}
;
