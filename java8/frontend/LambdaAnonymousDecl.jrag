/* Copyright (c) 2014, Erik Hogeman <Erik.Hogemn@gmail.com>
 *               2016-2017, Jesper Ã–qvist <jesper.oqvist@cs.lth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
aspect LambdaToClass {
  /** Constructs an anonymous class instance expression based on this lambda. */
  syn nta ClassInstanceExpr LambdaExpr.toClass() =
      new ClassInstanceExpr(
          targetInterface().createQualifiedAccess(),
          new List<Expr>(),
          new Opt<TypeDecl>(buildAnonymousDecl()));

  syn TypeDecl LambdaExpr.anonymousDecl() = toClass().getTypeDecl();

  /**
   * Build an anonymous class which will be converted to byte code. Since a
   * lambda can't target generic methods, eventual type variables don't have to
   * be taken into account.
   */
  protected TypeDecl LambdaExpr.buildAnonymousDecl() {
    List<Access> implementsList = new List<Access>();
    InterfaceDecl iDecl = targetInterface();

    // Compute the interface type implemented by the anonymous class:
    iDecl = (InterfaceDecl) iDecl.nonWildcardParameterization().getOrElse(iDecl);
    implementsList.add(iDecl.createQualifiedAccess());

    // Now we will build the single method of the anonymous class.
    List<BodyDecl> bodyDecls = new List<BodyDecl>();
    Modifiers methodModifiers = new Modifiers(new List<Modifier>().add(new Modifier("public")));
    FunctionDescriptor fd = iDecl.functionDescriptor();
    TypeDecl methodType;
    String methodName;
    if (fd.method.hasValue()) {
      methodType = fd.method.get().type();
      methodName = fd.method.get().name();
    } else {
      methodType = unknownType();
      methodName = "<unknown>";
    }
    Access returnType = methodType.createQualifiedAccess();
    List<ParameterDeclaration> methodParams = getLambdaParameters().toParameterList();
    List<Access> methodThrows = new List<Access>();
    for (TypeDecl throwsType : iDecl.functionDescriptor().throwsList) {
      methodThrows.add(throwsType.createQualifiedAccess());
    }
    Opt<Block> methodBlock = new Opt<Block>(getLambdaBody().toBlock());
    MethodDecl method = new MethodDecl(methodModifiers, returnType,
        methodName, methodParams, methodThrows, methodBlock);

    bodyDecls.add(method);

    // Now the anonymous class can be built. We use the type
    // LambdaAnonymousDecl instead of a normal AnonymousDecl in order for this
    // and super keywords to get the type of the outer scope.
    return new LambdaAnonymousDecl(new Modifiers(), "Lambda", implementsList, bodyDecls);
  }

  /**
   * Copies the method block for the lambda body.
   */
  protected abstract Block LambdaBody.toBlock();

  protected Block BlockLambdaBody.toBlock() {
    return getBlock().treeCopyNoTransform();
  }

  protected Block ExprLambdaBody.toBlock() {
    List<Stmt> stmtList = new List<Stmt>();
    Expr expr = getExpr().treeCopyNoTransform();
    boolean voidType;
    FunctionDescriptor fd = enclosingLambda().targetInterface().functionDescriptor();
    if (fd.method.hasValue()) {
      voidType = fd.method.get().type().isVoid();
    } else {
      voidType = false;
    }
    if (voidType) {
      // Return type is void: insert ExprStmt in list.
      stmtList.add(new ExprStmt(expr));
    } else {
      // Otherwise, insert return statement.
      stmtList.add(new ReturnStmt(expr));
    }
    return new Block(stmtList);
  }

  /**
   * Builds a parameter list copying the lambda parameters.
   */
  protected abstract List<ParameterDeclaration> LambdaParameters.toParameterList();

  protected List<ParameterDeclaration> DeclaredLambdaParameters.toParameterList() {
    return getParameterList().treeCopyNoTransform();
  }

  protected List<ParameterDeclaration> InferredLambdaParameters.toParameterList() {
    List<ParameterDeclaration> paramList = new List<ParameterDeclaration>();
    FunctionDescriptor fd = enclosingLambda().targetInterface().functionDescriptor();
    if (fd.method.hasValue()) {
      MethodDecl targetMethod = fd.method.get();
      int i = 0;
      for (InferredParameterDeclaration infDecl : getParameterList()) {
        ParameterDeclaration funcDecl = targetMethod.getParameter(i);
        paramList.add(
            new ParameterDeclaration(funcDecl.type().createQualifiedAccess(), infDecl.name()));
        i += 1;
      }
    }
    return paramList;
  }
}
