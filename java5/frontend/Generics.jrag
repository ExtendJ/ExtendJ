/* Copyright (c) 2005-2008, Torbjorn Ekman
 *               2014-2016, Jesper Ã–qvist <jesper.oqvist@cs.lth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * <b>Notes on parameterized type substitution.</b>
 *
 * <p>In ExtendJ parameterized types are represented by higher-order attributes
 * representing synthetic type declarations as children of the original generic
 * type declaration. Generic method and constructor parameterization works
 * similarly.
 * Note that "original" is used in attribute names to refer to
 * the generic declaration parent of a parameterized type or method/constructor.
 *
 * <p>Parameterized types are generic types with type arguments. The type variables
 * of the generic type should be substituted for the type arguments.
 * This used to be done using direct substitution, i.e., all occurrences of the
 * type variable were replaced directly in the synthetic parameterized declaration when
 * the synthetic declaration was constructed. However, this caused problems because
 * it prevented a few tricky cases of type substitution to work correctly.
 *
 * <p>The new system for parameterized type substitution is more light-weight and
 * demand-driven. The type substition only occurs during type lookup. Since type
 * lookup follows the AST upwards to find a declaration for a type, we simply
 * intercept type lookup at parameterized declarations and check if the typename should
 * be substituted. This easily enables complex nested substitutions which were tricky
 * to implement previously. It even allows some circularly dependent type substitions
 * and recursive types.
 *
 * <p>The synthetic parameterized declarations are copied from their original generic
 * templates, but it is not necessary to copy everything. Method bodies and instance
 * initializers can be dropped. Only the "signature" part of members are kept.
 * This is done by the signatureCopy() method. It copies the parts of a declaration
 * that are essential for type analysis. The erasedCopy() method works similarly but
 * removes type arguments in all parameterized type accesses, as necessary for
 * type erasure.
 *
 * <p>The new way of doing type substitution means that the parameterization needs to
 * be kept in the parameterized declaration. This is done by using a token of type
 * Parameterization.
 */
aspect Generics {

  @Override public String TypeVariable.toString() {
    return name();
  }

  /**
   * Qualified access for wildcard types.  Since they have no ordinary package
   * and type name we just return the bound access.
   */
  public Access AbstractWildcardType.createQualifiedAccess() {
    return createBoundAccess();
  }

  eq ParClassDecl.hostType() = original();
  eq ParInterfaceDecl.hostType() = original();
  eq RawClassDecl.hostType() = original();
  eq RawInterfaceDecl.hostType() = original();
  eq ClassDeclSubstituted.hostType() = getOriginal();
  eq InterfaceDeclSubstituted.hostType() = getOriginal();
  eq GenericClassDeclSubstituted.hostType() = getOriginal();
  eq GenericInterfaceDeclSubstituted.hostType() = getOriginal();

  refine TypeAnalysis eq MethodAccess.type() {
    if (getNumArg() == 0 && name().equals("getClass") && decl().hostType().isObject()) {
      TypeDecl typeClass = lookupType("java.lang", "Class");
      if (typeClass instanceof GenericClassDecl) {
        TypeDecl bound = isQualified() ? qualifier().type() : hostType();
        ArrayList<TypeDecl> args = new ArrayList<TypeDecl>();
        args.add(bound.erasure().asWildcardExtends());
        return ((GenericClassDecl) typeClass).lookupParTypeDecl(args);
      }
    }
    // Legacy getClass access using non-generic java.lang.Class.
    return refined();
  }

  // Imported types are considered raw types by the name resolver
  // here we replace them by their generic counter parts.
  refine TypeScopePropagation eq CompilationUnit.getChild().lookupType(String name) {
    SimpleSet<TypeDecl> result = emptySet();
    for (TypeDecl typeDecl : refined(name)) {
      if (typeDecl instanceof ParTypeDecl) {
        result = result.add(((ParTypeDecl) typeDecl).genericDecl());
      } else {
        result = result.add(typeDecl);
      }
    }
    return result;
  }

  refine TypeConversion eq ClassDecl.castingConversionTo(TypeDecl type) {
    TypeDecl S = this;
    TypeDecl T = type;
    if (T instanceof TypeVariable) {
      TypeVariable t = (TypeVariable) T;
      if (t.getNumTypeBound() == 0) {
        return true;
      }
      for (int i = 0; i < t.getNumTypeBound(); i++) {
        if (castingConversionTo(t.getTypeBound(i).type())) {
          return true;
        }
      }
      return false;
    }
    if (S.erasure() != S || T.erasure() != T) {
      return S.erasure().castingConversionTo(T.erasure());
    }
    return refined(type);
  }

  refine TypeConversion eq InterfaceDecl.castingConversionTo(TypeDecl type) {
    TypeDecl S = this;
    TypeDecl T = type;
    if (T.isArrayDecl()) {
      return T.subtype(S);
    } else if (T.isReferenceType() && !T.isFinal()) {
      return true;
    } else {
      return T.subtype(S);
    }
  }

  eq TypeVariable.castingConversionTo(TypeDecl type) {
    if (!type.isReferenceType()) {
      return false;
    }
    if (getNumTypeBound() == 0) {
      return true;
    }
    for (int i = 0; i < getNumTypeBound(); i++) {
      if (getTypeBound(i).type().castingConversionTo(type)) {
        return true;
      }
    }
    return false;
  }

  refine TypeConversion eq ArrayDecl.castingConversionTo(TypeDecl type) {
    TypeDecl S = this;
    TypeDecl T = type;
    if (T instanceof TypeVariable) {
      TypeVariable t = (TypeVariable) T;
      if (!type.isReferenceType()) {
        return false;
      }
      if (t.getNumTypeBound() == 0) {
        return true;
      }
      for (int i = 0; i < t.getNumTypeBound(); i++) {
        TypeDecl bound = t.getTypeBound(i).type();
        if (bound.isObject() || bound == typeSerializable() || bound == typeCloneable()) {
          return true;
        }
        if (bound.isTypeVariable() && castingConversionTo(bound)) {
          return true;
        }
        if (bound.isArrayDecl() && castingConversionTo(bound)) {
          return true;
        }
      }
      return false;
    } else {
      return refined(type);
    }
  }

  eq AbstractWildcardType.castingConversionTo(TypeDecl type) = erasure().castingConversionTo(type);

  refine TypeAnalysis eq ClassAccess.type() {
    TypeDecl decl = refined();
    if (decl instanceof GenericClassDecl) {
      GenericClassDecl d = (GenericClassDecl) refined();
      TypeDecl type = qualifier().type();
      if (type.isPrimitiveType()) {
        type = type.boxed();
      }
      ArrayList<TypeDecl> list = new ArrayList<TypeDecl>();
      list.add(type);
      return d.lookupParTypeDecl(list);
    }
    // Using non-generic java.lang.Class.
    return decl;
  }

  refine AutoBoxing eq ConditionalExpr.type() {
    TypeDecl type = refined();
    if (type.isUnknown()) {
      TypeDecl trueType = getTrueExpr().type();
      TypeDecl falseType = getFalseExpr().type();
      if (!trueType.isReferenceType() && !trueType.boxed().isUnknown()) {
        trueType = trueType.boxed();
      }
      if (!falseType.isReferenceType() && !falseType.boxed().isUnknown()) {
        falseType = falseType.boxed();
      }
      ArrayList<TypeDecl> list = new ArrayList<TypeDecl>();
      list.add(trueType);
      list.add(falseType);
      return type.lookupLUBType(list).lub();
    }
    return type;
  }

  syn boolean TypeVariable.isNestedType() = false;

  // Accessibility for members in generic classes.  The accessibility for
  // parameterized and raw versions of a generic class should be the same as
  // for the generic class, in other words the erasure of the paramterized
  // version.
  eq ParClassDecl.topLevelType() = erasure().topLevelType();

  interface GenericTypeDecl {
    syn boolean isGenericType();
    TypeDecl original();
    int getNumTypeParameter();
    TypeVariable getTypeParameter(int index);
    List<TypeVariable> getTypeParameterList();
    syn lazy TypeDecl rawType();
    public String fullName();
    public String typeName();
  }

  GenericClassDecl implements GenericTypeDecl;
  GenericInterfaceDecl implements GenericTypeDecl;

  eq GenericClassDecl.rawType() = lookupParTypeDecl(Collections.<TypeDecl>emptyList());

  eq GenericInterfaceDecl.rawType() = lookupParTypeDecl(Collections.<TypeDecl>emptyList());

  syn boolean TypeDecl.isGenericType() = false;

  eq GenericTypeDecl.isGenericType() = true;

  // Brute force replacesment with generic one in AST
  // make sure that the AST has not beed traversed yet!
  public TypeDecl TypeDecl.makeGeneric(Signatures.ClassSignature s) {
    return this;
  }

  public TypeDecl ClassDecl.makeGeneric(Signatures.ClassSignature s) {
    // NOTE: we are overwriting List- and Opt- children here using setSuperClassOpt
    // and setImplementsList. This is dangerous since those children are in some
    // cases NTAs, and we should not use set methods to try to overwrite NTA values.
    // However, we have to do this here in order to not trigger rewrites that in
    // turn need to access certain (inherited) lookup attributes, and we are reasonably
    // sure that we are in fact not overwriting NTA children. We exclude EnumDecl here
    // because its [SuperClass] and Implements* are in fact NTAs.
    // /Jesper 2015-01-22
    if (this instanceof EnumDecl) {
      return this; // Enum superclass and superinterfaces are NTAs.
    }
    if (s.hasFormalTypeParameters()) {
      ASTNode node = getParent();
      int index = node.getIndexOfChild(this);
      node.setChild(
          new GenericClassDecl(
              getModifiersNoTransform(),
              getID(),
              s.hasSuperclassSignature()
                  ? new Opt(s.superclassSignature())
                  : getSuperClassOptNoTransform(),
              s.hasSuperinterfaceSignature()
                  ? s.superinterfaceSignature()
                  : getImplementsListNoTransform(),
              getBodyDeclListNoTransform(),
              s.typeParameters()),
          index);
      return (TypeDecl) node.getChildNoTransform(index);
    } else {
      if (s.hasSuperclassSignature()) {
        setSuperClassOpt(new Opt(s.superclassSignature()));
      }
      if (s.hasSuperinterfaceSignature()) {
        setImplementsList(s.superinterfaceSignature());
      }
      return this;
    }
  }

  public TypeDecl InterfaceDecl.makeGeneric(Signatures.ClassSignature s) {
    if (s.hasFormalTypeParameters()) {
      ASTNode node = getParent();
      int index = node.getIndexOfChild(this);
      node.setChild(
          new GenericInterfaceDecl(
              getModifiersNoTransform(),
              getID(),
              s.hasSuperinterfaceSignature()
                  ? s.superinterfaceSignature()
                  : getSuperInterfaceListNoTransform(),
              getBodyDeclListNoTransform(),
              s.typeParameters()),
          index);
      return (TypeDecl) node.getChildNoTransform(index);
    } else {
      if (s.hasSuperinterfaceSignature()) {
        setSuperInterfaceList(s.superinterfaceSignature());
      }
      return this;
    }
  }

  public TypeDecl GenericTypeDecl.makeGeneric(Signatures.ClassSignature s) {
    return (TypeDecl) this;
  }

  interface ParTypeDecl {
    TypeVariable getTypeParameter(int i);
    Parameterization getParameterization();
    syn boolean isParameterizedType();
    syn boolean isRawType();
    public String typeName();
    SimpleSet<Variable> localFields(String name);
    Map<String, SimpleSet<MethodDecl>> localMethodsSignatureMap();
    List<TypeVariable> getSubstTypeParamList();
  }

  ParClassDecl implements ParTypeDecl;

  ParInterfaceDecl implements ParTypeDecl;

  syn boolean TypeDecl.isParameterizedType() = false;

  eq ParTypeDecl.isParameterizedType() = true;

  eq RawClassDecl.isParameterizedType() = false;

  eq RawInterfaceDecl.isParameterizedType() = false;

  syn boolean TypeDecl.isRawType() = isNestedType() && enclosingType().isRawType();

  eq ParClassDecl.isRawType() = isNestedType() && enclosingType().isRawType();

  eq ParInterfaceDecl.isRawType() = isNestedType() && enclosingType().isRawType();

  eq RawClassDecl.isRawType() = true;

  eq RawInterfaceDecl.isRawType() = true;
}

aspect GenericsTypeAnalysis {
  eq ParTypeAccess.unqualifiedScope() =
      getParent() instanceof Access
      ? ((Access) getParent()).unqualifiedScope()
      : super.unqualifiedScope();

  eq ParTypeAccess.getTypeArgument().lookupType(String name) = unqualifiedScope().lookupType(name);

  eq Program.getChild().inExtendsOrImplements() = false;
  eq ClassDecl.getSuperClass().inExtendsOrImplements() = true;
  eq ClassDecl.getImplements(int i).inExtendsOrImplements() = true;
  eq InterfaceDecl.getSuperInterface().inExtendsOrImplements() = true;
  inh boolean Expr.inExtendsOrImplements();

  eq ParTypeAccess.type() {
    TypeDecl typeDecl = genericDecl();
    if (typeDecl instanceof ParInterfaceDecl || typeDecl instanceof ParClassDecl) {
      typeDecl = typeDecl.original();
    }
    if (typeDecl instanceof GenericTypeDecl) {
      // Use signature in lookup for types that are used in extends and implements clauses.
      if (unqualifiedScope().inExtendsOrImplements()) {
        return ((GenericTypeDecl) typeDecl).lookupParTypeDecl(this);
      }
      ArrayList<TypeDecl> args = new ArrayList<TypeDecl>();
      for (Access argument : getTypeArgumentList()) {
        args.add(argument.type());
      }
      return ((GenericTypeDecl) typeDecl).lookupParTypeDecl(args);
    }
    return typeDecl;
  }

  syn TypeDecl ParTypeAccess.genericDecl() = getTypeAccess().type();

  eq ParTypeAccess.isTypeAccess() = true;

  refine TypeScopePropagation eq TypeAccess.decl() {
    TypeDecl decl = refined();
    if (decl instanceof GenericTypeDecl && isRaw()) {
      return ((GenericTypeDecl) decl).lookupParTypeDecl(Collections.<TypeDecl>emptyList());
    }
    return decl;
  }

  /** This method assumes that the bound type is generic. */
  public boolean TypeAccess.isRaw() {
    ASTNode parent = getParent();
    while (parent instanceof Dot) {
      parent = parent.getParent();
    }
    if (parent instanceof ParTypeAccess) {
      return false;
    }
    if (parent instanceof ImportDecl) {
      return false;
    }
    return true;
  }

  refine TypeScopePropagation eq ThisAccess.decl() {
    TypeDecl typeDecl = refined();
    if (typeDecl instanceof ParTypeDecl) {
      typeDecl = ((ParTypeDecl) typeDecl).genericDecl();
    }
    return typeDecl;
  }

  refine TypeScopePropagation eq SuperAccess.decl() {
    TypeDecl typeDecl = refined();
    if (typeDecl instanceof ParTypeDecl) {
      typeDecl = ((ParTypeDecl) typeDecl).genericDecl();
    }
    return typeDecl;
  }

  public boolean BoundTypeAccess.isRaw() {
    return getTypeDecl().isRawType();
  }

  public boolean ParTypeAccess.isRaw() {
    return false;
  }

}

aspect GenericsErasure {
  eq AbstractWildcardType.isReferenceType() = true;

  syn lazy TypeDecl TypeDecl.erasure() = this;

  eq WildcardType.erasure() = typeObject();

  eq WildcardExtendsType.erasure() = getAccess().type().erasure();

  eq WildcardSuperType.erasure() = typeObject();

  eq ParClassDecl.erasure() = genericDecl();

  eq ParInterfaceDecl.erasure() = genericDecl();

  eq TypeVariable.erasure() = firstBound().type().erasure(); // TODO(joqvist): skip last erasure?

  eq ArrayDecl.erasure() = componentType().erasure().arrayType();
}

aspect GenericsTypeCheck {

  // TODO(joqvist): make reifiability check more efficient by implementing Access.isReifiable().
  ArrayCreationExpr contributes
      error("can not create array with non-reifiable element type")
      when !type().isReifiable()
      to CompilationUnit.problems();

  refine TypeCheck eq InstanceOfExpr.typeProblems() {
    Collection<Problem> problems = refined();
    if (!getTypeAccess().type().isReifiable()) {
      problems.add(error(
          "the right-hand side of this instanceof expression does not denote a reifiable type"));
    }
    return problems;
  }

  // Different parameterizations of the same generic interface may not be implemented.
  refine TypeHierarchyCheck eq TypeDecl.typeProblems() {
    Collection<Problem> problems = refined();
    ArrayList<InterfaceDecl> interfaceList = new ArrayList<InterfaceDecl>();
    interfaceList.addAll(implementedInterfaces());
    for (int i = 0; i < interfaceList.size(); i++) {
      InterfaceDecl decl = interfaceList.get(i);
      if (decl instanceof ParInterfaceDecl) {
        ParInterfaceDecl p = (ParInterfaceDecl) decl;
        for (Iterator<InterfaceDecl> i2 = interfaceList.listIterator(i); i2.hasNext(); ) {
          InterfaceDecl decl2 = i2.next();
          if (decl2 instanceof ParInterfaceDecl) {
            ParInterfaceDecl q = (ParInterfaceDecl) decl2;
            if (p != q && p.genericDecl() == q.genericDecl() && !p.sameArguments(q)) {
              problems.add(errorf("%s cannot be inherited with different type arguments: %s and %s",
                  p.genericDecl().name(), p.typeName(), q.typeName()));
            }
          }
        }
      }
    }

    // Check if a method has same signature as another in a supertype but does not override it.
    Map<String, SimpleSet<MethodDecl>> map = erasedAncestorMethodsMap();
    for (MethodDecl localMethod : localMethods()) {
      String signature = localMethod.signature();

      SimpleSet<MethodDecl> set = map.get(signature);
      if (set != null) {
        for (MethodDecl decl : set) {
          if (!decl.signature().equals(signature)) {
            problems.add(localMethod.errorf("method %s in %s has the same erased signature as"
                + " %s declared in %s but does not override it",
                signature, typeName(), decl.signature(), decl.hostType().typeName()));
          }
        }
      }
    }
    return problems;
  }

  syn lazy Map<String, SimpleSet<MethodDecl>> TypeDecl.erasedAncestorMethodsMap() =
      original().localMethodsSignatureMap();

  eq ClassDecl.erasedAncestorMethodsMap() {
    Map<String, SimpleSet<MethodDecl>> localMap = localMethodsSignatureMap();
    Map<String, SimpleSet<MethodDecl>> map = new HashMap<String, SimpleSet<MethodDecl>>();
    if (hasSuperclass()) {
      for (MethodDecl m : superclass().localMethods()) {
        if (!m.isPrivate() && m.accessibleFrom(this) && m.erasedMethod() != m) {
          // Map erased signature to substituted method.
          putSimpleSetElement(map, m.erasedMethod().signature(), m);
        }
      }
      mergeMap(map, superclass().erasedAncestorMethodsMap());
    }
    for (MethodDecl m : interfacesMethods()) {
      if (m.accessibleFrom(this) && m.erasedMethod() != m) {
        String erasedSignature = m.erasedMethod().signature();
        // Map erased signature to substituted method.
        putSimpleSetElement(map, erasedSignature, m);
      }
    }
    return map;
  }

  eq InterfaceDecl.erasedAncestorMethodsMap() {
    Map<String, SimpleSet<MethodDecl>> localMap = localMethodsSignatureMap();
    Map<String, SimpleSet<MethodDecl>> map = new HashMap<String, SimpleSet<MethodDecl>>(localMap);
    for (MethodDecl m : interfacesMethods()) {
      if (m.accessibleFrom(this) && m.erasedMethod() != m) {
        String erasedSignature = m.erasedMethod().signature();
        if (!localMap.containsKey(erasedSignature)) {
          // Map erased signature to substituted method.
          putSimpleSetElement(map, m.erasedMethod().signature(), m);
        }
      }
    }
    for (MethodDecl m : typeObject().methods()) {
      if (m.isPublic() && m.erasedMethod() != m) {
        String erasedSignature = m.erasedMethod().signature();
        if (!localMap.containsKey(erasedSignature)) {
          // Map erased signature to substituted method.
          putSimpleSetElement(map, m.erasedMethod().signature(), m);
        }
      }
    }
    return map;
  }

  /**
   * Merge the source map into the destination map.
   * @param dest destination map
   * @param src source map
   */
  protected void TypeDecl.mergeMap(Map<String, SimpleSet<MethodDecl>> dest,
      Map<String, SimpleSet<MethodDecl>> src) {
    for (Map.Entry<String, SimpleSet<MethodDecl>> entry : src.entrySet()) {
      String signature = entry.getKey();
      for (MethodDecl method : entry.getValue()) {
        putSimpleSetElement(dest, signature, method);
      }
    }
  }

  refine TypeHierarchyCheck eq ClassDecl.typeProblems() {
    Collection<Problem> problems = refined();

    if (hasSuperclass()) {
      // JLS SE7 8.4.8.4
      // Check for duplicate methods inherited from parameterized supertype.
      if (superclass().isParameterizedType()) {
        Map<String, SimpleSet<MethodDecl>> localMap = localMethodsSignatureMap();
        Map<String, SimpleSet<MethodDecl>> methodMap = superclass().localMethodsSignatureMap();
        for (Map.Entry<String, SimpleSet<MethodDecl>> entry: methodMap.entrySet()) {
          String signature = entry.getKey();
          if (!localMap.containsKey(signature)) {
            // Not locally overridden.
            SimpleSet<MethodDecl> set = entry.getValue();
            Iterator<MethodDecl> iter = set.iterator();
            iter.next();
            while (iter.hasNext()) {
              iter.next();
              problems.add(errorf(
                  "method with signature %s is multiply declared when inherited from %s",
                  signature, superclass().typeName()));
            }
          }
        }
      }
    }
    return problems;
  }

  syn boolean ParTypeDecl.sameArguments(ParTypeDecl decl) {
    if (this == decl) {
      return true;
    }
    if (genericDecl() != decl.genericDecl()) {
      return false;
    }
    return getParameterization().sameArguments(decl.getParameterization());
  }

  // TODO(joqvist): may be circular due to import-on-demand circularity.
  // See https://bitbucket.org/extendj/extendj/issues/159/circularity-in-type-lookup-due-to-on.
  syn lazy Collection<InterfaceDecl> TypeDecl.implementedInterfaces() = Collections.emptySet();

  eq ClassDecl.implementedInterfaces() {
    Collection<InterfaceDecl> set = new HashSet<InterfaceDecl>();
    if (hasSuperclass()) {
      set.addAll(superclass().implementedInterfaces());
    }
    for (InterfaceDecl decl : superInterfaces()) {
      set.add(decl);
      set.addAll(decl.implementedInterfaces());
    }
    return set;
  }

  eq InterfaceDecl.implementedInterfaces() {
    HashSet<InterfaceDecl> set = new HashSet<InterfaceDecl>();
    set.addAll(typeObject().implementedInterfaces());
    for (InterfaceDecl decl : superInterfaces()) {
      set.add(decl);
      set.addAll(decl.implementedInterfaces());
    }
    return set;
  }

  GenericClassDecl contributes
      errorf("generic class %s may not directly or indirectly inherit java.lang.Throwable",
          typeName())
      when subtype(typeThrowable())
      to CompilationUnit.problems();

  GenericInterfaceDecl contributes
      errorf("generic interface %s may not directly or indirectly inherit java.lang.Throwable",
          typeName())
      when subtype(typeThrowable())
      to CompilationUnit.problems();

  inh TypeDecl GenericClassDecl.typeThrowable();
  inh TypeDecl GenericInterfaceDecl.typeThrowable();

  TypeAccess contributes
      error("Can not access a member type of a paramterized type as a raw type")
      when type().isRawType() && type().isNestedType()
          && type().enclosingType().isParameterizedType()
          && !type().enclosingType().isRawType()
      to CompilationUnit.problems();

  ParTypeAccess contributes each typeProblems() to CompilationUnit.problems();

  syn Collection<Problem> ParTypeAccess.typeProblems() {
    Collection<Problem> problems = new LinkedList<Problem>();
    if (!genericDecl().isUnknown()) {
      TypeDecl type = type();
      if (!genericDecl().isGenericType()) {
        problems.add(errorf("%s is not a generic type but used as one in %s",
            genericDecl().typeName(), this.prettyPrint()));
      } else if (!type.isRawType() && type.isNestedType() && type.enclosingType().isRawType()) {
        problems.add(error("Can not access a member type of a raw type as a parameterized type"));
      } else {
        ParTypeDecl decl = (ParTypeDecl) type;
        GenericTypeDecl original = (GenericTypeDecl) genericDecl().original();
        if (original.getNumTypeParameter() != getNumTypeArgument()) {
          problems.add(errorf("%s takes %d type parameters, not %d as used in %s",
              original.typeName(), original.getNumTypeParameter(), getNumTypeArgument(),
              this.prettyPrint()));
        } else {
          List<TypeVariable> typeParam = decl.getSubstTypeParamList();
          for (int i = 0; i < getNumTypeArgument(); i++) {
            if (!getTypeArgument(i).type().withinBounds(typeParam.getChild(i))) {
              problems.add(errorf("type argument %d is of type %s which is not within"
                  + " the bounds of type parameter %s (%s)",
                  i + 1, getTypeArgument(i).type().typeName(),
                  original.getTypeParameter(i).typeName(),
                  original.getTypeParameter(i).prettyPrint()));
            }
          }
        }
      }
    }
    return problems;
  }

  /** Substituted type parameters are used when checking type argument bounds. */
  syn lazy List<TypeVariable> ParInterfaceDecl.getSubstTypeParamList() {
    List<TypeVariable> result = new List<TypeVariable>();
    for (TypeVariable param : getTypeParameterList()) {
      result.add(new SubstitutedTypeVariable(
          new Modifiers(new List<Modifier>()),
          param.getID(),
          new List<BodyDecl>(),
          param.getBoundList().treeCopy(),
          getParameterization()));
    }
    return result;
  }

  /** Substituted type parameters are used when checking type argument bounds. */
  syn lazy List<TypeVariable> ParClassDecl.getSubstTypeParamList() {
    List<TypeVariable> result = new List<TypeVariable>();
    for (TypeVariable param : getTypeParameterList()) {
      result.add(new SubstitutedTypeVariable(
          new Modifiers(new List<Modifier>()),
          param.getID(),
          new List<BodyDecl>(),
          param.getBoundList().treeCopy(),
          getParameterization()));
    }
    return result;
  }
}

aspect GenericsNameBinding {

  eq ParTypeAccess.getChild().nameType() = NameType.TYPE_NAME;

  eq GenericClassDecl.getTypeParameter().isNestedType() = true;
  eq GenericClassDecl.getTypeParameter().enclosingType() = this;

  eq GenericInterfaceDecl.getTypeParameter().isNestedType() = true;
  eq GenericInterfaceDecl.getTypeParameter().enclosingType() = this;

  /**
   * Helper method used to interject type variable substitution into the type
   * lookup process for generic type scopes.
   *
   * <p>When the type variables should be visible to a typename lookup from
   * inside this generic type scope, this helper method will check if there
   * exists a type variable with the given name. If so, that type variable is
   * the target for the lookup.
   */
  public SimpleSet<TypeDecl> GenericTypeDecl.addTypeVariables(SimpleSet<TypeDecl> types,
      String name) {
    GenericTypeDecl original = (GenericTypeDecl) original();
    for (int i = 0; i < original.getNumTypeParameter(); i++) {
      TypeVariable p = original.getTypeParameter(i);
      if (p.name().equals(name)) {
        types = types.add(p);
      }
    }
    return types;
  }

  eq GenericInterfaceDecl.getSuperInterface().lookupType(String name) {
    SimpleSet<TypeDecl> result = addTypeVariables(ASTNode.<TypeDecl>emptySet(), name);
    return !result.isEmpty() ? result : lookupType(name);
  }

  eq GenericClassDecl.getSuperClass().lookupType(String name) {
    SimpleSet<TypeDecl> result = addTypeVariables(ASTNode.<TypeDecl>emptySet(), name);
    return !result.isEmpty() ? result : lookupType(name);
  }

  eq GenericClassDecl.getImplements().lookupType(String name) {
    SimpleSet<TypeDecl> result = addTypeVariables(ASTNode.<TypeDecl>emptySet(), name);
    return !result.isEmpty() ? result : lookupType(name);
  }

  eq GenericTypeDecl.getTypeParameter().lookupType(String name) {
    SimpleSet<TypeDecl> result = memberTypes(name);
    result = addTypeVariables(result, name);
    if (!result.isEmpty()) {
      return result;
    }
    // 8.5.2
    if (isClassDecl() && isStatic() && !isTopLevelType()) {
      for (TypeDecl type : lookupType(name)) {
        if (type.isStatic() || (type.enclosingType() != null && subtype(type.enclosingType()))) {
          result = result.add(type);
        }
      }
    } else {
      result = lookupType(name);
    }
    if (!result.isEmpty()) {
      return result;
    }
    return topLevelType().lookupType(name); // Fix to search imports.
  }

  eq GenericTypeDecl.getBodyDecl(int index).lookupType(String name) {
    SimpleSet<TypeDecl> result = memberTypes(name);
    if (getBodyDecl(index).visibleTypeParameters()) {
      result = addTypeVariables(result, name);
    }
    if (!result.isEmpty()) {
      return result;
    }
    // 8.5.2
    if (isClassDecl() && isStatic() && !isTopLevelType()) {
      for (TypeDecl type : lookupType(name)) {
        if (type.isStatic() || (type.enclosingType() != null && subtype(type.enclosingType()))) {
          result = result.add(type);
        }
      }
    } else {
      result = lookupType(name);
    }
    if (!result.isEmpty()) {
      return result;
    }
    return topLevelType().lookupType(name); // Fix to search imports.
    // Include type parameters if not static.
  }
}

aspect LookupParTypeDecl {
  /**
   * Returns a string describing the context of a type variable. If the type
   * variable is part of a type declaration then the context string is the
   * qualified name of the type. If the type variable is declared in a method
   * or constructor declaration then the context string is the qualified
   * signature of the method or constructor.
   */
  inh String TypeVariable.typeVariableContext();

  eq MethodDecl.getChild().typeVariableContext() = hostType().typeName() + "." + signature();

  eq ConstructorDecl.getChild().typeVariableContext() = hostType().typeName() + "." + signature();

  eq TypeDecl.getChild().typeVariableContext() = fullName();

  eq TypeVariable.fullName() = typeVariableContext() + "@" + name();

  eq CompilationUnit.getChild().typeVariableContext() = "";

  syn boolean TypeDecl.sameSignature(Access a) {
    if (a instanceof ParTypeAccess) {
      return false;
    }
    if (a instanceof AbstractWildcard) {
      return false;
    }
    return this == a.type();
  }

  eq TypeVariable.sameSignature(Access a) = a.type() == this;

  syn boolean ParTypeDecl.sameSignature(Access a){
    if (a instanceof ParTypeAccess) {
      ParTypeAccess ta = (ParTypeAccess) a;
      if (genericDecl() != ta.genericDecl()) {
        return false;
      }
      Parameterization par = getParameterization();
      if (par.args.size() != ta.getNumTypeArgument()) {
        return false;
      }
      for (int i = 0; i < par.args.size(); i++) {
        if (!par.args.get(i).sameSignature(ta.getTypeArgument(i))) {
          return false;
        }
      }
      return true;
    } else if (a instanceof TypeAccess && ((TypeAccess) a).isRaw()) {
      return false;
    }
    return super.sameSignature(a);
  }

  eq RawClassDecl.sameSignature(Access a) = a instanceof TypeAccess && a.type() == this;

  eq RawInterfaceDecl.sameSignature(Access a) = a instanceof TypeAccess && a.type() == this;

  eq WildcardType.sameSignature(Access a) {
    if (a instanceof Wildcard) {
      return true;
    }
    return super.sameSignature(a);
  }

  eq WildcardExtendsType.sameSignature(Access a) {
    if (a instanceof WildcardExtends) {
      return getAccess().type().sameSignature(((WildcardExtends) a).getAccess());
    }
    return super.sameSignature(a);
  }

  eq WildcardSuperType.sameSignature(Access a) {
    if (a instanceof WildcardSuper) {
      return getAccess().type().sameSignature(((WildcardSuper) a).getAccess());
    }
    return super.sameSignature(a);
  }

  syn lazy boolean ParTypeDecl.sameSignature(java.util.List<TypeDecl> list) circular [true] {
    Parameterization par = getParameterization();
    if (par.args.size() != list.size()) {
      return false;
    }
    for (int i = 0; i < list.size(); i++) {
      if (par.args.get(i) != list.get(i)) {
        return false;
      }
    }
    return true;
  }

  /** Transforms the parameter and calls the lookupParTypeDecl attribute for ArrayList arguments. */
  syn lazy TypeDecl GenericTypeDecl.lookupParTypeDecl(ParTypeAccess p) {
    Collection<TypeDecl> typeArguments = new ArrayList<TypeDecl>();
    for (Access argument : p.getTypeArgumentList()) {
      typeArguments.add(argument.type());
    }
    return lookupParTypeDecl(typeArguments);
  }

  syn nta TypeDecl GenericTypeDecl.lookupParTypeDecl(Collection<TypeDecl> typeArgs);

  eq GenericClassDecl.lookupParTypeDecl(Collection<TypeDecl> typeArgs) {
    Parameterization parameterization = new Parameterization(getTypeParameterList(), typeArgs);
    ParClassDecl typeDecl;
    if (typeArgs.isEmpty()) {
      // According to JLSv8 4.6 (Type Erasure), the signature of members in the
      // erased type have no parameterized types or type variables.
      typeDecl = new RawClassDecl(
          getModifiers().treeCopyNoTransform(),
          getID(),
          getTypeParameterList().treeCopyNoTransform(),
          parameterization,
          hasSuperClass() ? new Opt<Access>(getSuperClass().erasedCopy()) : new Opt<Access>(),
          erasedAccessList(getImplementsList()));
    } else {
      typeDecl = new ParClassDecl(
          getModifiers().treeCopyNoTransform(),
          getID(),
          getTypeParameterList().treeCopyNoTransform(),
          parameterization,
          getSuperClassOpt().treeCopyNoTransform(),
          getImplementsList().treeCopyNoTransform());
    }
    return typeDecl;
  }

  eq GenericInterfaceDecl.lookupParTypeDecl(Collection<TypeDecl> typeArgs) {
    Parameterization parameterization = new Parameterization(getTypeParameterList(), typeArgs);
    Modifiers modifiers = getModifiers().treeCopyNoTransform();
    ParInterfaceDecl typeDecl;
    if (typeArgs.isEmpty()) {
      // According to JLSv8 4.6 (Type Erasure), the signature of members in the
      // erased type have no parameterized types or type variables.
      typeDecl = new RawInterfaceDecl(
          getModifiers().treeCopyNoTransform(),
          getID(),
          getTypeParameterList().treeCopyNoTransform(),
          parameterization,
          erasedAccessList(getSuperInterfaceList()));
    } else {
      typeDecl = new ParInterfaceDecl(
          getModifiers().treeCopyNoTransform(),
          getID(),
          getTypeParameterList().treeCopyNoTransform(),
          parameterization,
          getSuperInterfaceList().treeCopyNoTransform());
    }
    return typeDecl;
  }

  /**
   * This substitutes type variable names for matching type arguments during type lookup.
   */
  eq ParTypeDecl.getBodyDecl().lookupType(String name) {
    TypeDecl paramType = getParameterization().substitute(name);
    if (paramType != null) {
      return paramType;
    }
    return localLookupType(name);
  }

  /**
   * This substitutes type variable names for matching type arguments during type lookup.
   */
  eq ParTypeDecl.getChild().lookupType(String name) {
    TypeDecl paramType = getParameterization().substitute(name);
    if (paramType != null) {
      return paramType;
    }
    return lookupType(name);
  }

  /**
   * This substitutes type variable names for matching type arguments during type lookup.
   */
  eq ParMethodDecl.getChild().lookupType(String name) {
    TypeDecl paramType = getParameterization().substitute(name);
    if (paramType != null) {
      return paramType;
    }
    return lookupType(name);
  }

  /**
   * This substitutes type variable names for matching type arguments during type lookup.
   */
  eq ParConstructorDecl.getChild().lookupType(String name) {
    TypeDecl paramType = getParameterization().substitute(name);
    if (paramType != null) {
      return paramType;
    }
    return lookupType(name);
  }

  /**
   * This substitutes type variable names for matching type arguments during type lookup.
   */
  eq SubstitutedTypeVariable.getChild().lookupType(String name) {
    TypeDecl paramType = getParameterization().substituteBound(name);
    if (paramType != null) {
      return paramType;
    }
    return lookupType(name);
  }

  /**
   * Specifies a particular parameterization for a parameterized type or generic method.
   *
   * <p>Parameterizations are used during type lookup to substitute type variable names
   * for type arguments (TypeDecl).
   */
  public class Parameterization {
    public interface TypeProperty {
      boolean holds(TypeDecl t1, TypeDecl t2);
    }

    static class Substitution {
      final public TypeVariable param;
      final public TypeDecl arg;

      public Substitution(TypeVariable param, TypeDecl arg) {
        this.param = param;
        this.arg = arg;
      }

      /** Creates a raw type substitution. */
      public Substitution(TypeVariable param) {
        this.param = param;
        this.arg = null;
      }

      public TypeDecl substitute() {
        return arg == null
            ? param.erasure()
            : arg.expandWildcard(param);
      }

      /** Substitute types, preserving wildcards. */
      public TypeDecl substituteBound() {
        return arg == null
            ? param.erasure()
            : arg;
      }
    }

    /** Type variable names mapped to wildcard expanded argument types. */
    public final Map<String, Substitution> typeMap = new HashMap<String, Substitution>();

    /**
     * The original type parameters of the generic type or method.
     */
    public final java.util.List<TypeVariable> params = new ArrayList<TypeVariable>();

    /**
     * The type arguments provided for the this parameterization (not wildcard expanded).
     */
    public final java.util.List<TypeDecl> args = new ArrayList<TypeDecl>();

    private final boolean isRaw;

    public Parameterization(Iterable<TypeVariable> typeParams, Iterable<TypeDecl> typeArgs) {
      Iterator<TypeVariable> param = typeParams.iterator();
      Iterator<TypeDecl> arg = typeArgs.iterator();
      isRaw = param.hasNext() && !arg.hasNext();
      while (param.hasNext()) {
        TypeVariable variable = param.next();
        Substitution substitution;
        if (arg.hasNext()) {
          TypeDecl argument = arg.next();
          substitution = new Substitution(variable, argument);
          this.args.add(argument);
        } else {
          substitution = new Substitution(variable);
        }
        typeMap.put(variable.name(), substitution);
        params.add(variable);
      }
    }

    @Override public String toString() {
      StringBuilder str = new StringBuilder();
      str.append("[");
      if (isRaw) {
        str.append("raw");
      } else {
        for (TypeVariable var : params) {
          if (str.length() > 1) {
            str.append(", ");
          }
          TypeDecl arg = typeMap.get(var.name()).arg;
          str.append(var.name()).append("=").append(arg.typeName());
        }
      }
      str.append("]");
      return str.toString();
    }

    public boolean isRawType() {
      return isRaw;
    }

    /**
     * @return the substituted type, if the name matches a type variable name.
     * Returns {@code null} if the name does not match a type variable in this
     * parameterization.
     */
    public TypeDecl substitute(String name) {
      if (typeMap.containsKey(name)) {
        return typeMap.get(name).substitute();
      }
      return null;
    }

    /**
     * Substitute a type bound of a type variable.
     * This should preserve wildcards.
     */
    public TypeDecl substituteBound(String name) {
      if (typeMap.containsKey(name)) {
        return typeMap.get(name).substituteBound();
      }
      return null;
    }

    /**
     * @return the original type argument, or the Object type, if this is a raw
     * parameterization.
     */
    public TypeDecl getArg(int i) {
      if (args.isEmpty()) {
        // This is a raw parameterization.
        return params.get(0).typeObject();
      } else {
        return args.get(i);
      }
    }

    public boolean sameArguments(Parameterization that) {
      Iterator<TypeDecl> it1 = this.args.iterator();
      Iterator<TypeDecl> it2 = that.args.iterator();
      while (it1.hasNext() && it2.hasNext()) {
        TypeDecl t1 = it1.next();
        TypeDecl t2 = it2.next();
        if (t1 instanceof ParTypeDecl && t2 instanceof ParTypeDecl) {
          if (!((ParTypeDecl) t1).sameArguments((ParTypeDecl) t2)) {
            return false;
          }
        } else {
          if (t1 != t2) {
            return false;
          }
        }
      }
      return !it1.hasNext() && !it2.hasNext();
    }

    /**
     * Check a type property on each pair of type arguments in this and that
     * parameterization.
     * @return {@code true} if this parameterization and the argument
     * parameterization have the same number of type arguments, and if the
     * given property holds for each type argument pair.
     */
    public boolean compare(Parameterization that, TypeProperty property) {
      Iterator<TypeDecl> it1 = this.args.iterator();
      Iterator<TypeDecl> it2 = that.args.iterator();
      while (it1.hasNext() && it2.hasNext()) {
        TypeDecl t1 = it1.next();
        TypeDecl t2 = it2.next();
        if (!property.holds(t1, t2)) {
          return false;
        }
      }
      return !it1.hasNext() && !it2.hasNext();
    }

    /**
     * Check a type property on each pair of type arguments in this and that
     * parameterization, with substituted arguments in this parameterization.
     * @return {@code true} if this parameterization and the argument
     * parameterization have the same number of type arguments, and if the
     * given property holds for each type argument pair, with the argument
     * from this parameterization substituted.
     */
    public boolean compareSubstituted(Parameterization that, TypeProperty property) {
      Iterator<TypeVariable> it1 = this.params.iterator();
      Iterator<TypeDecl> it2 = that.args.iterator();
      while (it1.hasNext() && it2.hasNext()) {
        TypeDecl t1 = substitute(it1.next().name());
        TypeDecl t2 = it2.next();
        if (!property.holds(t1, t2)) {
          return false;
        }
      }
      return !it1.hasNext() && !it2.hasNext();
    }
  }

  interface MemberSubstitutor {
    TypeDecl original();
  }

  ParClassDecl implements MemberSubstitutor;
  ParInterfaceDecl implements MemberSubstitutor;
  ClassDeclSubstituted implements MemberSubstitutor;
  InterfaceDeclSubstituted implements MemberSubstitutor;
  GenericClassDeclSubstituted implements MemberSubstitutor;
  GenericInterfaceDeclSubstituted implements MemberSubstitutor;

  /**
   * Replaces wildcards in generic type arguments by ? extends with the
   * type bound of the corresponding type parameter.
   */
  syn TypeDecl TypeDecl.expandWildcard(TypeVariable param) = this;

  eq WildcardType.expandWildcard(TypeVariable param) {
    TypeDecl bound = param.erasure();
    if (bound != typeObject()) {
      bound = lookupWildcardExtends(bound);
    }
    return bound;
  }

  public boolean ParConstructorDecl.isRawType() {
    return false;
  }

  public int ParTypeDecl.numTypeParameter() {
    return ((GenericTypeDecl) original()).getNumTypeParameter();
  }

  public TypeVariable ParTypeDecl.typeParameter(int index) {
    return ((GenericTypeDecl) original()).getTypeParameter(index);
  }

  public int ParMethodDecl.numTypeParameter() {
    return genericMethodDecl().original().getNumTypeParameter();
  }

  public int ParConstructorDecl.numTypeParameter() {
    return genericConstructorDecl().original().getNumTypeParameter();
  }

  public TypeVariable ParMethodDecl.typeParameter(int index) {
    return genericMethodDecl().original().getTypeParameter(index);
  }

  public TypeVariable ParConstructorDecl.typeParameter(int index) {
    return genericConstructorDecl().original().getTypeParameter(index);
  }

  inh TypeDecl TypeVariable.typeObject();

  /**
   * Computes the least upper bound of this type variable.
   */
  syn lazy TypeDecl TypeVariable.lubType() {
    if (getNumBound() == 0) {
      return typeObject();
    } else if (getNumBound() == 1) {
      return getBound(0).type();
    } else {
      ArrayList<TypeDecl> list = new ArrayList<TypeDecl>();
      for (Access bound : getBoundList()) {
        list.add(bound.type());
      }
      return lookupLUBType(list);
    }
  }

  inh TypeDecl TypeVariable.typeNull();

  syn boolean ASTNode.usesTypeVariable() {
    for (int i = 0; i < getNumChild(); i++) {
      if (getChild(i).usesTypeVariable()) {
        return true;
      }
    }
    return false;
  }

  syn lazy boolean MethodDecl.usesTypeVariable() =
      getModifiers().usesTypeVariable() || getTypeAccess().usesTypeVariable()
      || getParameterList().usesTypeVariable() || getExceptionList().usesTypeVariable();

  syn lazy boolean FieldDecl.usesTypeVariable() = getTypeAccess().usesTypeVariable();

  syn lazy boolean FieldDeclarator.usesTypeVariable() = getTypeAccess().usesTypeVariable();

  eq TypeAccess.usesTypeVariable() = decl().usesTypeVariable() || super.usesTypeVariable();

  syn lazy boolean TypeDecl.usesTypeVariable() circular [false] =
      isNestedType() && enclosingType().usesTypeVariable();

  eq ParTypeDecl.usesTypeVariable() {
    if (super.usesTypeVariable()) {
      return true;
    }
    for (TypeDecl argument : getParameterization().args) {
      if (argument.usesTypeVariable()) {
        return true;
      }
    }
    return false;
  }

  eq GenericClassDecl.usesTypeVariable() = true;
  eq GenericInterfaceDecl.usesTypeVariable() = true;
  eq TypeVariable.usesTypeVariable() = true;
  eq WildcardExtendsType.usesTypeVariable() = getAccess().type().usesTypeVariable();
  eq WildcardSuperType.usesTypeVariable() = getAccess().type().usesTypeVariable();
  eq ArrayDecl.usesTypeVariable() = elementType().usesTypeVariable();

  /**
   * Substituted local methods.
   *
   * <p>Includes all non-substitutable original methods plus all substituted methods.
   */
  syn lazy java.util.List<MethodDecl> MemberSubstitutor.localMethods() {
    ArrayList<MethodDecl> methods = new ArrayList<MethodDecl>();
    for (MethodDecl m : original().localMethods()) {
      if (!m.isSubstitutable()) {
        methods.add(m);
      }
    }
    for (BodyDecl decl : getBodyDeclList()) {
      if (decl instanceof MethodDecl) {
        methods.add((MethodDecl) decl);
      }
    }
    return methods;
  }

  syn lazy SimpleSet<Variable> MemberSubstitutor.localFields(String name) {
    SimpleSet<Variable> set = emptySet();
    for (Variable field : original().localFields(name)) {
      if (field.name().equals(name)
          && field.fieldDecl() != null && !field.fieldDecl().isSubstitutable()) {
        set = set.add(field);
      }
    }
    for (BodyDecl decl : getBodyDeclList()) {
      if (decl instanceof FieldDecl) {
        FieldDecl field = (FieldDecl) decl;
        for (FieldDeclarator f : field.getDeclaratorList()) {
          if (f.name().equals(name)) {
            set = set.add(f);
          }
        }
      }
    }
    return set;
  }

  inh FieldDecl Variable.fieldDecl();

  eq FieldDecl.getDeclarator().fieldDecl() = this;

  eq VarDeclStmt.getDeclarator().fieldDecl() = null;

  eq EnhancedForStmt.getVariableDecl().fieldDecl() = null;

  eq Program.getChild().fieldDecl() = null;

  syn lazy SimpleSet<TypeDecl> MemberSubstitutor.localTypeDecls(String name) circular [emptySet()] {
    SimpleSet<TypeDecl> set = emptySet();
    for (TypeDecl type : original().localTypeDecls(name)) {
      if (type.isStatic()) {
        set = set.add(type);
      }
    }
    for (BodyDecl decl : getBodyDeclList()) {
      if (decl instanceof MemberClassDecl) {
        ClassDecl typeDecl = ((MemberClassDecl) decl).getClassDecl();
        if (typeDecl.name().equals(name)) {
          set = set.add(typeDecl);
        }
      }
    }
    return set;
  }

  /**
   * Copies the signature of this body decl. The type and name and parameters
   * are copied where applicable, but the body or initializer is not copied.
   */
  public BodyDecl BodyDecl.signatureCopy() {
    throw new Error("Can not susbtitute type parameters in body decl of type "
        + getClass().getSimpleName());
  }

  public BodyDecl MethodDecl.signatureCopy() {
    return new MethodDeclSubstituted(
        getModifiers().treeCopyNoTransform(),
        getTypeAccessNoTransform().treeCopyNoTransform(),
        getID(),
        getParameterList().treeCopyNoTransform(),
        getExceptionList().treeCopyNoTransform(),
        new Opt<Block>(),
        this);
  }

  public BodyDecl GenericMethodDecl.signatureCopy() {
    return new GenericMethodDeclSubstituted(
        getModifiers().treeCopyNoTransform(),
        getTypeAccessNoTransform().treeCopyNoTransform(),
        getID(),
        getParameterList().treeCopyNoTransform(),
        getExceptionList().treeCopyNoTransform(),
        new Opt<Block>(),
        getTypeParameterList().treeCopyNoTransform(),
        this);
  }

  syn GenericMethodDecl GenericMethodDecl.original() = this;

  syn GenericConstructorDecl GenericConstructorDecl.original() = this;

  public BodyDecl ConstructorDecl.signatureCopy() {
    return new ConstructorDeclSubstituted(
        getModifiers().treeCopyNoTransform(),
        getID(),
        getParameterList().treeCopyNoTransform(),
        getExceptionList().treeCopyNoTransform(),
        new Opt(),
        new Block(),
        this);
  }

  public BodyDecl GenericConstructorDecl.signatureCopy() {
    return new GenericConstructorDeclSubstituted(
        getModifiers().treeCopyNoTransform(),
        getID(),
        getParameterList().treeCopyNoTransform(),
        getExceptionList().treeCopyNoTransform(),
        new Opt(),
        new Block(),
        getTypeParameterList().treeCopyNoTransform(),
        this);
  }

  public BodyDecl FieldDecl.signatureCopy() {
    List<FieldDeclarator> decls = new List<FieldDeclarator>();
    for (FieldDeclarator decl : getDeclaratorList()) {
      decls.add(decl.signatureCopy());
    }
    return new FieldDeclSubstituted(
        getModifiers().treeCopyNoTransform(),
        getTypeAccessNoTransform().treeCopyNoTransform(),
        decls,
        this);
  }

  /**
   * Copies the declarator without initializer.
   */
  public FieldDeclarator FieldDeclarator.signatureCopy() {
    return new FieldDeclarator(getID(), getDimsList().treeCopyNoTransform(), new Opt<Expr>());
  }

  public BodyDecl MemberClassDecl.signatureCopy() {
    return new MemberClassDecl(getClassDecl().signatureCopy());
  }

  public ClassDecl ClassDecl.signatureCopy() {
    return new ClassDeclSubstituted(
        getModifiers().treeCopyNoTransform(),
        getID(),
        getSuperClassOpt().treeCopyNoTransform(),
        getImplementsList().treeCopyNoTransform(),
        this);
  }

  public ClassDecl GenericClassDecl.signatureCopy() {
    return new GenericClassDeclSubstituted(
        getModifiers().treeCopyNoTransform(),
        getID(),
        getSuperClassOpt().treeCopyNoTransform(),
        getImplementsList().treeCopyNoTransform(),
        getTypeParameterList().treeCopyNoTransform(),
        this);
  }

  /**
   * Creates an erased copy of the signature of this body declaration.
   *
   * <p>Occurrences of type variables are replaced by their type bound.
   */
  public BodyDecl BodyDecl.erasedCopy() {
    throw new Error("Can not erase types in body decl of type " + getClass().getSimpleName());
  }

  public BodyDecl MethodDecl.erasedCopy() {
    return new MethodDeclSubstituted(
        getModifiers().treeCopyNoTransform(),
        getTypeAccess().erasedCopy(),
        getID(),
        erasedParameterList(getParameterList()),
        erasedAccessList(getExceptionList()),
        new Opt<Block>(),
        this);
  }

  public BodyDecl GenericMethodDecl.erasedCopy() {
    return new GenericMethodDeclErased(
        getModifiers().treeCopyNoTransform(),
        getTypeAccess().erasedCopy(),
        getID(),
        erasedParameterList(getParameterList()),
        erasedAccessList(getExceptionList()),
        new Opt<Block>(),
        getTypeParameterList().treeCopyNoTransform(),
        this);
  }

  public BodyDecl ConstructorDecl.erasedCopy() {
    return new ConstructorDeclSubstituted(
        getModifiers().treeCopyNoTransform(),
        getID(),
        erasedParameterList(getParameterList()),
        erasedAccessList(getExceptionList()),
        new Opt<Stmt>(),
        new Block(),
        this);
  }

  public BodyDecl GenericConstructorDecl.erasedCopy() {
    return new GenericConstructorDeclErased(
        getModifiers().treeCopyNoTransform(),
        getID(),
        erasedParameterList(getParameterList()),
        erasedAccessList(getExceptionList()),
        new Opt<Stmt>(),
        new Block(),
        getTypeParameterList().treeCopyNoTransform(),
        this);
  }

  public BodyDecl FieldDecl.erasedCopy() {
    List<FieldDeclarator> decls = new List<FieldDeclarator>();
    for (FieldDeclarator decl : getDeclaratorList()) {
      decls.add(decl.signatureCopy());
    }
    return new FieldDeclSubstituted(
        getModifiers().treeCopyNoTransform(),
        getTypeAccess().erasedCopy(),
        decls,
        this);
  }

  public BodyDecl MemberClassDecl.erasedCopy() {
    return new MemberClassDecl(getClassDecl().erasedCopy());
  }

  public ClassDecl ClassDecl.erasedCopy() {
    return new ClassDeclErased(
        getModifiers().treeCopyNoTransform(),
        getID(),
        hasSuperClass() ? new Opt<Access>(getSuperClass().erasedCopy()) : new Opt<Access>(),
        erasedAccessList(getImplementsList()),
        this);
  }

  /**
   * Creates a copy of this access where parameterized types have been erased.
   */
  syn Access Access.erasedCopy() = treeCopyNoTransform();

  eq Dot.erasedCopy() = new Dot(getLeft().erasedCopy(), getRight().erasedCopy());

  eq ParTypeAccess.erasedCopy() = getTypeAccess().erasedCopy();

  eq ArrayTypeAccess.erasedCopy() = new ArrayTypeAccess(getAccess().erasedCopy());

  syn Expr Expr.erasedCopy() = treeCopyNoTransform();

  /**
   * Creates a copy of this parameter declaration where parameterized types have been erased.
   */
  syn ParameterDeclaration ParameterDeclaration.erasedCopy() =
      new ParameterDeclaration(
          getModifiers().treeCopyNoTransform(),
          getTypeAccess().erasedCopy(),
          getID());

  eq VariableArityParameterDeclaration.erasedCopy() =
      new VariableArityParameterDeclaration(
          getModifiers().treeCopyNoTransform(),
          getTypeAccess().erasedCopy(),
          getID());

  /**
   * Create a copy of the access list where each access has been erased.
   */
  protected List<Access> ASTNode.erasedAccessList(List<Access> list) {
    List<Access> result = new List<Access>();
    for (Access access : list) {
      result.add(access.erasedCopy());
    }
    return result;
  }

  /**
   * Create a copy of the parameter list where each parameter has been erased.
   */
  protected List<ParameterDeclaration> ASTNode.erasedParameterList(List<ParameterDeclaration> list) {
    List<ParameterDeclaration> result = new List<ParameterDeclaration>();
    for (ParameterDeclaration param : list) {
      result.add(param.erasedCopy());
    }
    return result;
  }

  inh FieldDeclarator FieldDeclarator.erasedField();

  eq FieldDecl.getDeclarator(int index).erasedField() = getDeclarator(index);

  eq FieldDeclSubstituted.getDeclarator(int index).erasedField() =
      getOriginal().getDeclarator(index);

  eq VarDeclStmt.getDeclarator().erasedField() {
    throw new Error("FieldDeclarator child of VarDeclStmt");
  }

  eq EnhancedForStmt.getVariableDecl().erasedField() {
    throw new Error("FieldDeclarator child of EnhancedForStmt");
  }

  syn MethodDecl MethodDecl.erasedMethod() = this;

  eq MethodDeclSubstituted.erasedMethod() = getOriginal().erasedMethod();

  eq ParMethodDecl.erasedMethod() = genericMethodDecl().erasedMethod();

  syn TypeDecl TypeDecl.original() = this;
  eq ClassDeclSubstituted.original() = getOriginal().original();
  eq InterfaceDeclSubstituted.original() = getOriginal().original();
  eq GenericClassDeclSubstituted.original() = getOriginal().original();
  eq GenericInterfaceDeclSubstituted.original() = getOriginal().original();
  eq ParTypeDecl.original() = genericDecl().original();

  // Equations for the BodyDecl NTA:
  syn lazy List<BodyDecl> RawClassDecl.getBodyDeclList() = original().erasedBodyDecls();
  syn lazy List<BodyDecl> RawInterfaceDecl.getBodyDeclList() = original().erasedBodyDecls();
  syn lazy List<BodyDecl> ClassDeclErased.getBodyDeclList() = getOriginal().erasedBodyDecls();
  syn lazy List<BodyDecl> GenericClassDeclErased.getBodyDeclList() =
      getOriginal().erasedBodyDecls();

  /**
   * Builds a list of erased members in a raw type.
   */
  protected List<BodyDecl> TypeDecl.erasedBodyDecls() {
    List<BodyDecl> list = new List<BodyDecl>();
    for (BodyDecl decl : getBodyDeclList()) {
      if (decl.isSubstitutable()) {
        list.add(decl.erasedCopy());
      }
    }
    return list;
  }

  // Equations for the BodyDecl NTA:
  syn lazy List<BodyDecl> ParClassDecl.getBodyDeclList() = original().substitutedBodyDecls();
  syn lazy List<BodyDecl> ParInterfaceDecl.getBodyDeclList() = original().substitutedBodyDecls();
  syn lazy List<BodyDecl> ClassDeclSubstituted.getBodyDeclList() =
      getOriginal().substitutedBodyDecls();
  syn lazy List<BodyDecl> GenericClassDeclSubstituted.getBodyDeclList() =
      getOriginal().substitutedBodyDecls();

  /**
   * Builds a list of substituted members in a parameterized type.
   *
   * <p>The bodies of methods are not copied to the substituted version.
   */
  protected List<BodyDecl> TypeDecl.substitutedBodyDecls() {
    List<BodyDecl> list = new List<BodyDecl>();
    for (BodyDecl decl : getBodyDeclList()) {
      if (decl.isSubstitutable()) {
        list.add(decl.signatureCopy());
      }
    }
    return list;
  }

  syn boolean BodyDecl.isSubstitutable() = false;
  eq MethodDecl.isSubstitutable() = !isStatic();
  eq ConstructorDecl.isSubstitutable() = true;
  eq MemberClassDecl.isSubstitutable() = !isStatic();
  eq FieldDecl.isSubstitutable() = !isStatic();

  syn nta WildcardsCompilationUnit Program.wildcards() =
      new WildcardsCompilationUnit(
          "wildcards",
          new List(),
          new List());

  /**
   * Gives the upper bound for this wildcard type.
   */
  syn TypeDecl WildcardExtendsType.extendsType() = getAccess().type();

  /**
   * Gives the lower bound for this wildcard type.
   */
  syn TypeDecl WildcardSuperType.superType() = getAccess().type();

  eq Wildcard.type() = typeWildcard();
  eq WildcardExtends.type() = lookupWildcardExtends(getAccess().type());
  eq WildcardSuper.type() = lookupWildcardSuper(getAccess().type());
  inh TypeDecl WildcardSuper.lookupWildcardSuper(TypeDecl typeDecl);
  inh TypeDecl WildcardExtends.lookupWildcardExtends(TypeDecl typeDecl);
  inh TypeDecl Wildcard.typeWildcard();

  syn nta TypeDecl WildcardsCompilationUnit.typeWildcard() =
      new WildcardType(
          new Modifiers(new List().add(new Modifier("public"))),
          "?",
          new List());

  inh TypeDecl TypeDecl.typeWildcard();

  eq Program.getChild().typeWildcard() = wildcards().typeWildcard();

  syn nta TypeDecl WildcardsCompilationUnit.lookupWildcardExtends(TypeDecl bound) =
      new WildcardExtendsType(
          new Modifiers(new List().add(new Modifier("public"))),
          "? extends " + bound.name(),
          new List(),
          bound.createBoundAccess());

  eq Program.getChild().lookupWildcardExtends(TypeDecl typeDecl) =
      wildcards().lookupWildcardExtends(typeDecl);

  inh TypeDecl TypeDecl.lookupWildcardExtends(TypeDecl typeDecl);

  syn TypeDecl TypeDecl.asWildcardExtends() = lookupWildcardExtends(this);

  syn nta TypeDecl WildcardsCompilationUnit.lookupWildcardSuper(TypeDecl bound) =
      new WildcardSuperType(
          new Modifiers(new List().add(new Modifier("public"))),
          "? super " + bound.name(),
          new List(),
          bound.createBoundAccess());

  eq Program.getChild().lookupWildcardSuper(TypeDecl typeDecl) =
      wildcards().lookupWildcardSuper(typeDecl);

  inh TypeDecl TypeDecl.lookupWildcardSuper(TypeDecl typeDecl);

  syn TypeDecl TypeDecl.asWildcardSuper() = lookupWildcardSuper(this);

  syn nta LUBType WildcardsCompilationUnit.lookupLUBType(Collection<TypeDecl> bounds) =
      createLUBType(bounds);

  public static LUBType WildcardsCompilationUnit.createLUBType(Collection<TypeDecl> bounds) {
    List<Access> boundList = new List<Access>();
    StringBuilder name = new StringBuilder();
    for (TypeDecl typeDecl : bounds) {
      boundList.add(typeDecl.createBoundAccess());
      name.append("& " + typeDecl.typeName());
    }
    LUBType decl = new LUBType(
      new Modifiers(new List().add(new Modifier("public"))),
      name.toString(),
      new List(),
      boundList
    );
    return decl;
  }

  inh LUBType TypeDecl.lookupLUBType(Collection<TypeDecl> bounds);

  eq Program.getChild().lookupLUBType(Collection<TypeDecl> bounds) =
      wildcards().lookupLUBType(bounds);

  syn String LUBType.typeName() {
    if (getNumTypeBound() == 0) {
      return "<NOTYPE>";
    }
    StringBuilder sb = new StringBuilder();
    sb.append(getTypeBound(0).type().typeName());
    for (int i = 1; i < getNumTypeBound(); i++) {
      sb.append(" & " + getTypeBound(i).type().typeName());
    }
    return sb.toString();
  }

  public Collection<InterfaceDecl> LUBType.implementedInterfaces() {
    Collection<InterfaceDecl> ret = new HashSet<InterfaceDecl>();
    for (int i = 0; i < getNumTypeBound(); i++) {
      ret.addAll(getTypeBound(i).type().implementedInterfaces());
    }
    return ret;
  }

  syn nta GLBType WildcardsCompilationUnit.lookupGLBType(Collection<TypeDecl> bounds) {
    List<Access> boundList = new List<Access>();
    StringBuilder name = new StringBuilder();
    for (TypeDecl typeDecl : bounds) {
      boundList.add(typeDecl.createBoundAccess());
      name.append("& " + typeDecl.typeName());
    }
    GLBType decl = new GLBType(
      new Modifiers(new List().add(new Modifier("public"))),
      name.toString(),
      new List(),
      boundList
    );
    return decl;
  }

  inh GLBType TypeDecl.lookupGLBType(Collection<TypeDecl> bounds);

  eq Program.getChild().lookupGLBType(Collection<TypeDecl> bounds) =
      wildcards().lookupGLBType(bounds);

  syn String GLBType.typeName() {
    if (getNumTypeBound() == 0) {
      return "<NOTYPE>";
    }
    StringBuilder sb = new StringBuilder();
    sb.append(getTypeBound(0).type().typeName());
    for (int i = 1; i < getNumTypeBound(); i++) {
      sb.append(" & " + getTypeBound(i).type().typeName());
    }
    return sb.toString();
  }

  public Collection<InterfaceDecl> GLBType.implementedInterfaces() {
    Collection<InterfaceDecl> ret = new HashSet<InterfaceDecl>();
    for (int i = 0; i < getNumTypeBound(); i++) {
      ret.addAll(getTypeBound(i).type().implementedInterfaces());
    }
    return ret;
  }

}

aspect NewGenerics {

  public Access TypeVariable.createQualifiedAccess() {
    return createBoundAccess();
  }

  eq TypeVariable.accessibleFrom(TypeDecl type) = true;

  eq TypeVariable.typeName() = name();

  eq WildcardType.typeName() = name();

  eq WildcardExtendsType.typeName() = name();

  eq WildcardSuperType.typeName() = name();
}

aspect SourceDeclarations {
  syn lazy TypeDecl TypeDecl.sourceTypeDecl() = this;
  eq ParTypeDecl.sourceTypeDecl() = genericDecl().original().sourceTypeDecl();
  eq ClassDeclSubstituted.sourceTypeDecl() = original().sourceTypeDecl();
  eq InterfaceDeclSubstituted.sourceTypeDecl() = original().sourceTypeDecl();
  eq GenericClassDeclSubstituted.sourceTypeDecl() = original().sourceTypeDecl();
  eq GenericInterfaceDeclSubstituted.sourceTypeDecl() = original().sourceTypeDecl();

  syn lazy MethodDecl MethodDecl.sourceMethodDecl() = this;
  eq ParMethodDecl.sourceMethodDecl() = genericMethodDecl().original().sourceMethodDecl();
  eq MethodDeclSubstituted.sourceMethodDecl() = getOriginal().sourceMethodDecl();

  syn lazy ConstructorDecl ConstructorDecl.sourceConstructorDecl() = this;

  eq ParConstructorDecl.sourceConstructorDecl() =
      genericConstructorDecl().original().sourceConstructorDecl();

  eq ConstructorDeclSubstituted.sourceConstructorDecl() =
      getOriginal().sourceConstructorDecl();
}
