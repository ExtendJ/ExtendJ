/* Copyright (c) 2005-2008, Torbjorn Ekman
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import java.io.*;

aspect JVMBytecodesDebug  {
  class BytecodeDebug extends Bytecode {
    public static String toString(byte code) {
      String res = "";
      switch (code) {
        case NOP: res = "nop";break;
        case ACONST_NULL: res = "aconst_null";break;
        case ICONST_M1: res = "iconst_m1";break;
        case ICONST_0: res = "iconst_0";break;
        case ICONST_1: res = "iconst_1";break;
        case ICONST_2: res = "iconst_2";break;
        case ICONST_3: res = "iconst_3";break;
        case ICONST_4: res = "iconst_4";break;
        case ICONST_5: res = "iconst_5";break;
        case LCONST_0: res = "lconst_0";break;
        case LCONST_1: res = "lconst_1";break;
        case FCONST_0: res = "fconst_0";break;
        case FCONST_1: res = "fconst_1";break;
        case FCONST_2: res = "fconst_2";break;
        case DCONST_0: res = "dconst_0";break;
        case DCONST_1: res = "dconst_1";break;
        case BIPUSH: res = "bipush";break;
        case SIPUSH: res = "sipush";break;
        case LDC: res = "ldc";break;
        case LDC_W: res = "ldc_w";break;
        case LDC2_W: res = "ldc2_w";break;
        case ILOAD: res = "iload";break;
        case LLOAD: res = "lload";break;
        case FLOAD: res = "fload";break;
        case DLOAD: res = "dload";break;
        case ALOAD: res = "aload";break;
        case ILOAD_0: res = "iload_0";break;
        case ILOAD_1: res = "iload_1";break;
        case ILOAD_2: res = "iload_2";break;
        case ILOAD_3: res = "iload_3";break;
        case LLOAD_0: res = "lload_0";break;
        case LLOAD_1: res = "lload_1";break;
        case LLOAD_2: res = "lload_2";break;
        case LLOAD_3: res = "lload_3";break;
        case FLOAD_0: res = "fload_0";break;
        case FLOAD_1: res = "fload_1";break;
        case FLOAD_2: res = "fload_2";break;
        case FLOAD_3: res = "fload_3";break;
        case DLOAD_0: res = "dload_0";break;
        case DLOAD_1: res = "dload_1";break;
        case DLOAD_2: res = "dload_2";break;
        case DLOAD_3: res = "dload_3";break;
        case ALOAD_0: res = "aload_0";break;
        case ALOAD_1: res = "aload_1";break;
        case ALOAD_2: res = "aload_2";break;
        case ALOAD_3: res = "aload_3";break;
        case IALOAD: res = "iaload";break;
        case LALOAD: res = "laload";break;
        case FALOAD: res = "faload";break;
        case DALOAD: res = "daload";break;
        case AALOAD: res = "aaload";break;
        case BALOAD: res = "baload";break;
        case CALOAD: res = "caload";break;
        case SALOAD: res = "saload";break;
        case ISTORE: res = "istore";break;
        case LSTORE: res = "lstore";break;
        case FSTORE: res = "fstore";break;
        case DSTORE: res = "dstore";break;
        case ASTORE: res = "astore";break;
        case ISTORE_0: res = "istore_0";break;
        case ISTORE_1: res = "istore_1";break;
        case ISTORE_2: res = "istore_2";break;
        case ISTORE_3: res = "istore_3";break;
        case LSTORE_0: res = "lstore_0";break;
        case LSTORE_1: res = "lstore_1";break;
        case LSTORE_2: res = "lstore_2";break;
        case LSTORE_3: res = "lstore_3";break;
        case FSTORE_0: res = "fstore_0";break;
        case FSTORE_1: res = "fstore_1";break;
        case FSTORE_2: res = "fstore_2";break;
        case FSTORE_3: res = "fstore_3";break;
        case DSTORE_0: res = "dstore_0";break;
        case DSTORE_1: res = "dstore_1";break;
        case DSTORE_2: res = "dstore_2";break;
        case DSTORE_3: res = "dstore_3";break;
        case ASTORE_0: res = "astore_0";break;
        case ASTORE_1: res = "astore_1";break;
        case ASTORE_2: res = "astore_2";break;
        case ASTORE_3: res = "astore_3";break;
        case IASTORE: res = "iastore";break;
        case LASTORE: res = "lastore";break;
        case FASTORE: res = "fastore";break;
        case DASTORE: res = "dastore";break;
        case AASTORE: res = "aastore";break;
        case BASTORE: res = "bastore";break;
        case CASTORE: res = "castore";break;
        case SASTORE: res = "sastore";break;
        case POP: res = "pop";break;
        case POP2: res = "pop2";break;
        case DUP: res = "dup";break;
        case DUP_X1: res = "dup_x1";break;
        case DUP_X2: res = "dup_x2";break;
        case DUP2: res = "dup2";break;
        case DUP2_X1: res = "dup2_x1";break;
        case DUP2_X2: res = "dup2_x2" ;break;
        case SWAP: res = "swap";break;
        case IADD: res = "iadd";break;
        case LADD: res = "ladd";break;
        case FADD: res = "fadd";break;
        case DADD: res = "dadd";break;
        case ISUB: res = "isub";break;
        case LSUB: res = "lsub";break;
        case FSUB: res = "fsub";break;
        case DSUB: res = "dsub";break;
        case IMUL: res = "imul";break;
        case LMUL: res = "lmul";break;
        case FMUL: res = "fmul";break;
        case DMUL: res = "dmul";break;
        case IDIV: res = "idiv";break;
        case LDIV: res = "ldiv";break;
        case FDIV: res = "fdiv";break;
        case DDIV: res = "ddiv";break;
        case IREM: res = "irem";break;
        case LREM: res = "lrem";break;
        case FREM: res = "frem";break;
        case DREM: res = "drem";break;
        case INEG: res = "ineg";break;
        case LNEG: res = "lneg";break;
        case FNEG: res = "fneg";break;
        case DNEG: res = "dneg";break;
        case ISHL: res = "ishl";break;
        case LSHL: res = "lshl";break;
        case ISHR: res = "ishr";break;
        case LSHR: res = "lshr";break;
        case IUSHR: res = "iushr";break;
        case LUSHR: res = "lushr";break;
        case IAND: res = "iand";break;
        case LAND: res = "land";break;
        case IOR: res = "ior";break;
        case LOR: res = "lor";break;
        case IXOR: res = "ixor";break;
        case LXOR: res = "lxor";break;
        case IINC: res = "iinc";break;
        case I2L: res = "i2l";break;
        case I2F: res = "i2f";break;
        case I2D: res = "i2d";break;
        case L2I: res = "l2i";break;
        case L2F: res = "l2f";break;
        case L2D: res = "l2d";break;
        case F2I: res = "f2i";break;
        case F2L: res = "f2l";break;
        case F2D: res = "f2d";break;
        case D2I: res = "d2i";break;
        case D2L: res = "d2l";break;
        case D2F: res = "d2f";break;
        case I2B: res = "i2b";break;
        case I2C: res = "i2c";break;
        case I2S: res = "i2s";break;
        case LCMP: res = "lcmp";break;
        case FCMPL: res = "fcmpl";break;
        case FCMPG: res = "fcmpg";break;
        case DCMPL: res = "dcmpl";break;
        case DCMPG: res = "dcmpg";break;
        case IFEQ: res = "ifeq";break;
        case IFNE: res = "ifne";break;
        case IFLT: res = "iflt";break;
        case IFGE: res = "ifge";break;
        case IFGT: res = "ifgt";break;
        case IFLE: res = "ifle";break;
        case IF_ICMPEQ: res = "if_icmpeq";break;
        case IF_ICMPNE: res = "if_icmpne";break;
        case IF_ICMPLT: res = "if_icmplt";break;
        case IF_ICMPGE: res = "if_icmpge";break;
        case IF_ICMPGT: res = "if_icmpgt";break;
        case IF_ICMPLE: res = "if_icmple";break;
        case IF_ACMPEQ: res = "if_acmpeq";break;
        case IF_ACMPNE: res = "if_acmpne";break;
        case GOTO: res = "goto";break;
        case JSR: res = "jsr";break;
        case RET: res = "ret";break;
        case TABLESWITCH: res = "tableswitch";break;
        case LOOKUPSWITCH: res = "lookupswitch";break;
        case IRETURN: res = "ireturn";break;
        case LRETURN: res = "lreturn";break;
        case FRETURN: res = "freturn" ;break;
        case DRETURN: res = "dreturn";break;
        case ARETURN: res = "areturn";break;
        case RETURN: res = "return";break;
        case GETSTATIC: res = "getstatic" ;break;
        case PUTSTATIC: res = "putstatic";break;
        case GETFIELD: res = "getfield";break;
        case PUTFIELD: res = "putfield";break;
        case INVOKEVIRTUAL: res = "invokevirtual";break;
        case INVOKESPECIAL: res = "invokespecial";break;
        case INVOKESTATIC: res = "invokestatic";break;
        case INVOKEINTERFACE: res = "invokeinterface";break;
        case NEW: res = "new";break;
        case NEWARRAY: res = "newarray";break;
        case ANEWARRAY: res = "anewarray";break;
        case ARRAYLENGTH: res = "arraylength";break;
        case ATHROW: res = "athrow";break;
        case CHECKCAST: res = "checkcast";break;
        case INSTANCEOF: res = "instanceof";break;
        case MONITORENTER: res = "monitorenter";break;
        case MONITOREXIT: res = "monitorexit";break;
        case WIDE: res = "wide";break;
        case MULTIANEWARRAY: res = "multianewarray";break;
        case IFNULL: res = "ifnull";break;
        case IFNONNULL: res = "ifnonnull";break;
        case GOTO_W: res = "goto_w";break;
        case JSR_W: res = "jsr_w";break;
        case BREAKPOINT: res = "breakpoint";break;
        case IMPDEP1: res = "impdep1";break;
        case IMPDEP2: res = "impdep2";break;
        default: res = "<UNKNOWN BYTECODE:" + code + ">";
      }
      return res;
    }

    private static String getByteOperand(byte[] codes, int index) {
      return Integer.toString((int) codes[index]);
    }

    private static String getCharOperand(byte[] codes, int index) {
      int hi = (codes[index + 0] << 8);
      int lo = ((codes[index + 1] & 0xff) << 0);
      return Integer.toString(hi + lo);
    }

    private static String getIntOperand(byte[] codes, int index) {
      int hh = (codes[index + 0] << 24);
      int hl = ((codes[index + 1] & 0xff) << 16);
      int lh = ((codes[index + 2] & 0xff) << 8);
      int ll = ((codes[index + 3] & 0xff) << 0);
      return Integer.toString(hh + hl + lh + ll);
    }

    public static String getOperands(byte[] codes, int index) {
      String res = "";
      switch(codes[index])
      {
        case NOP:
        case ACONST_NULL:
        case ICONST_M1:
        case ICONST_0:
        case ICONST_1:
        case ICONST_2:
        case ICONST_3:
        case ICONST_4:
        case ICONST_5:
        case LCONST_0:
        case LCONST_1:
        case FCONST_0:
        case FCONST_1:
        case FCONST_2:
        case DCONST_0:
        case DCONST_1:
          break;
        case BIPUSH:
          res = getByteOperand(codes, index + 1);
          break;
        case SIPUSH:
          res = getCharOperand(codes, index + 1);
          break;
        case LDC:
          res = getByteOperand(codes, index + 1);
          break;
        case LDC_W:
        case LDC2_W:
          res = getCharOperand(codes, index + 1);
          break;
        case ILOAD:
        case LLOAD:
        case FLOAD:
        case DLOAD:
        case ALOAD:
          res = getByteOperand(codes, index + 1);
          break;
        case ILOAD_0:
        case ILOAD_1:
        case ILOAD_2:
        case ILOAD_3:
        case LLOAD_0:
        case LLOAD_1:
        case LLOAD_2:
        case LLOAD_3:
        case FLOAD_0:
        case FLOAD_1:
        case FLOAD_2:
        case FLOAD_3:
        case DLOAD_0:
        case DLOAD_1:
        case DLOAD_2:
        case DLOAD_3:
        case ALOAD_0:
        case ALOAD_1:
        case ALOAD_2:
        case ALOAD_3:
        case IALOAD:
        case LALOAD:
        case FALOAD:
        case DALOAD:
        case AALOAD:
        case BALOAD:
        case CALOAD:
        case SALOAD:
          break;
        case ISTORE:
        case LSTORE:
        case FSTORE:
        case DSTORE:
        case ASTORE:
          res = getByteOperand(codes, index + 1);
          break;
        case ISTORE_0:
        case ISTORE_1:
        case ISTORE_2:
        case ISTORE_3:
        case LSTORE_0:
        case LSTORE_1:
        case LSTORE_2:
        case LSTORE_3:
        case FSTORE_0:
        case FSTORE_1:
        case FSTORE_2:
        case FSTORE_3:
        case DSTORE_0:
        case DSTORE_1:
        case DSTORE_2:
        case DSTORE_3:
        case ASTORE_0:
        case ASTORE_1:
        case ASTORE_2:
        case ASTORE_3:
        case IASTORE:
        case LASTORE:
        case FASTORE:
        case DASTORE:
        case AASTORE:
        case BASTORE:
        case CASTORE:
        case SASTORE:
        case POP:
        case POP2:
        case DUP:
        case DUP_X1:
        case DUP_X2:
        case DUP2:
        case DUP2_X1:
        case DUP2_X2:
        case SWAP:
        case IADD:
        case LADD:
        case FADD:
        case DADD:
        case ISUB:
        case LSUB:
        case FSUB:
        case DSUB:
        case IMUL:
        case LMUL:
        case FMUL:
        case DMUL:
        case IDIV:
        case LDIV:
        case FDIV:
        case DDIV:
        case IREM:
        case LREM:
        case FREM:
        case DREM:
        case INEG:
        case LNEG:
        case FNEG:
        case DNEG:
        case ISHL:
        case LSHL:
        case ISHR:
        case LSHR:
        case IUSHR:
        case LUSHR:
        case IAND:
        case LAND:
        case IOR:
        case LOR:
        case IXOR:
        case LXOR:
          break;
        case IINC:
          res = getByteOperand(codes, index + 1) + " " + getByteOperand(codes, index + 2);
          break;
        case I2L:
        case I2F:
        case I2D:
        case L2I:
        case L2F:
        case L2D:
        case F2I:
        case F2L:
        case F2D:
        case D2I:
        case D2L:
        case D2F:
        case I2B:
        case I2C:
        case I2S:
        case LCMP:
        case FCMPL:
        case FCMPG:
        case DCMPL:
        case DCMPG:
          break;
        case IFEQ:
        case IFNE:
        case IFLT:
        case IFGE:
        case IFGT:
        case IFLE:
        case IF_ICMPEQ:
        case IF_ICMPNE:
        case IF_ICMPLT:
        case IF_ICMPGE:
        case IF_ICMPGT:
        case IF_ICMPLE:
        case IF_ACMPEQ:
        case IF_ACMPNE:
        case GOTO:
        case JSR:
          res = getCharOperand(codes, index + 1);
          break;
        case RET:
          res = getByteOperand(codes, index + 1);
          break;
        case TABLESWITCH:
          {
            int db = ((index + 4) / 4) * 4; // Align-4, step to defaultbytes.
            int val = fourByteToInt(codes, db);
            db += 4;
            res = "defaultbytes:" + val;
            int low = fourByteToInt(codes, db);
            db += 4;
            res += ", low:" + low;
            int high = fourByteToInt(codes, db);
            db += 4;
            res += ", high:" + high;
            for (int i = 0; i < (high - low + 1); i++) {
              res += "\n\t" + "offset:" + fourByteToInt(codes, db + i * 4);
            }
          }
          break;
        case LOOKUPSWITCH:
          {
            int db = ((index + 4) / 4) * 4; // Align-4, step to defaultbytes.
            int val = fourByteToInt(codes, db);
            db += 4;
            res = "defaultbytes:" + val;
            int npairs = fourByteToInt(codes, db);
            db += 4;
            res += ", npairs:" + npairs;
            for (int i = 0; i < npairs; i++) {
              res += "\n\t" + "match:" + fourByteToInt(codes, db + i * 8) + ", offset:"
                  + fourByteToInt(codes, db + i * 8 + 4);
            }
          }
          break;
        case IRETURN: break;
        case LRETURN: break;
        case FRETURN: break;
        case DRETURN: break;
        case ARETURN: break;
        case RETURN: break;
        case GETSTATIC:
        case PUTSTATIC:
        case GETFIELD:
        case PUTFIELD:
        case INVOKEVIRTUAL:
        case INVOKESPECIAL:
        case INVOKESTATIC:
          res = getCharOperand(codes, index + 1);
          break;
        case INVOKEINTERFACE:
          res = getCharOperand(codes, index + 1) + " " + getByteOperand(codes, index + 3);
          break;
        case NEW:
          res = getCharOperand(codes, index + 1);
          break;
        case NEWARRAY:
          res = getByteOperand(codes, index + 1);
          break;
        case ANEWARRAY:
          res = getCharOperand(codes, index + 1);
          break;
        case ARRAYLENGTH:
          break;
        case ATHROW:
          break;
        case CHECKCAST:
          res = getCharOperand(codes, index + 1);
          break;
        case INSTANCEOF:
          res = getCharOperand(codes, index + 1);
          break;
        case MONITORENTER:
          break;
        case MONITOREXIT:
          break;
        case WIDE:
          res = "XXX";
          break;
        case MULTIANEWARRAY:
          res = getCharOperand(codes, index + 1) + " " + getByteOperand(codes, index + 3);
          break;
        case IFNULL:
          res = getCharOperand(codes, index + 1);
          break;
        case IFNONNULL:
          res = getCharOperand(codes, index + 1);
          break;
        case GOTO_W:
          res = getIntOperand(codes, index + 1);
          break;
        case JSR_W:
          res = getIntOperand(codes, index + 1);
          break;
        case BREAKPOINT:
          break;
        case IMPDEP1:
          break;
        case IMPDEP2:
          break;
        default:
          res = "<UNKNOWN BYTECODE:" + codes[index] + ">";
      }
      return res;
    }

    public static int fourByteToInt(byte[] codes, int pos) {
      int b1 = (int) codes[pos + 0];
      int b2 = (int) codes[pos + 1];
      int b3 = (int) codes[pos + 2];
      int b4 = (int) codes[pos + 3];
      int val = b1 << 24 | b2 << 16 | b3 << 8 | b4;
      return val;
    }

    public static int stepBytecode(byte[] codes, int index)
    {
      int res = 0;

      switch (codes[index]) {
        case NOP:res++;break;
        case ACONST_NULL:res++;break;
        case LDC2_W:
        case LDC_W:res+=3;break;
        case LDC:res+=2;break;
        case DCONST_0:
        case DCONST_1:
        case LCONST_0:
        case LCONST_1:res++;break;
        case BIPUSH:res+=2;break;
        case SIPUSH:res+=3;break;
        case FCONST_1:
        case FCONST_2:
        case FCONST_0:
        case ICONST_M1:
        case ICONST_0:
        case ICONST_1:
        case ICONST_2:
        case ICONST_3:
        case ICONST_4:
        case ICONST_5:res++;break;
        case FALOAD:
        case BALOAD:
        case CALOAD:
        case SALOAD:
        case IALOAD:res++;break;
        case DALOAD:
        case LALOAD:res++;break;
        case AALOAD:res++;break;
        case FLOAD:
        case FSTORE:
        case ILOAD:
        case ISTORE:res+=2;break;
        case FLOAD_0:
        case FSTORE_0:
        case ILOAD_0:
        case ISTORE_0:res++;break;
        case FLOAD_1:
        case FSTORE_1:
        case ILOAD_1:
        case ISTORE_1:res++;break;
        case FLOAD_2:
        case FSTORE_2:
        case ILOAD_2:
        case ISTORE_2:res++;break;
        case FLOAD_3:
        case FSTORE_3:
        case ILOAD_3:
        case ISTORE_3:res++;break;
        case DLOAD:
        case DSTORE:
        case LLOAD:
        case LSTORE:res+=2;break;
        case DLOAD_0:
        case DSTORE_0:
        case LLOAD_0:
        case LSTORE_0:res++;break;
        case DLOAD_1:
        case DSTORE_1:
        case LLOAD_1:
        case LSTORE_1:res++;break;
        case DLOAD_2:
        case DSTORE_2:
        case LLOAD_2:
        case LSTORE_2:res++;break;
        case DLOAD_3:
        case DSTORE_3:
        case LLOAD_3:
        case LSTORE_3:res++;break;
        case ALOAD:
        case ASTORE:res+=2;break;
        case ALOAD_0:
        case ASTORE_0:res++;break;
        case ALOAD_1:
        case ASTORE_1:res++;break;
        case ALOAD_2:
        case ASTORE_2:res++;break;
        case ALOAD_3:
        case ASTORE_3:res++;break;
        case FASTORE:
        case IASTORE:res++;break;
        case DASTORE:
        case LASTORE:res++;break;
        case AASTORE:res++;break;
        case BASTORE:res++;break;
        case CASTORE:
        case SASTORE:res++;break;
        case POP:res++;break;
        case POP2:res++;break;
        case DUP:res++;break;
        case DUP_X1:res++;break;
        case DUP_X2:res++;break;
        case DUP2:res++;break;
        case DUP2_X1:res++;break;
        case DUP2_X2:res++;break;
        case SWAP:res++;break;
        case IADD:res++;break;
        case FADD:res++;break;
        case DADD:res++;break;
        case LADD:res++;break;
        case ISUB:res++;break;
        case FSUB:res++;break;
        case DSUB:res++;break;
        case LSUB:res++;break;
        case IMUL:res++;break;
        case LMUL:res++;break;
        case DMUL:res++;break;
        case FMUL:res++;break;
        case IDIV:res++;break;
        case LDIV:res++;break;
        case DDIV:res++;break;
        case FDIV:res++;break;
        case IREM:res++;break;
        case LREM:res++;break;
        case DREM:res++;break;
        case FREM:res++;break;
        case INEG:res++;break;
        case LNEG:res++;break;
        case DNEG:res++;break;
        case FNEG:res++;break;
        case ISHL:res++;break;
        case LSHL:res++;break;
        case ISHR:res++;break;
        case LSHR:res++;break;
        case IUSHR:res++;break;
        case LUSHR:res++;break;
        case IAND:res++;break;
        case LAND:res++;break;
        case IOR:res++;break;
        case LOR:res++;break;
        case IXOR:res++;break;
        case LXOR:res++;break;
        case IINC:res+=3;break;
        case I2L:res++;break;
        case I2F:res++;break;
        case I2D:res++;break;
        case L2I:res++;break;
        case L2F:res++;break;
        case L2D:res++;break;
        case F2I:res++;break;
        case F2L:res++;break;
        case F2D:res++;break;
        case D2I:res++;break;
        case D2L:res++;break;
        case D2F:res++;break;
        case I2B:res++;break;
        case I2C:res++;break;
        case I2S:res++;break;
        case LCMP:res++;break;
        case FCMPL:res++;break;
        case FCMPG:res++;break;
        case DCMPL:res++;break;
        case DCMPG:res++;break;
        case IFEQ:res+=3;break;
        case IFNE:res+=3;break;
        case IFLT:res+=3;break;
        case IFGE:res+=3;break;
        case IFGT:res+=3;break;
        case IFLE:res+=3;break;
        case IF_ICMPEQ:res+=3;break;
        case IF_ICMPNE:res+=3;break;
        case IF_ICMPLT:res+=3;break;
        case IF_ICMPGE:res+=3;break;
        case IF_ICMPGT:res+=3;break;
        case IF_ICMPLE:res+=3;break;
        case IF_ACMPEQ:res+=3;break;
        case IF_ACMPNE:res+=3;break;
        case GOTO:res+=3;break;
        case JSR:res+=3;break;
        case RET:res+=2;break;
        case TABLESWITCH:
                 {
                   int db = ((index + 4) / 4) * 4; // Align-4, step to defaultbytes
                   db += 4;
                   int low = fourByteToInt(codes, db);
                   db += 4;
                   int high = fourByteToInt(codes, db);
                   db += 4;
                   db += (high-low+1)*4;
                   res = db;
                 }
                 break;
        case LOOKUPSWITCH:
                 {
                   int db = ((index + 4) / 4) * 4; // Align-4, step to defaultbytes
                   db += 4;
                   int np = fourByteToInt(codes, db);
                   db += 4;
                   db += np * 8;
                   res = db;
                 }
                 break;
        case FRETURN:
        case IRETURN:res++;break;
        case LRETURN:
        case DRETURN:res++;break;
        case ARETURN:res++;break;
        case RETURN:res++;break;
        case GETSTATIC:
        case PUTSTATIC:
        case GETFIELD:
        case PUTFIELD:res+=3;break;
        case INVOKEVIRTUAL:res+=3;break;
        case INVOKESPECIAL:res+=3;break;
        case INVOKESTATIC:res+=3;break;
        case INVOKEINTERFACE:res+=5;break;
        case NEW:res+=3; break;
        case NEWARRAY:res+=2;break;
        case ANEWARRAY:res+=3;break;
        case ARRAYLENGTH:res++;break;
        case ATHROW:res++;break;
        case CHECKCAST:res+=3;break;
        case INSTANCEOF:res+=3;break;
        case MONITORENTER:res++;break;
        case MONITOREXIT:res++;break;
        case WIDE:
           switch (codes[index + 1])
           {
             case ILOAD:res+=4;break;
             case FLOAD:res+=4;break;
             case ALOAD:res+=4;break;
             case LLOAD:res+=4;break;
             case DLOAD:res+=4;break;
             case ISTORE:res+=4;break;
             case FSTORE:res+=4;break;
             case ASTORE:res+=4;break;
             case LSTORE:res+=4;break;
             case DSTORE:res+=4;break;
             case RET:res+=4;break;
             case IINC:res+=6;break;
             default:System.err.println("ERROR_INVALID_OPCODE in stepBytecode (wide)");break;
           }
           break;
        case MULTIANEWARRAY:res+=4;break;
        case IFNULL:res+=3;break;
        case IFNONNULL:res+=3;break;
        case GOTO_W:res+=5;break;
        case JSR_W:res+=5;break;
        default:res++;System.err.println("INVALID BYTECODE " + codes[index] + " IN stepBytecode");
      }
      return res;
    }

    public static void printBytecode(PrintStream p, byte[] bytes, int index) {
      p.print(toString(bytes[index])+" "+getOperands(bytes, index));
    }

    public static void printBytecodes(PrintStream p, byte[] bytes, int start, int end) {
      for (int i = start, cnt = 1; i < end; i += stepBytecode(bytes, i), cnt++) {
        p.print("\t" + i + "\t" + cnt + "\t");
        printBytecode(p, bytes, i);
        p.println();
      }
    }

    public static void printBytecodes(PrintStream p, byte[] bytes) {
      for (int i = 0, cnt = 1; i < bytes.length; i += stepBytecode(bytes, i), cnt++) {
        p.print("\t" + i + "\t" + cnt + "\t");
        printBytecode(p, bytes, i);
        p.println();
      }
    }

    public static void appendBytecodes(StringBuffer p, byte[] bytes) {
      for (int i = 0, cnt = 1; i < bytes.length; i += stepBytecode(bytes, i), cnt++) {
        p.append(" " + i + " " + cnt + "\t");
        p.append(toString(bytes[i])+" "+getOperands(bytes, i));
        p.append("\n");
      }
    }
  }
}
