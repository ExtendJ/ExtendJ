/* Copyright (c) 2005-2008, Torbjorn Ekman
 *               2013-2016, Jesper Ã–qvist <jesper.oqvist@cs.lth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import java.util.*;
import java.io.*;

aspect CreateBCode {

  inh TypeDecl CatchClause.hostType();

  public abstract void CatchClause.exceptionTableEntries(CodeGeneration gen,
      int begin_lbl, int end_lbl);

  public void BasicCatch.exceptionTableEntries(CodeGeneration gen, int begin_lbl, int end_lbl) {
    gen.addException(
        begin_lbl,
        end_lbl,
        label(),
        gen.constantPool().addClass(getParameter().type().constantPoolName()));
  }

  syn lazy boolean TypeDecl.hasClinit() {
    for (BodyDecl b : getBodyDeclList()) {
      if (b instanceof FieldDecl) {
        FieldDecl field = (FieldDecl) b;
        if (field.isStatic() && field.hasInit()) {
          return true;
        }
      } else if (b instanceof StaticInitializer) {
        return true;
      }
    }
    return hasAssertStatement(); // Check if we need to initialize the $assertionsDisabled field.
  }

  /**
   * @return {@code true} if any of the contained field declarations has an
   * initializer
   */
  syn lazy boolean FieldDecl.hasInit() {
    for (FieldDeclarator decl : getDeclaratorList()) {
      if (decl.hasInit()) {
        return true;
      }
    }
    return false;
  }

  syn lazy CodeGeneration TypeDecl.bytecodes(ConstantPool constantPool) {
    CodeGeneration gen = new CodeGeneration(constantPool);
    try {
      generateBytecodes(gen);
    } catch (CodeGeneration.JumpOffsetError e) {
      // Retry with wide gotos.
      gen = new CodeGeneration(constantPool, true);
      generateBytecodes(gen);
    }
    return gen;
  }

  /**
   * Generates static initializer bytecode.
   */
  protected void TypeDecl.generateBytecodes(CodeGeneration gen) {
    for (BodyDecl b : getBodyDeclList()) {
      if (b instanceof FieldDecl) {
        FieldDecl field = (FieldDecl) b;
        if (field.isStatic()) {
          for (FieldDeclarator decl : field.getDeclaratorList()) {
            if (decl.hasInit()) {
              decl.emitInitializerBCode(gen);
              emitStoreField(gen, decl, this);
            }
          }
        }
      } else if (b instanceof StaticInitializer) {
        b.createBCode(gen);
      }
    }
    if (hasAssertStatement()) {
      assertionsDisabled().emitInitializerBCode(gen);
      emitStoreField(gen, assertionsDisabled(), this);
    }
    gen.emitReturn();
  }

  syn lazy CodeGeneration MethodDecl.bytecodes(ConstantPool constantPool) {
    CodeGeneration gen = new CodeGeneration(constantPool);
    try {
      generateBytecodes(gen);
    } catch (CodeGeneration.JumpOffsetError e) {
      // Retry with wide gotos.
      gen = new CodeGeneration(constantPool, true);
      generateBytecodes(gen);
    }
    return gen;
  }

  private void MethodDecl.generateBytecodes(CodeGeneration gen) {
    int label = gen.variableScopeLabel();
    int paramLength = 0;
    if (!isStatic()) {
      paramLength += 1;
      gen.addLocalVariableEntryAtCurrentPC("this", hostType(), 0, label);
    }
    for (ParameterDeclaration p : getParameterList()) {
      paramLength += p.type().variableSize();
      if (paramLength > 255) {
        throw new Error("parameter list too large");
      }
      gen.addLocalVariableEntryAtCurrentPC(p.name(), p.type(), p.localNum(), label);
    }
    createBCode(gen);
    if (type().isVoid() && (!hasBlock() || getBlock().canCompleteNormally())) {
      gen.emitReturn();
    }
    gen.addVariableScopeLabel(label);
  }

  syn lazy CodeGeneration ConstructorDecl.bytecodes(ConstantPool constantPool) {
    CodeGeneration gen = new CodeGeneration(constantPool);
    try {
      generateBytecodes(gen);
    } catch (CodeGeneration.JumpOffsetError e) {
      // Retry with wide gotos.
      gen = new CodeGeneration(constantPool, true);
      generateBytecodes(gen);
    }
    return gen;
  }

  private void ConstructorDecl.generateBytecodes(CodeGeneration gen) {
    int label = gen.variableScopeLabel();
    int paramLength = 1;
    gen.addLocalVariableEntryAtCurrentPC("this", hostType(), 0, label);
    for (ParameterDeclaration p : getParameterList()) {
      paramLength += p.type().variableSize();
      if (paramLength > 255) {
        throw new Error("parameter list too large");
      }
      gen.addLocalVariableEntryAtCurrentPC(p.name(), p.type(), p.localNum(), label);
    }
    int nextLocal = offsetFirstEnclosingVariable();
    for (Variable var : hostType().enclosingVariables()) {
      paramLength += var.type().variableSize();
      if (paramLength > 255) {
        throw new Error("parameter list too large, not enough room for enclosing variables");
      }
      gen.addLocalVariableEntryAtCurrentPC("val$" + var.name(), var.type(), nextLocal, label);
      nextLocal += var.type().variableSize();
    }
    createBCode(gen);
    gen.emitReturn();
    gen.addVariableScopeLabel(label);
  }

  public void MethodDecl.createBCode(CodeGeneration gen) {
    try {
      if (hasBlock()) {
        gen.maxLocals = Math.max(gen.maxLocals, getBlock().localNum());
        getBlock().createBCode(gen);
      }
    } catch (Error e) {
      System.err.println(hostType().typeName() + ": " + this);
      throw e;
    }
  }

  public void ConstructorDecl.createBCode(CodeGeneration gen) {
    try {
      boolean needsInit = true;

      if (hasConstructorInvocation()) {
        getConstructorInvocation().createBCode(gen);
        Stmt stmt = getConstructorInvocation();
        if (stmt instanceof ExprStmt) {
          ExprStmt exprStmt = (ExprStmt) stmt;
          Expr expr = exprStmt.getExpr();
          if (!expr.isSuperConstructorAccess()) {
            needsInit = false;
          }
        }
      }

      if (needsEnclosing()) {
        gen.emitLoadReference(0);
        gen.emitLoadReference(1);
        String classname = hostType().constantPoolName();
        String name = "this$0";
        int index = gen.constantPool().addFieldref(classname, name, enclosing());
        gen.emit(Bytecode.PUTFIELD, -2).add2(index);
      }

      int localIndex = offsetFirstEnclosingVariable();
      for (Variable v : hostType().enclosingVariables()) {
        gen.emitLoadReference(0);
        v.type().emitLoadLocal(gen, localIndex);
        String classname = hostType().constantPoolName();
        String name = "val$" + v.name();
        int index = gen.constantPool().addFieldref(classname, name, v.type());
        gen.emit(Bytecode.PUTFIELD, -1 - v.type().variableSize()).add2(index);
        localIndex += v.type().variableSize();
      }

      if (needsInit) {
        TypeDecl typeDecl = hostType();
        for (BodyDecl b : typeDecl.getBodyDeclList()) {
          if (b instanceof FieldDecl) {
            FieldDecl field = (FieldDecl) b;
            if (!field.isStatic()) {
              for (FieldDeclarator decl : field.getDeclaratorList()) {
                if (decl.hasInit()) {
                  gen.emit(Bytecode.ALOAD_0);
                  decl.emitInitializerBCode(gen);
                  emitStoreField(gen, decl, hostType());
                }
              }
            }
          } else if (b instanceof InstanceInitializer) {
            b.createBCode(gen);
          }
        }
      }
      gen.maxLocals = Math.max(gen.maxLocals, getBlock().localNum());
      getBlock().createBCode(gen);
    } catch (Error e) {
      System.err.println(hostType().typeName() + ": " + this);
      throw e;
    }
  }

  public void ASTNode.createBCode(CodeGeneration gen) {
    for (int i = 0; i < getNumChild(); i++) {
      getChild(i).createBCode(gen);
    }
  }

  public void Literal.createBCode(CodeGeneration gen) {
    emitPushConstant(gen);
  }

  protected boolean Expr.needsPush() {
    ASTNode n = getParent();
    while (n instanceof ParExpr) {
      n = n.getParent();
    }
    return !(n instanceof ExprStmt);
  }

  syn boolean ExprStmt.needsPop() = getExpr().needsPop();

  syn boolean Expr.needsPop() = true;

  eq Dot.needsPop() = lastAccess().needsPop();

  eq ConstructorAccess.needsPop() = false;

  eq ParExpr.needsPop() = getExpr().needsPop();
  eq AssignExpr.needsPop() = getDest().isVarAccessWithAccessor();
  eq PreIncExpr.needsPop() = false;
  eq PostIncExpr.needsPop() = getOperand().isVarAccessWithAccessor();
  eq PreDecExpr.needsPop() = false;
  eq PostDecExpr.needsPop() = getOperand().isVarAccessWithAccessor();

  syn boolean Expr.isVarAccessWithAccessor() = false;
  eq ParExpr.isVarAccessWithAccessor() = getExpr().isVarAccessWithAccessor();
  eq Dot.isVarAccessWithAccessor() = lastAccess().isVarAccessWithAccessor();
  eq VarAccess.isVarAccessWithAccessor() = decl().isInstanceVariable() && requiresAccessor();

  public void VarDeclStmt.createBCode(CodeGeneration gen) {
    gen.addLineNumberEntryAtCurrentPC(this); // Generate line number entry.
    for (VariableDeclarator decl : getDeclaratorList()) {
      decl.createBCode(gen);
    }
  }

  public void VariableDeclarator.createBCode(CodeGeneration gen) {
    if (hasInit()) {
      gen.addLocalVariableEntryAtCurrentPC(name(), type(), localNum(), variableScopeEndLabel(gen));
      emitInitializerBCode(gen);
      type().emitStoreLocal(gen, localNum());
    }
  }

  /**
   * Generate variable initialization bytecode.
   */
  protected void Declarator.emitInitializerBCode(CodeGeneration gen) {
    getInit().createBCode(gen);
    getInit().type().emitAssignConvTo(gen, type());
  }

  /**
   * Create bytecode for a simple assign expression.
   */
  public void AssignSimpleExpr.createBCode(CodeGeneration gen) {
    getDest().createAssignSimpleLoadDest(gen);
    getSource().createBCode(gen);
    getSource().type().emitAssignConvTo(gen, getDest().type()); // Assignment conversion.
    if (needsPush()) {
      getDest().createPushAssignmentResult(gen);
    }
    getDest().emitStore(gen);
  }

  /**
   * Create bytecode for a compund assign expression.
   */
  public void AssignExpr.createBCode(CodeGeneration gen) {
    TypeDecl dest = getDest().type();
    TypeDecl source = getSource().type();
    TypeDecl type;
    if (dest.isNumericType() && source.isNumericType()) {
      type = dest.binaryNumericPromotion(source);
    } else {
      type = dest;
    }
    getDest().createAssignLoadDest(gen);
    dest.emitCastTo(gen, type);
    getSource().createBCode(gen);
    source.emitCastTo(gen, type);
    createAssignOp(gen, type);
    type.emitCastTo(gen, dest);
    if (needsPush()) {
      getDest().createPushAssignmentResult(gen);
    }
    getDest().emitStore(gen);
  }

  // Generate code for String addition assignment expression.
  public void AssignPlusExpr.createBCode(CodeGeneration gen) {
    // TODO(joqvist): use StringBuilder instead of StringBuffer (StringBuilder is not concurrent).
    TypeDecl dest = getDest().type();
    TypeDecl source = getSource().type();
    if (dest.isString()) {
      getDest().createAssignLoadDest(gen);

      // Emit new StringBuffer()
      TypeDecl stringBuffer = lookupType("java.lang", "StringBuffer");
      String classname = stringBuffer.constantPoolName();
      String desc;
      int index;
      TypeDecl argumentType;
      stringBuffer.emitNew(gen);
      gen.emitDup();
      desc = "()V";
      index = gen.constantPool().addMethodref(classname, "<init>", desc);
      gen.emit(Bytecode.INVOKESPECIAL, -1).add2(index);

      gen.emitSwap();

      // Emit .append().
      argumentType = dest.stringPromotion();
      desc = "(" + argumentType.typeDescriptor() + ")" + stringBuffer.typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "append", desc);
      gen.emit(Bytecode.INVOKEVIRTUAL, -argumentType.variableSize()).add2(index);

      getSource().createBCode(gen);

      // Typed append.
      argumentType = source.stringPromotion();
      desc = "(" + argumentType.typeDescriptor() + ")" + stringBuffer.typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "append", desc);
      gen.emit(Bytecode.INVOKEVIRTUAL, -argumentType.variableSize()).add2(index);

      // Call StringBuffer.toString().
      desc = "()" + type().typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "toString", desc);
      gen.emit(Bytecode.INVOKEVIRTUAL, 0).add2(index);

      if (needsPush()) {
        getDest().createPushAssignmentResult(gen);
      }
      getDest().emitStore(gen);
    } else {
      super.createBCode(gen);
    }
  }

  // Shift assignment expression.
  public void AssignExpr.emitShiftExpr(CodeGeneration gen) {
    TypeDecl dest = getDest().type();
    TypeDecl source = getSource().type();
    TypeDecl type = dest.unaryNumericPromotion();
    getDest().createAssignLoadDest(gen);
    dest.emitCastTo(gen, type);
    getSource().createBCode(gen);
    source.emitCastTo(gen, typeInt());
    createAssignOp(gen, type);
    type.emitCastTo(gen, dest);
    if (needsPush()) {
      getDest().createPushAssignmentResult(gen);
    }
    getDest().emitStore(gen);
  }

  public void AssignLShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  public void AssignRShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  public void AssignURShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  // Load left hand side of destination in a simple assign expression.
  public void Expr.createAssignSimpleLoadDest(CodeGeneration gen) {
  }

  public void Dot.createAssignSimpleLoadDest(CodeGeneration gen) {
    lastAccess().createAssignSimpleLoadDest(gen);
  }

  public void VarAccess.createAssignSimpleLoadDest(CodeGeneration gen) {
    createLoadQualifier(gen, decl());
  }

  public void ArrayAccess.createAssignSimpleLoadDest(CodeGeneration gen) {
    prevExpr().createBCode(gen);
    getExpr().createBCode(gen);
  }

  /**
   * Duplicate top value on stack and store below destination element.
   */
  public void Expr.createPushAssignmentResult(CodeGeneration gen) {
  }

  public void Dot.createPushAssignmentResult(CodeGeneration gen) {
    lastAccess().createPushAssignmentResult(gen);
  }

  public void VarAccess.createPushAssignmentResult(CodeGeneration gen) {
    if (hostType().needsAccessorFor(decl())) {
      return;
    }
    if (decl().isInstanceVariable()) {
      type().emitDup_x1(gen);
    } else {
      type().emitDup(gen);
    }
  }

  public void ArrayAccess.createPushAssignmentResult(CodeGeneration gen) {
    type().emitDup_x2(gen);
  }

  // Load left hand side of destination in a compound assign expression.
  public void Expr.createAssignLoadDest(CodeGeneration gen) {
  }

  public void Dot.createAssignLoadDest(CodeGeneration gen) {
    lastAccess().createAssignLoadDest(gen);
  }

  public void VarAccess.createAssignLoadDest(CodeGeneration gen) {
    createLoadQualifier(gen, decl());
    Variable v = decl();
    if (v.isInstanceVariable()) {
      gen.emitDup();
    }
    if (v instanceof VariableDeclarator) {
      VariableDeclarator var = (VariableDeclarator) v;
      var.type().emitLoadLocal(gen, var.localNum());
    } else if (v.isField()) {
      if (requiresAccessor()) {
        fieldQualifierType().fieldAccessor(v).emitInvokeMethod(gen, fieldQualifierType());
      } else {
        emitLoadField(gen, v, fieldQualifierType());
      }
    } else if (v instanceof ParameterDeclaration) {
      ParameterDeclaration decl = (ParameterDeclaration) v;
      decl.type().emitLoadLocal(gen, decl.localNum());
    }
  }

  public void ArrayAccess.createAssignLoadDest(CodeGeneration gen) {
    prevExpr().createBCode(gen);
    gen.emitDup();
    getExpr().createBCode(gen);
    typeInt().emitDup_x1(gen);
    gen.emit(type().arrayLoad());
  }

  /** Select the typed operation for a compound assign expression. */
  public void AssignExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    throw new Error("Operation createAssignOp is not implemented for " + getClass().getName());
  }

  public void AssignMulExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.mul(gen);
  }

  public void AssignDivExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.div(gen);
  }

  public void AssignModExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.rem(gen);
  }

  public void AssignPlusExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.add(gen);
  }

  public void AssignMinusExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.sub(gen);
  }

  public void AssignLShiftExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.shl(gen);
  }

  public void AssignRShiftExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.shr(gen);
  }

  public void AssignURShiftExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.ushr(gen);
  }

  public void AssignAndExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.bitand(gen);
  }

  public void AssignXorExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.bitxor(gen);
  }

  public void AssignOrExpr.createAssignOp(CodeGeneration gen, TypeDecl type) {
    type.bitor(gen);
  }

  public void Dot.createBCode(CodeGeneration gen) {
    if (transformed() != this) {
      transformed().createBCode(gen);
    } else {
      getRight().createBCode(gen);
    }
  }

  public void VarAccess.createBCode(CodeGeneration gen) {
    emitLoadVariable(gen, decl());
  }

  /**
   * Generate bytecode to load a field, local variable, or parameter.
   */
  protected void Access.emitLoadVariable(CodeGeneration gen, Variable v) {
    if (v instanceof VariableDeclarator) {
      VariableDeclarator var = (VariableDeclarator) v;
      if (var.hostType() == hostType()) {
        var.type().emitLoadLocal(gen, var.localNum());
      } else {
        emitLoadLocalInNestedClass(gen, v);
      }
    } else if (v.isField()) {
      createLoadQualifier(gen, v);
      if (v.isConstant() && (v.type().isPrimitive() || v.type().isString())) {
        if (!v.isStatic()) {
          fieldQualifierType().emitPop(gen);
        }
        v.constant().createBCode(gen);
      } else if (requiresAccessor()) {
        fieldQualifierType().fieldAccessor(v).emitInvokeMethod(gen, fieldQualifierType());
      } else {
        emitLoadField(gen, v, fieldQualifierType());
      }
    } else if (v instanceof ParameterDeclaration) {
      ParameterDeclaration decl = (ParameterDeclaration) v;
      if (decl.hostType() == hostType()) {
        decl.type().emitLoadLocal(gen, decl.localNum());
      } else {
        emitLoadLocalInNestedClass(gen, v);
      }
    }
  }

  syn boolean TypeDecl.needsAccessorFor(Variable v) {
    if (!(v instanceof FieldDeclarator)) {
      return false;
    }
    if (v.isConstant() && (v.type().isPrimitive() || v.type().isString())) {
      return false;
    }
    return v.isPrivate() && !hasField(v.name());
  }

  inh boolean Access.inExplicitConstructorInvocation();

  protected void Access.emitLoadLocalInNestedClass(CodeGeneration gen, Variable v) {
    if (inExplicitConstructorInvocation() && enclosingBodyDecl() instanceof ConstructorDecl) {
      ConstructorDecl c = (ConstructorDecl) enclosingBodyDecl();
      v.type().emitLoadLocal(gen, c.localIndexOfEnclosingVariable(v));
    } else {
      String classname = hostType().constantPoolName();
      String      name = "val$" + v.name();
      int index = gen.constantPool().addFieldref(classname, name, v.type());
      gen.emit(Bytecode.ALOAD_0);
      gen.emit(Bytecode.GETFIELD, v.type().variableSize() - 1).add2(index);
    }
  }

  /**
   * Generate bytecode to push on the stack the qualifier to access the variable v.
   */
  protected void Access.createLoadQualifier(CodeGeneration gen, Variable v) {
    if (v.isField()) {
      if (hasPrevExpr()) {
        // Load explicit qualifier.
        prevExpr().createBCode(gen);
        // Pop qualifier stack element for class variables.
        // This qualifier must be computed to ensure side effects are evaluated.
        if (!prevExpr().isTypeAccess() && v.isClassVariable()) {
          prevExpr().type().emitPop(gen);
        }
      } else if (v.isInstanceVariable()) {
        emitThis(gen, fieldQualifierType());
      }
    }
  }

  public void MethodAccess.createBCode(CodeGeneration gen) {
    if (transformed() != this) {
      // Ensure bytecode is generated for the transformed access.
      transformed().createBCode(gen);
      return;
    }
    createLoadQualifier(gen);

    if (program().options().hasOption("-debug")) {
      if (decl().type().isUnknown()) {
        System.err.println("Could not bind " + this);
        for (int i = 0; i < getNumArg(); ++i) {
          System.err.println("Argument " + getArg(i)
              + " is of type " + getArg(i).type().typeName());
          if (getArg(i).varDecl() != null) {
            System.err.println(getArg(i).varDecl() + " in "
                + getArg(i).varDecl().hostType().typeName());
          }
        }
        if (isQualified()) {
          System.err.println("Qualifier " + qualifier()
              + " is of type " + qualifier().type().typeName());
        }
        throw new Error("Could not bind " + this);
      }
      if (decl().getNumParameter() != getNumArg()) {
        System.err.println(this
            + " does not have the same number of arguments as " + decl());
      }
    }

    // Perform method invocation conversions.
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      getArg(i).type().emitCastTo(gen, decl().getParameter(i).type());
    }

    if (!decl().isStatic() && isQualified() && prevExpr().isSuperAccess()
        || isSuperAccessor) {
      decl().emitInvokeSpecialMethod(gen, methodQualifierType());
    } else {
      decl().emitInvokeMethod(gen, methodQualifierType());
    }
  }

  protected void MethodAccess.createLoadQualifier(CodeGeneration gen) {
    MethodDecl m = decl();
    if (hasPrevExpr()) {
      // Load explicit qualifier
      prevExpr().createBCode(gen);
      // Pop qualifier stack element for class variables.
      // This qualifier must be computed to ensure side effects are evaluated.
      if (m.isStatic() && !prevExpr().isTypeAccess()) {
        prevExpr().type().emitPop(gen);
      }
    } else if (!m.isStatic()) {
      // Load implicit this qualifier.
      emitThis(gen, methodQualifierType());
    }
  }

  public void ArrayAccess.createBCode(CodeGeneration gen) {
    prevExpr().createBCode(gen);
    getExpr().createBCode(gen);
    gen.emit(type().arrayLoad());
  }

  public void ThisAccess.createBCode(CodeGeneration gen) {
    emitThis(gen, decl());
  }

  public void SuperAccess.createBCode(CodeGeneration gen) {
    emitThis(gen, decl());
  }

  // Load this where hostType is the target this instance
  // supporting inner classes and in explicit contructor invocations.
  public void Access.emitThis(CodeGeneration gen, TypeDecl targetDecl) {
    if (targetDecl == hostType()) {
      gen.emit(Bytecode.ALOAD_0);
    } else {
      TypeDecl enclosing = hostType();
      if (inExplicitConstructorInvocation()) {
        gen.emit(Bytecode.ALOAD_1);
        enclosing = enclosing.enclosing();
      } else {
        gen.emit(Bytecode.ALOAD_0);
      }
      while (enclosing != targetDecl) {
        String classname = enclosing.constantPoolName();
        enclosing = enclosing.enclosingType();
        int index = gen.constantPool().addFieldref(classname, "this$0", enclosing);
        gen.emit(Bytecode.GETFIELD, 0).add2(index);
      }
    }
  }

  public void ConstructorAccess.createBCode(CodeGeneration gen) {
    if (transformed() != this) {
      // Ensure bytecode is generated for the transformed access.
      transformed().createBCode(gen);
      return;
    }

    ConstructorDecl decl = decl().bytecodeTarget();
    int index = 0;
    // Push this argument.
    gen.emitLoadReference(index++);
    // Push this$0 argument.
    if (decl.needsEnclosing()) {
      gen.emitLoadReference(index++);
    }
    if (decl.needsSuperEnclosing()) {
      gen.emitLoadReference(index++);
    }
    // Push formal arguments.
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      // Method invocation conversion:
      getArg(i).type().emitCastTo(gen, decl.getParameter(i).type());
    }
    // Push enclosing variable arguments.
    for (Variable var : decl.hostType().enclosingVariables()) {
      emitLoadVariable(gen, var);
    }
    if (decl.isPrivate() && decl.hostType() != hostType()) {
      gen.emit(Bytecode.ACONST_NULL);
      decl.createAccessor().emitInvokeConstructor(gen);
    } else {
      decl.emitInvokeConstructor(gen);
    }
  }

  public void SuperConstructorAccess.createBCode(CodeGeneration gen) {
    if (transformed() != this) {
      // Ensure bytecode is generated for the transformed access.
      transformed().createBCode(gen);
      return;
    }

    ConstructorDecl decl = decl().bytecodeTarget();

    // Push this argument.
    gen.emit(Bytecode.ALOAD_0);

    if (decl.needsEnclosing()) {
      if (hasPrevExpr() && !prevExpr().isTypeAccess()) {
        prevExpr().createBCode(gen);
        gen.emitDup();
        int index = gen.constantPool().addMethodref("java/lang/Object", "getClass",
            "()Ljava/lang/Class;");
        gen.emit(Bytecode.INVOKEVIRTUAL, 0).add2(index);
        gen.emitPop();
      } else {
        if (hostType().needsSuperEnclosing()) {
          if (hostType().needsEnclosing()) {
            gen.emit(Bytecode.ALOAD_2);
          } else {
            gen.emit(Bytecode.ALOAD_1);
          }
        } else {
          emitThis(gen, superConstructorQualifier(decl.hostType().enclosingType()));
        }
      }
    }

    // Push formal arguments.
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      // Method invocation conversion:
      getArg(i).type().emitCastTo(gen, decl.getParameter(i).type());
    }
    // Push enclosing variable arguments.
    for (Variable var : decl.hostType().enclosingVariables()) {
      emitLoadVariable(gen, var);
    }
    if (decl.isPrivate() && decl.hostType() != hostType()) {
      gen.emit(Bytecode.ACONST_NULL);
      decl.createAccessor().emitInvokeConstructor(gen);
    } else {
      decl.emitInvokeConstructor(gen);
    }
  }

  // 15.9.2
  private void ClassInstanceExpr.emitLocalEnclosing(CodeGeneration gen, TypeDecl localClass) {
    if (!localClass.inStaticContext()) {
      emitThis(gen, localClass.enclosingType());
    }
  }

  private void ClassInstanceExpr.emitInnerMemberEnclosing(CodeGeneration gen, TypeDecl innerClass) {
    if (hasPrevExpr()) {
      prevExpr().createBCode(gen);
      gen.emitDup();
      int index = gen.constantPool()
          .addMethodref("java/lang/Object", "getClass", "()Ljava/lang/Class;");
      gen.emit(Bytecode.INVOKEVIRTUAL, 0).add2(index);
      gen.emitPop();
    } else {
      TypeDecl enclosing = hostType();
      while (enclosing != null && !enclosing.hasType(innerClass.name())) {
        enclosing = enclosing.enclosingType();
      }
      if (enclosing == null) {
        throw new Error(errorPrefix() + "Could not find enclosing for " + this);
      } else {
        emitThis(gen, enclosing);
      }
    }
  }

  public void ClassInstanceExpr.createBCode(CodeGeneration gen) {
    if (transformed() != this) {
      // Ensure bytecode is generated for the transformed access.
      transformed().createBCode(gen);
      return;
    }

    type().emitNew(gen);
    type().emitDup(gen);

    // 15.9.2 first part
    if (type().isAnonymous()) {
      if (isAnonymousInNonStaticContext()) {
        if (type().inExplicitConstructorInvocation()) {
          gen.emit(Bytecode.ALOAD_1);
        } else {
          gen.emit(Bytecode.ALOAD_0);
        }
      }
      // 15.9.2 second part
      ClassDecl C = (ClassDecl) type();
      TypeDecl S = C.superclass();
      if (S.isLocalClass()) {
        if (!type().inStaticContext()) {
          emitLocalEnclosing(gen, S);
        }
      } else if (S.isInnerType()) {
        emitInnerMemberEnclosing(gen, S);
      }
    } else if (type().isLocalClass()) {
      if (!type().inStaticContext()) {
        emitLocalEnclosing(gen, type());
      }
    } else if (type().isInnerType()) {
      emitInnerMemberEnclosing(gen, type());
    }

    ConstructorDecl decl = decl().bytecodeTarget();

    // Push formal arguments.
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      // Method invocation conversion:
      getArg(i).type().emitCastTo(gen, decl.getParameter(i).type());
    }
    // Push enclosing variable arguments.
    for (Variable var : decl.hostType().enclosingVariables()) {
      emitLoadVariable(gen, var);
    }

    if (decl.isPrivate() && type() != hostType()) {
      gen.emit(Bytecode.ACONST_NULL);
      decl.createAccessor().emitInvokeConstructor(gen);
    } else {
      decl.emitInvokeConstructor(gen);
    }
  }

  /**
   * The constructor that is called in bytecode.
   */
  syn ConstructorDecl ConstructorDecl.bytecodeTarget() = this;

  public void ArrayCreationExpr.createBCode(CodeGeneration gen) {
    if (hasArrayInit()){
      getArrayInit().createBCode(gen);
    } else {
      getTypeAccess().createBCode(gen); // Push array sizes.
      if (type().componentType().isPrimitive()) {
        gen.emit(Bytecode.NEWARRAY).add(type().componentType().arrayPrimitiveTypeDescriptor());
      } else {
        if (numArrays() == 1) {
          String n = type().componentType().arrayTypeDescriptor();
          int index = gen.constantPool().addClass(n);
          gen.emit(Bytecode.ANEWARRAY).add2(index);
        } else {
          String n = type().arrayTypeDescriptor();
          int index = gen.constantPool().addClass(n);
          gen.emit(Bytecode.MULTIANEWARRAY, 1 - numArrays()).add2(index).add(numArrays());
        }
      }
    }
  }

  public void ArrayInit.createBCode(CodeGeneration gen) {
    IntegerLiteral.push(gen, getNumInit());
    if (type().componentType().isPrimitive()) {
      gen.emit(Bytecode.NEWARRAY).add(type().componentType().arrayPrimitiveTypeDescriptor());
    } else {
      String n = type().componentType().arrayTypeDescriptor();
      int index = gen.constantPool().addClass(n);
      gen.emit(Bytecode.ANEWARRAY).add2(index);
    }
    for (int i = 0; i < getNumInit(); i++) {
      gen.emitDup();
      IntegerLiteral.push(gen, i);
      getInit(i).createBCode(gen);
      if (getInit(i) instanceof ArrayInit) {
        gen.emit(Bytecode.AASTORE);
      } else {
        getInit(i).type().emitAssignConvTo(gen, expectedType()); // Assignment conversion.
        gen.emit(expectedType().arrayStore());
      }
    }
  }

  public void ArrayTypeAccess.createBCode(CodeGeneration gen) {
    getAccess().createBCode(gen);
  }
  public void ArrayTypeWithSizeAccess.createBCode(CodeGeneration gen) {
    getAccess().createBCode(gen);
    getExpr().createBCode(gen);
  }

  syn String TypeDecl.arrayTypeDescriptor() { throw new Error("Operation not supported"); }
  eq ArrayDecl.arrayTypeDescriptor() = typeDescriptor();
  eq ClassDecl.arrayTypeDescriptor() = constantPoolName();
  eq InterfaceDecl.arrayTypeDescriptor() = constantPoolName();

  syn int TypeDecl.arrayPrimitiveTypeDescriptor() { error(); return -1; }
  eq BooleanType.arrayPrimitiveTypeDescriptor() = 4; // T_BOOLEAN
  eq CharType.arrayPrimitiveTypeDescriptor() = 5; // T_CHAR
  eq FloatType.arrayPrimitiveTypeDescriptor() = 6; // T_FLOAT
  eq DoubleType.arrayPrimitiveTypeDescriptor() = 7; // T_DOUBLE
  eq ByteType.arrayPrimitiveTypeDescriptor() = 8; // T_BYTE
  eq ShortType.arrayPrimitiveTypeDescriptor() = 9; // T_SHORT
  eq IntType.arrayPrimitiveTypeDescriptor() = 10; // T_INT
  eq LongType.arrayPrimitiveTypeDescriptor() = 11; // T_LONG

  public void Unary.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    emitOperation(gen);
  }

  public void CastExpr.createBCode(CodeGeneration gen) {
    getExpr().createBCode(gen);
    getExpr().type().emitCastTo(gen, type());
  }

  // TODO(joqvist): consider using IINC or WIDE, IINC.

  public void Unary.emitPostfix(CodeGeneration gen, int constant) {
    Expr operand = getOperand();
    while (operand instanceof ParExpr) {
      operand = ((ParExpr) operand).getExpr();
    }
    Access access = ((Access) operand).lastAccess();
    access.createAssignLoadDest(gen);
    if (needsPush()) {
      access.createPushAssignmentResult(gen);
    }
    TypeDecl type = access.type().binaryNumericPromotion(typeInt());
    type.emitPushConstant(gen, constant);
    type.add(gen);
    type.emitCastTo(gen, access.type());
    access.emitStore(gen);
  }

  public void PostIncExpr.createBCode(CodeGeneration gen) {
    emitPostfix(gen, 1);
  }

  public void PostDecExpr.createBCode(CodeGeneration gen) {
    emitPostfix(gen, -1);
  }

  public void Unary.emitPrefix(CodeGeneration gen, int constant) {
    Expr operand = getOperand();
    while (operand instanceof ParExpr) {
      operand = ((ParExpr) operand).getExpr();
    }
    Access access = ((Access) operand).lastAccess();
    access.createAssignLoadDest(gen);
    TypeDecl type = access.type().binaryNumericPromotion(typeInt());
    type.emitPushConstant(gen, constant);
    type.add(gen);
    type.emitCastTo(gen, access.type());
    if (needsPush()) {
      access.createPushAssignmentResult(gen);
    }
    access.emitStore(gen);
  }

  public void PreIncExpr.createBCode(CodeGeneration gen) {
    emitPrefix(gen, 1);
  }

  public void PreDecExpr.createBCode(CodeGeneration gen) {
    emitPrefix(gen, -1);
  }

  public void Binary.createBCode(CodeGeneration gen) {
    getLeftOperand().createBCode(gen);
    getLeftOperand().type().emitCastTo(gen, type()); // Binary numeric promotion.
    getRightOperand().createBCode(gen);
    getRightOperand().type().emitCastTo(gen, type()); // Binary numeric promotion.
    emitOperation(gen);
  }

  public void Binary.emitShiftExpr(CodeGeneration gen) {
    getLeftOperand().createBCode(gen);
    getLeftOperand().type().emitCastTo(gen, type()); // Binary numeric promotion.
    getRightOperand().createBCode(gen);
    getRightOperand().type().emitCastTo(gen, typeInt());
    emitOperation(gen);
  }

  public void LShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  public void RShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  public void URShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  public void AddExpr.createBCode(CodeGeneration gen) {
    if (!type().isString()) {
      super.createBCode(gen);
    } else if (isConstant()) {
      StringLiteral.push(gen, constant().stringValue());
    } else {
      // TODO(joqvist): use StringBuilder instead. No need for synchronization.
      TypeDecl stringBuffer = lookupType("java.lang", "StringBuffer");
      String classname = stringBuffer.constantPoolName();
      String desc;
      int index;
      TypeDecl argumentType;
      if (firstStringAddPart()) {
        stringBuffer.emitNew(gen);
        gen.emitDup();
        desc = "()V";
        index = gen.constantPool().addMethodref(classname, "<init>", desc);
        gen.emit(Bytecode.INVOKESPECIAL, -1).add2(index);
        getLeftOperand().createBCode(gen);
        argumentType = getLeftOperand().type().stringPromotion();
        desc = "(" + argumentType.typeDescriptor() + ")" + stringBuffer.typeDescriptor();
        index = gen.constantPool().addMethodref(classname, "append", desc);
        gen.emit(Bytecode.INVOKEVIRTUAL, -argumentType.variableSize()).add2(index);
      } else {
        getLeftOperand().createBCode(gen);
      }
      getRightOperand().createBCode(gen);
      argumentType = getRightOperand().type().stringPromotion();
      desc = "(" + argumentType.typeDescriptor() + ")" + stringBuffer.typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "append", desc);
      gen.emit(Bytecode.INVOKEVIRTUAL, -argumentType.variableSize()).add2(index);
      if (lastStringAddPart()) {
        desc = "()" + type().typeDescriptor();
        index = gen.constantPool().addMethodref(classname, "toString", desc);
        gen.emit(Bytecode.INVOKEVIRTUAL, 0).add2(index);
      }
    }
  }

  syn boolean Expr.canBeTrue() = !isFalse();
  eq CastExpr.canBeTrue() = getExpr().canBeTrue();
  eq ParExpr.canBeTrue() = getExpr().canBeTrue();
  eq Dot.canBeTrue() = lastAccess().canBeTrue();
  eq OrLogicalExpr.canBeTrue() = getLeftOperand().canBeTrue() || getRightOperand().canBeTrue();
  eq AndLogicalExpr.canBeTrue() = getLeftOperand().canBeTrue() && getRightOperand().canBeTrue();
  eq ConditionalExpr.canBeTrue() =
      type().isBoolean()
      && (getCondition().canBeTrue() && getTrueExpr().canBeTrue()
          || getCondition().canBeFalse() && getFalseExpr().canBeTrue());
  eq LogNotExpr.canBeTrue() = getOperand().canBeFalse();

  syn boolean Expr.canBeFalse() = !isTrue();
  eq CastExpr.canBeFalse() = getExpr().canBeFalse();
  eq ParExpr.canBeFalse() = getExpr().canBeFalse();
  eq Dot.canBeFalse() = lastAccess().canBeFalse();
  eq OrLogicalExpr.canBeFalse() = getLeftOperand().canBeFalse() && getRightOperand().canBeFalse();
  eq AndLogicalExpr.canBeFalse() = getLeftOperand().canBeFalse() || getRightOperand().canBeFalse();
  eq ConditionalExpr.canBeFalse() =
      type().isBoolean()
      && (getCondition().canBeTrue() && getTrueExpr().canBeFalse()
          || getCondition().canBeFalse() && getFalseExpr().canBeFalse());
  eq LogNotExpr.canBeFalse() = getOperand().canBeTrue();

  public void RelationalExpr.createBCode(CodeGeneration gen) { emitBooleanCondition(gen); }
  public void LogNotExpr.createBCode(CodeGeneration gen) { emitBooleanCondition(gen); }
  public void LogicalExpr.createBCode(CodeGeneration gen) { emitBooleanCondition(gen); }

  protected void Expr.emitBooleanCondition(CodeGeneration gen) {
    int end_label = -1;
    int false_label = -1;
    if (!isConstant()) {
      false_label = gen.constantPool().newLabel();
      branchFalse(gen, false_label);
    }
    if (canBeTrue()) {
      BooleanLiteral.push(gen, true);
      if (canBeFalse()) {
        end_label = gen.constantPool().newLabel();
        gen.emitGoto(end_label);
        gen.changeStackDepth(-1); // Discard value from stack depth computation.
      }
    }
    if (false_label != -1) {
      gen.addLabel(false_label);
    }
    if (canBeFalse()) {
      BooleanLiteral.push(gen, false);
    }
    if (end_label != -1) {
      gen.addLabel(end_label);
    }
  }

  public void ConditionalExpr.createBCode(CodeGeneration gen) {
    int end_label = -1;
    int false_label = -1;
    if (!getCondition().isConstant()) {
      false_label = gen.constantPool().newLabel();
      getCondition().branchFalse(gen, false_label);
    }
    if (getCondition().canBeTrue()) {
      getTrueExpr().createBCode(gen);
      getTrueExpr().type().emitCastTo(gen, type());
      if (getCondition().canBeFalse()) {
        end_label = gen.constantPool().newLabel();
        gen.emitGoto(end_label);
        gen.changeStackDepth(-type().variableSize());
      }
    }
    if (false_label != -1) {
      gen.addLabel(false_label);
    }
    if (getCondition().canBeFalse()) {
      getFalseExpr().createBCode(gen);
      getFalseExpr().type().emitCastTo(gen, type());
    }
    if (end_label != -1) {
      gen.addLabel(end_label);
    }
  }

  /**
   * Generate a conditional branch statement. The branch should be taken if the
   * expression evaluates to true. May in some cases not result in an actual
   * branch statement if the branch would never be taken.
   * @param gen code generator
   * @param target target label to jump to if the condition was true
   */
  public void Expr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    if (isConstant()) {
      if (isTrue()) {
        gen.emitGoto(target);
      }
    } else {
      createBCode(gen);
      gen.emitCompare(Bytecode.IFNE, target);
    }
  }

  public void ParExpr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    getExpr().branchTrue(gen, target);
  }

  public void Dot.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    lastAccess().branchTrue(gen, target);
  }

  public void LogNotExpr.branchTrue(CodeGeneration gen, int target)  {
    // Branch when true.
    getOperand().branchFalse(gen, target);
  }

  public void AndLogicalExpr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    Expr left = getLeftOperand();
    Expr right = getRightOperand();
    int skip_lbl = -1;
    if (!left.isConstant()) {
      skip_lbl = gen.constantPool().newLabel();
      left.branchFalse(gen, skip_lbl);
    }
    if (left.canBeTrue()) {
      right.branchTrue(gen, target);
    }
    if (skip_lbl != -1) {
      gen.addLabel(skip_lbl);
    }
  }

  public void OrLogicalExpr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    Expr left = getLeftOperand();
    Expr right = getRightOperand();
    if (!left.isFalse()) {
      left.branchTrue(gen, target);
    }
    if (left.canBeFalse()) {
      right.branchTrue(gen, target);
    }
  }

  public void ConditionalExpr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    int else_label = -1;
    int end_label = -1;
    if (!getCondition().isConstant()) {
      else_label = gen.constantPool().newLabel();
      getCondition().branchFalse(gen, else_label);
    }
    if (getCondition().canBeTrue()) {
      getTrueExpr().branchTrue(gen, target);
      if (getCondition().canBeFalse() && getTrueExpr().canBeFalse()) {
        end_label = gen.constantPool().newLabel();
        gen.emitGoto(end_label);
        //gen.GOTO(end_label);
      }
    }
    if (else_label != -1) {
      gen.addLabel(else_label);
    }
    if (getCondition().canBeFalse()) {
      getFalseExpr().branchTrue(gen, target);
    }
    if (end_label != -1) {
      gen.addLabel(end_label);
    }
  }

  public void RelationalExpr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    if (isConstant()) {
      if (isTrue()) {
        gen.emitGoto(target);
      }
    } else {
      TypeDecl type = getLeftOperand().type();
      if (type.isNumericType()) {
        type = binaryNumericPromotedType();
        getLeftOperand().createBCode(gen);
        getLeftOperand().type().emitCastTo(gen, type); // Binary numeric promotion.
        getRightOperand().createBCode(gen);
        getRightOperand().type().emitCastTo(gen, type); // Binary numeric promotion.
      } else {
        getLeftOperand().createBCode(gen);
        getRightOperand().createBCode(gen);
      }
      compareBranch(gen, target, type);
    }
  }

  /**
   * Generate a conditional branch statement. The branch should be taken if the
   * expression evaluates to false. May in some cases not result in an actual
   * branch statement if the branch would never be taken.
   * @param gen code generator
   * @param target target label to jump to if the condition was false
   */
  public void Expr.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    if (isConstant()) {
      if (isFalse()) {
        gen.emitGoto(target);
      }
    } else {
      createBCode(gen);
      gen.emitCompare(Bytecode.IFEQ, target);
    }
  }

  public void ParExpr.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    getExpr().branchFalse(gen, target);
  }

  public void Dot.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    lastAccess().branchFalse(gen, target);
  }

  public void LogNotExpr.branchFalse(CodeGeneration gen, int target)  {
    // Branch when false.
    getOperand().branchTrue(gen, target);
  }

  public void AndLogicalExpr.branchFalse(CodeGeneration gen, int target) {
    // branch when false
    Expr left = getLeftOperand();
    Expr right = getRightOperand();
    if (!left.isTrue()) {
      left.branchFalse(gen, target);
    }
    if (left.canBeTrue()) {
      right.branchFalse(gen, target);
    }
  }

  public void OrLogicalExpr.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    Expr left = getLeftOperand();
    Expr right = getRightOperand();
    int skip_lbl = -1;
    if (!left.isConstant()) {
      skip_lbl = gen.constantPool().newLabel();
      left.branchTrue(gen, skip_lbl);
    }
    if (left.canBeFalse()) {
      right.branchFalse(gen, target);
    }
    if (skip_lbl != -1) {
      gen.addLabel(skip_lbl);
    }
  }

  public void ConditionalExpr.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    int else_label = -1;
    int end_label = -1;
    if (!getCondition().isConstant()) {
      else_label = gen.constantPool().newLabel();
      getCondition().branchFalse(gen, else_label);
    }
    if (getCondition().canBeTrue()) {
      getTrueExpr().branchFalse(gen, target);
      if (getCondition().canBeFalse() && getTrueExpr().canBeTrue()) {
        end_label = gen.constantPool().newLabel();
        gen.emitGoto(end_label);
      }
    }
    if (else_label != -1) {
      gen.addLabel(else_label);
    }
    if (getCondition().canBeFalse()) {
      getFalseExpr().branchFalse(gen, target);
    }
    if (end_label != -1) {
      gen.addLabel(end_label);
    }
  }

  public void RelationalExpr.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    if (isConstant()) {
      if (isFalse()) {
        gen.emitGoto(target);
      }
    } else {
      TypeDecl type = getLeftOperand().type();
      if (type.isNumericType()) {
        type = binaryNumericPromotedType();
        getLeftOperand().createBCode(gen);
        getLeftOperand().type().emitCastTo(gen, type); // Binary numeric promotion.
        getRightOperand().createBCode(gen);
        getRightOperand().type().emitCastTo(gen, type); // Binary numeric promotion.
      } else {
        getLeftOperand().createBCode(gen);
        getRightOperand().createBCode(gen);
      }
      compareNotBranch(gen, target, type);
    }
  }

  public void RelationalExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    throw new Error("compareBranch not implemented for " + getClass().getName());
  }

  public void LTExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchLT(gen, label);
  }

  public void LEExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchLE(gen, label);
  }

  public void GEExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchGE(gen, label);
  }

  public void GTExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchGT(gen, label);
  }

  public void EQExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchEQ(gen, label);
  }

  public void NEExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchNE(gen, label);
  }

  public void RelationalExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    throw new Error("compareNotBranch not implemented for " + getClass().getName());
  }

  public void LTExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchGEInv(gen, label);
  }

  public void LEExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchGTInv(gen, label);
  }

  public void GEExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchLTInv(gen, label);
  }

  public void GTExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchLEInv(gen, label);
  }

  public void EQExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchNE(gen, label);
  }

  public void NEExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchEQ(gen, label);
  }

  public void InstanceOfExpr.createBCode(CodeGeneration gen) {
    getExpr().createBCode(gen);
    gen.emitInstanceof(getTypeAccess().type());
  }

  public void Stmt.createBCode(CodeGeneration gen) {
    gen.addLineNumberEntryAtCurrentPC(this);
  }

  public void Block.createBCode(CodeGeneration gen) {
    for (Stmt stmt : getStmtList()) {
      try {
        stmt.createBCode(gen);
      } catch (Exception e) {
        e.printStackTrace();
        System.err.println(dumpTree());
        throw new Error("Error generating code for " + errorPrefix() + " " + stmt);
      }
    }
    gen.addVariableScopeLabel(variableScopeEndLabel(gen));
  }

  public void EmptyStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
  }

  syn lazy int LabeledStmt.label() = hostType().constantPool().newLabel();

  syn lazy int LabeledStmt.end_label() = hostType().constantPool().newLabel();

  public void LabeledStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    gen.addLabel(label());
    getStmt().createBCode(gen);
    gen.addLabel(end_label());
  }

  public void ExprStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    getExpr().createBCode(gen);
    if (needsPop()) {
      getExpr().type().emitPop(gen);
    }
  }

  syn lazy DefaultCase SwitchStmt.defaultCase() {
    for (int i= 0; i < getBlock().getNumStmt(); i++) {
      if (getBlock().getStmt(i) instanceof DefaultCase) {
        return (DefaultCase) getBlock().getStmt(i);
      }
    }
    return null;
  }

  syn lazy int SwitchStmt.end_label() = hostType().constantPool().newLabel();

  public void SwitchStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    int switch_label = gen.constantPool().newLabel();

    getExpr().createBCode(gen);

    TreeMap<Integer, ConstCase> map = new TreeMap<Integer, ConstCase>();
    for (int i = 0; i < getBlock().getNumStmt(); i++) {
      if (getBlock().getStmt(i) instanceof ConstCase) {
        ConstCase ca = (ConstCase) getBlock().getStmt(i);
        map.put(ca.getValue().constant().intValue(), ca);
      }
    }

    int low = map.isEmpty() ? 0 : map.firstKey();
    int high = map.isEmpty() ? 0 : map.lastKey();

    long tableSwitchSize = 4L * (3L + (high - low + 1L));
    int lookupSwitchSize = 4 * (2 + 2 * map.size());
    int pad;
    int switchSize;
    int switchPos;
    boolean tableSwitch = tableSwitchSize < lookupSwitchSize;

    gen.addLabel(switch_label);

    // Select the switch type which produces the smallest switch instruction.
    if (tableSwitch) {
      // Use TABLESWITCH.
      gen.emit(Bytecode.TABLESWITCH);
      switchSize = (int) tableSwitchSize;
    } else {
      // Use LOOKUPSWITCH.
      gen.emit(Bytecode.LOOKUPSWITCH);
      switchSize = lookupSwitchSize;
    }

    pad = emitPad(gen);
    switchPos = gen.pos();

    // Leave room for the address table.
    gen.skip(switchSize);

    getBlock().createBCode(gen);

    // Write jump address table.
    int endpos = gen.pos();
    gen.setPos(switchPos);
    if (tableSwitch) {
      int defaultOffset = defaultOffset(gen, switch_label);
      int numCase = high - low + 1;
      if (defaultOffset == 0) {
        defaultOffset = 1 + pad + switchSize;
      }
      gen.add4(defaultOffset);
      gen.add4(low);
      gen.add4(high);
      for (int i = low; i <= high; i++) {
        ConstCase ca = map.get(i);
        if (ca != null) {
          int offset = gen.addressOf(ca.label()) - gen.addressOf(switch_label);
          gen.add4(offset);
        } else {
          gen.add4(defaultOffset);
        }
      }
    } else {
      int defaultOffset = defaultOffset(gen, switch_label);
      if (defaultOffset == 0) {
        defaultOffset = 1 + pad + switchSize;
      }
      gen.add4(defaultOffset);
      gen.add4(map.size());
      for (ConstCase ca : map.values()) {
        gen.add4(ca.getValue().constant().intValue());
        int offset = gen.addressOf(ca.label())
          - gen.addressOf(switch_label);
        gen.add4(offset);
      }
    }
    gen.setPos(endpos);

    gen.addLabel(end_label());
  }

  syn int SwitchStmt.numCase() {
    int result = 0;
    for (int i = 0; i < getBlock().getNumStmt(); i++) {
      if (getBlock().getStmt(i) instanceof Case) {
        result++;
      }
    }
    return result;
  }

  private int SwitchStmt.emitPad(CodeGeneration gen) {
    int pad = (4 - (gen.pos() % 4)) % 4;
    for (int i = 0; i < pad; i++) {
      gen.emit(Bytecode.NOP);
    }
    if (gen.pos() % 4 != 0) {
      throw new Error("Switch not at 4-byte boundary:" + gen.pos());
    }
    return pad;
  }

  /**
   * Calculate offset to the default label.
   * @return bytecode offset to default label (or zero if there is no
   * default label)
   */
  private int SwitchStmt.defaultOffset(CodeGeneration gen, int switch_label) {
    DefaultCase defaultCase = defaultCase();
    if (defaultCase != null) {
      int offset = gen.addressOf(defaultCase.label()) - gen.addressOf(switch_label);
      return offset;
    }
    return 0;
  }

  syn lazy int Case.label() = hostType().constantPool().newLabel();

  public void Case.createBCode(CodeGeneration gen) {
    gen.addLabel(label());
  }

  syn lazy int IfStmt.else_branch_label() = hostType().constantPool().newLabel();

  syn lazy int IfStmt.then_branch_label() = hostType().constantPool().newLabel();

  syn lazy int IfStmt.end_label() = hostType().constantPool().newLabel();

  public void IfStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    int elseBranch = else_branch_label();
    int thenBranch = then_branch_label();
    int endBranch = end_label();
    if (!getCondition().isConstant()) {
      getCondition().branchFalse(gen, elseBranch);
    }
    gen.addLabel(thenBranch);
    if (getCondition().canBeTrue()) {
      getThen().createBCode(gen);
      if (getThen().canCompleteNormally() && hasElse() && getCondition().canBeFalse()) {
        gen.emitGoto(endBranch);
      }
    }
    gen.addLabel(elseBranch);
    if (hasElse() && getCondition().canBeFalse()) {
      getElse().createBCode(gen);
    }
    gen.addLabel(endBranch);
  }

  syn lazy int WhileStmt.cond_label() = hostType().constantPool().newLabel();
  syn lazy int WhileStmt.end_label() = hostType().constantPool().newLabel();
  syn lazy int WhileStmt.stmt_label() = hostType().constantPool().newLabel();

  public void WhileStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    gen.addLabel(cond_label());
    if (!getCondition().isConstant()) {
      getCondition().branchFalse(gen, end_label());
    }
    gen.addLabel(stmt_label());
    if (getCondition().canBeTrue()) {
      getStmt().createBCode(gen);
      if (getStmt().canCompleteNormally()) {
        gen.emitGoto(cond_label());
      }
    }
    gen.addLabel(end_label());
  }

  syn lazy int DoStmt.begin_label() = hostType().constantPool().newLabel();
  syn lazy int DoStmt.cond_label() = hostType().constantPool().newLabel();
  syn lazy int DoStmt.end_label() = hostType().constantPool().newLabel();

  public void DoStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    gen.addLabel(begin_label());
    getStmt().createBCode(gen);
    gen.addLabel(cond_label());
    getCondition().branchTrue(gen, begin_label());
    gen.addLabel(end_label());
  }

  syn lazy int ForStmt.cond_label() = hostType().constantPool().newLabel();
  syn lazy int ForStmt.begin_label() = hostType().constantPool().newLabel();
  syn lazy int ForStmt.update_label() = hostType().constantPool().newLabel();
  syn lazy int ForStmt.end_label() = hostType().constantPool().newLabel();

  public void ForStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    for (Stmt stmt : getInitStmtList()) {
      stmt.createBCode(gen);
    }
    gen.addLabel(cond_label());
    if (hasCondition() && !getCondition().isConstant()) {
      getCondition().branchFalse(gen, end_label());
    }
    if (!hasCondition() || getCondition().canBeTrue()) {
      gen.addLabel(begin_label());
      getStmt().createBCode(gen);
      gen.addLabel(update_label());
      for (Stmt stmt : getUpdateStmtList()) {
        stmt.createBCode(gen);
      }
      gen.emitGoto(cond_label());
    }
    gen.addLabel(end_label());
    gen.addVariableScopeLabel(variableScopeEndLabel(gen));
  }

  syn int Stmt.break_label() {
    throw new UnsupportedOperationException("Can not break at this statement of type "
        + getClass().getName());
  }
  eq ForStmt.break_label() = end_label();
  eq WhileStmt.break_label() = end_label();
  eq DoStmt.break_label() = end_label();
  eq LabeledStmt.break_label() = end_label();
  eq SwitchStmt.break_label() = end_label();
  eq TryStmt.break_label() =  label_end();
  syn lazy int SynchronizedStmt.start_label() = hostType().constantPool().newLabel();

  public void BreakStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    if (hasFinally()) {
      int nextRange = gen.constantPool().newLabel();
      getFinally().createBCode(gen);
      gen.emitGoto(targetStmt().break_label());
      gen.addLabel(nextRange);
      gen.monitorRangesStart(this, nextRange);
    } else {
      gen.emitGoto(targetStmt().break_label());
    }
  }

  syn int Stmt.continue_label() {
    throw new UnsupportedOperationException("Can not continue at this statement");
  }
  eq ForStmt.continue_label() = update_label();
  eq WhileStmt.continue_label() = cond_label();
  eq DoStmt.continue_label() = cond_label();
  eq LabeledStmt.continue_label() = getStmt().continue_label();

  // TODO(joqvist): test continue in try-statement!
  eq TryStmt.continue_label() = label_end();

  public void ContinueStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    if (hasFinally()) {
      int nextRange = gen.constantPool().newLabel();
      getFinally().createBCode(gen);
      gen.emitGoto(targetStmt().continue_label());
      gen.addLabel(nextRange);
      gen.monitorRangesStart(this, nextRange);
    } else {
      gen.emitGoto(targetStmt().continue_label());
    }
  }

  public void ReturnStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    if (hasResult()) {
      TypeDecl type = null;
      BodyDecl b = enclosingBodyDecl();
      if (b instanceof MethodDecl) {
        type = ((MethodDecl) b).type();
      } else {
        throw new Error("Can not create code that returns value within non method");
      }
      getResult().createBCode(gen);
      getResult().type().emitCastTo(gen, type);
      if (hasFinally()) {
        int nextRange = gen.constantPool().newLabel();
        type.emitStoreLocal(gen, resultSaveLocalNum());
        getFinally().createBCode(gen);
        type.emitLoadLocal(gen, resultSaveLocalNum());
        type.emitReturn(gen);
        gen.addLabel(nextRange);
        gen.monitorRangesStart(this, nextRange);
      } else {
        type.emitReturn(gen);
      }
    } else {
      if (hasFinally()) {
        int nextRange = gen.constantPool().newLabel();
        getFinally().createBCode(gen);
        gen.emitReturn();
        gen.addLabel(nextRange);
        gen.monitorRangesStart(this, nextRange);
      } else {
        gen.emitReturn();
      }
    }
  }

  public void ThrowStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    getExpr().createBCode(gen);
    gen.emitThrow();
  }

  syn lazy int TryStmt.fallthrough_label() =
      hasNonEmptyFinally() ? hostType().constantPool().newLabel() : label_end();

  public void TryStmt.createBCode(CodeGeneration gen) {
    int block_top_lbl = gen.constantPool().newLabel();
    int block_end_lbl = gen.constantPool().newLabel();
    int fallthrough_lbl = fallthrough_label();
    int handler_lbl = gen.constantPool().newLabel();
    boolean needsHandler = false;

    super.createBCode(gen);
    gen.addLabel(block_top_lbl);
    getBlock().createBCode(gen);
    gen.addLabel(block_end_lbl);

    if (getBlock().canCompleteNormally()) {
      gen.emitGoto(fallthrough_lbl);
    }

    for (int i = 0; i < getNumCatchClause(); i++) {
      CatchClause cc = getCatchClause(i);
      cc.createBCode(gen);
      cc.exceptionTableEntries(gen, block_top_lbl, block_end_lbl);
      if (cc.getBlock().canCompleteNormally()) {
        gen.emitGoto(fallthrough_lbl);
      }
      if (hasNonEmptyFinally()) {
        int cc_end_lbl = gen.constantPool().newLabel();
        gen.addLabel(cc_end_lbl);
        needsHandler = true;
        gen.addException(cc.label(), cc_end_lbl, handler_lbl,
            CodeGeneration.ExceptionEntry.CATCH_ALL);
      }
    }

    if (hasNonEmptyFinally()) {

      emitExceptionHandler(gen, block_top_lbl, block_end_lbl, handler_lbl, needsHandler);

      // Fallthrough finally.
      gen.addLabel(fallthrough_lbl);
      getFinally().createBCode(gen);
    }

    gen.addLabel(label_end());
  }

  /**
   * Outer finally host with a finally block that can complete normally.
   */
  syn FinallyHost TryStmt.outerFinallyHost() {
    // Find outer finally block.
    FinallyHost outer = this;
    Iterator<FinallyHost> iter = finallyIterator();
    while (iter.hasNext()) {
      outer = iter.next();
    }
    return outer;
  }

  /**
   * Generate catch-all (finally).
   */
  public void TryStmt.emitExceptionHandler(CodeGeneration gen, int start_lbl, int end_lbl,
      int handler_lbl, boolean needsHandler) {
    int top_pc = gen.addressOf(start_lbl);
    int end_pc = gen.addressOf(end_lbl);
    if (needsHandler || top_pc != end_pc) {
      // Catch-all exception handler (finally).
      gen.addLabel(handler_lbl);
      gen.changeStackDepth(1);
      int num = getBlock().localNum();
      gen.emitStoreReference(num);
      getExceptionHandler().createBCode(gen);
      gen.emitLoadReference(num);
      gen.emit(Bytecode.ATHROW);
      gen.addException(start_lbl, end_lbl, handler_lbl, CodeGeneration.ExceptionEntry.CATCH_ALL);
    }
  }

  public void SynchronizedStmt.emitMonitorEnter(CodeGeneration gen) {
    gen.emitDup();
    int num = localNum();
    gen.emitStoreReference(num);
    gen.emit(Bytecode.MONITORENTER);
  }

  syn lazy int CatchClause.label() = hostType().constantPool().newLabel();
  public void BasicCatch.createBCode(CodeGeneration gen) {
    gen.addLabel(label());
    // Add 1 to stack depth.
    gen.changeStackDepth(1);
    getParameter().type().emitStoreLocal(gen, getParameter().localNum());
    getBlock().createBCode(gen);
  }

  protected int SynchronizedStmt.monitorId = -1;

  public void SynchronizedStmt.createBCode(CodeGeneration gen) {
    int lbl_start = gen.constantPool().newLabel();
    super.createBCode(gen);
    getExpr().createBCode(gen);

    monitorId = gen.monitorEnter(this);
    gen.addLabel(lbl_start);
    gen.monitorRangeStart(monitorId, lbl_start);

    getBlock().createBCode(gen);

    if (getBlock().canCompleteNormally()) {
      getMonitorExit().createBCode(gen);
      gen.emitGoto(label_end());
    }

    gen.monitorExit();

    gen.addLabel(label_end());
  }

  /**
   * Checks if the branch statement leaves the monitor.
   * @return <code>true</code> if the branch leaves the monitor
   */
  inh boolean Stmt.leavesMonitor(Stmt branch, SynchronizedStmt monitor);

  eq BodyDecl.getChild().leavesMonitor(Stmt branch, SynchronizedStmt monitor) {
    throw new Error("Enclosing monitor not found!");
  }

  eq SynchronizedStmt.getChild().leavesMonitor(Stmt branch, SynchronizedStmt monitor) {
    if (monitor == this) {
      return true;
    } else {
      return leavesMonitor(branch, monitor);
    }
  }

  eq BranchTargetStmt.getChild().leavesMonitor(Stmt branch, SynchronizedStmt monitor) {
    if (potentialTargetOf(branch)) {
      return false;
    } else {
      return leavesMonitor(branch, monitor);
    }
  }

  /**
   * Assert statement bytecode is generated through the transformed
   * version of the assert statement.
   */
  public void AssertStmt.createBCode(CodeGeneration gen) {
    transformed().createBCode(gen);
  }

  public void LocalClassDeclStmt.createBCode(CodeGeneration gen) {
  }

  public void ClassAccess.createBCode(CodeGeneration gen) {
    if (prevExpr().type().isPrimitiveType() || prevExpr().type().isVoid()) {
      TypeDecl typeDecl = lookupType("java.lang", prevExpr().type().primitiveClassName());
      SimpleSet<Variable> fields = typeDecl.memberFields("TYPE");
      Variable f = fields.iterator().next();
      emitLoadField(gen, f, typeDecl);
    } else {
      int index = gen.constantPool().addClass(prevExpr().type().jvmName());
      if (index < 256) {
        gen.emit(Bytecode.LDC).add(index);
      } else {
        gen.emit(Bytecode.LDC_W).add2(index);
      }
    }
  }

  /**
   * Generate bytecode for the monitor exit call.
   */
  public void MonitorExit.createBCode(CodeGeneration gen) {
    gen.monitorRangeEnd(monitor.monitorId, hostType().constantPool().newLabel());
  }

  /**
   * Generate exception handler for monitor closing.
   * @param gen
   */
  public void MonitorExit.emitMonitorExitHandler(CodeGeneration gen) {
    int handler_lbl = handler_label();
    int end_lbl = handler_end_label();

    gen.changeStackDepth(1);
    int num = localNum() + 1;

    // Handler start.
    gen.addLabel(handler_lbl);

    gen.emitStoreReference(num);

    gen.emitLoadReference(monitor.localNum());
    gen.emit(Bytecode.MONITOREXIT);

    // Handler end.
    gen.addLabel(end_lbl);

    gen.emitLoadReference(num);
    gen.emit(Bytecode.ATHROW);

    // Add exception handler for the monitor closing.
    // See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4414101.
    gen.addException(handler_lbl, end_lbl, handler_lbl, CodeGeneration.ExceptionEntry.CATCH_ALL);
  }
}
