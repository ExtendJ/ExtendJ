/* Copyright (c) 2005-2008, Torbjorn Ekman
 *               2013-2017, Jesper Ã–qvist <jesper.oqvist@cs.lth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import java.util.*;
import java.io.*;

aspect CreateBCode {

  inh TypeDecl CatchClause.hostType();

  public abstract void CatchClause.exceptionTableEntries(CodeGeneration gen,
      int begin_lbl, int end_lbl);

  public void BasicCatch.exceptionTableEntries(CodeGeneration gen, int begin_lbl, int end_lbl) {
    gen.addExceptionHandler(begin_lbl, end_lbl, label(), getParameter().type());
  }

  syn lazy boolean TypeDecl.hasClinit() {
    for (BodyDecl b : getBodyDeclList()) {
      if (b instanceof FieldDecl) {
        FieldDecl field = (FieldDecl) b;
        if (field.isStatic() && field.hasInit()) {
          return true;
        }
      } else if (b instanceof StaticInitializer) {
        return true;
      }
    }
    return hasAssertStatement(); // Check if we need to initialize the $assertionsDisabled field.
  }

  /**
   * @return {@code true} if any of the contained field declarations has an
   * initializer
   */
  syn lazy boolean FieldDecl.hasInit() {
    for (FieldDeclarator decl : getDeclaratorList()) {
      if (decl.hasInit()) {
        return true;
      }
    }
    return false;
  }

  syn lazy CodeGeneration TypeDecl.bytecodes(ConstantPool constantPool) {
    CodeGeneration gen = new CodeGeneration(constantPool, this);
    try {
      generateBytecodes(gen);
    } catch (CodeGeneration.JumpOffsetError e) {
      // Retry with wide gotos.
      gen = new CodeGeneration(constantPool, this, true);
      generateBytecodes(gen);
    } catch (Error e) {
      System.err.println("Error while processing " + sourceLocation());
      throw e;
    }
    return gen;
  }

  /**
   * Generates static initializer bytecode.
   */
  protected void TypeDecl.generateBytecodes(CodeGeneration gen) {
    for (BodyDecl b : getBodyDeclList()) {
      if (b instanceof FieldDecl) {
        FieldDecl field = (FieldDecl) b;
        if (field.isStatic()) {
          for (FieldDeclarator decl : field.getDeclaratorList()) {
            if (decl.hasInit()) {
              decl.emitInitializerBCode(gen);
              decl.emitStoreField(gen, this);
            }
          }
        }
      } else if (b instanceof StaticInitializer) {
        b.createBCode(gen);
      }
    }
    if (hasAssertStatement()) {
      assertionsDisabled().emitInitializerBCode(gen);
      assertionsDisabled().emitStoreField(gen, this);
    }
    gen.RETURN();
  }

  syn lazy CodeGeneration MethodDecl.bytecodes(ConstantPool constantPool) {
    CodeGeneration gen = new CodeGeneration(constantPool, this);
    try {
      generateBytecodes(gen);
    } catch (CodeGeneration.JumpOffsetError e) {
      // Retry with wide gotos.
      gen = new CodeGeneration(constantPool, this, true);
      generateBytecodes(gen);
    } catch (Error e) {
      System.err.println("Error while processing " + sourceLocation());
      throw e;
    }
    return gen;
  }

  private void MethodDecl.generateBytecodes(CodeGeneration gen) {
    int label = gen.variableScopeLabel();
    int paramLength = 0;
    if (!isStatic()) {
      paramLength += 1;
      gen.addLocalVariableEntryAtCurrentPC("this", hostType(), 0, label);
      gen.addParameter(0, hostType());
    }
    for (ParameterDeclaration p : getParameterList()) {
      paramLength += p.type().variableSize();
      if (paramLength > 255) {
        throw new Error("parameter list too large");
      }
      gen.addLocalVariableEntryAtCurrentPC(p.name(), p.type(), p.localNum(), label);
      gen.addParameter(p.localNum(), p.type());
    }
    createBCode(gen);
    if (type().isVoid() && (!hasBlock() || getBlock().canCompleteNormally())) {
      // TODO(joqvist): use deadcode elimination to remove redundant RETURN.
      gen.RETURN();
    }
    gen.addVariableScopeLabel(label);
  }

  syn lazy CodeGeneration ConstructorDecl.bytecodes(ConstantPool constantPool) {
    CodeGeneration gen = new CodeGeneration(constantPool, this);
    try {
      generateBytecodes(gen);
    } catch (CodeGeneration.JumpOffsetError e) {
      // Retry with wide gotos.
      gen = new CodeGeneration(constantPool, this, true);
      generateBytecodes(gen);
    } catch (Error e) {
      System.err.println("Error while processing " + sourceLocation());
      throw e;
    }
    return gen;
  }

  private void ConstructorDecl.generateBytecodes(CodeGeneration gen) {
    int label = gen.variableScopeLabel();
    int paramLength = 1;
    gen.addLocalVariableEntryAtCurrentPC("this", hostType(), 0, label);
    gen.addParameter(0, VerificationTypes.UNINITIALIZED_THIS);
    if (needsEnclosing()) {
      gen.addLocalVariableEntryAtCurrentPC("this$0", enclosing(), 1, label);
      gen.addParameter(1, enclosing());
    }
    if (needsSuperEnclosing()) {
      gen.addLocalVariableEntryAtCurrentPC("this$1", superEnclosing(), 2, label);
      gen.addParameter(2, superEnclosing());
    }
    for (ParameterDeclaration p : getParameterList()) {
      paramLength += p.type().variableSize();
      if (paramLength > 255) {
        throw new Error("parameter list too large");
      }
      gen.addLocalVariableEntryAtCurrentPC(p.name(), p.type(), p.localNum(), label);
      gen.addParameter(p.localNum(), p.type());
    }
    int nextLocal = offsetFirstEnclosingVariable();
    for (Variable var : hostType().enclosingVariables()) {
      paramLength += var.type().variableSize();
      if (paramLength > 255) {
        throw new Error("parameter list too large, not enough room for enclosing variables");
      }
      gen.addLocalVariableEntryAtCurrentPC("val$" + var.name(), var.type(), nextLocal, label);
      gen.addParameter(nextLocal, var.type());
      nextLocal += var.type().variableSize();
    }
    createBCode(gen);
    gen.RETURN();
    gen.addVariableScopeLabel(label);
  }

  public void MethodDecl.createBCode(CodeGeneration gen) {
    try {
      if (hasBlock()) {
        getBlock().createBCode(gen);
      }
    } catch (Error e) {
      System.err.println(hostType().typeName() + ": " + this);
      throw e;
    }
  }

  public void ConstructorDecl.createBCode(CodeGeneration gen) {
    try {
      boolean needsInit = true;

      if (hasConstructorInvocation()) {
        getConstructorInvocation().createBCode(gen);
        Stmt stmt = getConstructorInvocation();
        if (stmt instanceof ExprStmt) {
          ExprStmt exprStmt = (ExprStmt) stmt;
          Expr expr = exprStmt.getExpr();
          if (!expr.isSuperConstructorAccess()) {
            needsInit = false;
          }
        }
      }

      gen.initializedThis(0, hostType());

      if (needsEnclosing()) {
        gen.ALOAD(0, hostType());
        gen.ALOAD(1, enclosing());
        String classname = hostType().constantPoolName();
        String name = "this$0";
        int index = gen.constantPool().addFieldref(classname, name, enclosing());
        gen.PUTFIELD(index);
      }

      int localIndex = offsetFirstEnclosingVariable();
      for (Variable v : hostType().enclosingVariables()) {
        gen.ALOAD(0, hostType());
        v.type().emitLoadLocal(gen, localIndex);
        String classname = hostType().constantPoolName();
        String name = "val$" + v.name();
        int index = gen.constantPool().addFieldref(classname, name, v.type());
        gen.PUTFIELD(index);
        localIndex += v.type().variableSize();
      }

      if (needsInit) {
        TypeDecl typeDecl = hostType();
        for (BodyDecl b : typeDecl.getBodyDeclList()) {
          if (b instanceof FieldDecl) {
            FieldDecl field = (FieldDecl) b;
            if (!field.isStatic()) {
              for (FieldDeclarator decl : field.getDeclaratorList()) {
                if (decl.hasInit()) {
                  gen.ALOAD(0, hostType());
                  decl.emitInitializerBCode(gen);
                  decl.emitStoreField(gen, hostType());
                }
              }
            }
          } else if (b instanceof InstanceInitializer) {
            b.createBCode(gen);
          }
        }
      }
      getBlock().createBCode(gen);
    } catch (Error e) {
      System.err.println(hostType().typeName() + ": " + this);
      throw e;
    }
  }

  public void ASTNode.createBCode(CodeGeneration gen) {
    for (int i = 0; i < getNumChild(); i++) {
      getChild(i).createBCode(gen);
    }
  }

  public void Literal.createBCode(CodeGeneration gen) {
    emitPushConstant(gen);
  }

  // TODO(joqvist): this should be an inherited attribute.
  protected boolean Expr.needsPush() {
    ASTNode n = getParent();
    while (n instanceof ParExpr) {
      n = n.getParent();
    }
    return !(n instanceof ExprStmt);
  }

  syn boolean ExprStmt.needsPop() = getExpr().needsPop();

  syn boolean Expr.needsPop() = true;

  eq Dot.needsPop() = lastAccess().needsPop();

  eq ConstructorAccess.needsPop() = false;

  eq ParExpr.needsPop() = getExpr().needsPop();
  eq AssignExpr.needsPop() = getDest().isVarAccessWithAccessor();
  eq PreIncExpr.needsPop() = getOperand().isVarAccessWithAccessor();
  eq PostIncExpr.needsPop() = getOperand().isVarAccessWithAccessor();
  eq PreDecExpr.needsPop() = getOperand().isVarAccessWithAccessor();
  eq PostDecExpr.needsPop() = getOperand().isVarAccessWithAccessor();

  syn boolean Expr.isVarAccessWithAccessor() = false;
  eq ParExpr.isVarAccessWithAccessor() = getExpr().isVarAccessWithAccessor();
  eq Dot.isVarAccessWithAccessor() = lastAccess().isVarAccessWithAccessor();
  eq VarAccess.isVarAccessWithAccessor() = decl().isInstanceVariable() && requiresAccessor();

  public void VarDeclStmt.createBCode(CodeGeneration gen) {
    gen.addLineNumberEntryAtCurrentPC(this); // Generate line number entry.
    for (VariableDeclarator decl : getDeclaratorList()) {
      decl.createBCode(gen);
    }
  }

  public void VariableDeclarator.createBCode(CodeGeneration gen) {
    if (hasInit()) {
      gen.addLocalVariableEntryAtCurrentPC(name(), type(), localNum(), variableScopeEndLabel(gen));
      emitInitializerBCode(gen);
      type().emitStoreLocal(gen, localNum());
    }
  }

  /**
   * Generate variable initialization bytecode.
   */
  protected void Declarator.emitInitializerBCode(CodeGeneration gen) {
    getInit().createBCode(gen);
    getInit().emitAssignConvTo(gen, type());
  }

  /**
   * Create bytecode for a simple assign expression.
   */
  public void AssignSimpleExpr.createBCode(CodeGeneration gen) {
    getDest().createAssignSimpleLoadDest(gen);
    getSource().createBCode(gen);
    getSource().emitAssignConvTo(gen, getDest().type());
    if (needsPush()) {
      getDest().createPushAssignmentResult(gen);
    }
    getDest().emitStore(gen);
  }

  /**
   * Create bytecode for a compund assign expression.
   */
  public void AssignExpr.createBCode(CodeGeneration gen) {
    TypeDecl dest = getDest().type();
    TypeDecl source = getSource().type();
    TypeDecl type;
    if (dest.isNumericType() && source.isNumericType()) {
      type = dest.binaryNumericPromotion(source);
    } else {
      type = dest;
    }
    getDest().createAssignLoadDest(gen);
    dest.emitCastTo(gen, type);
    getSource().createBCode(gen);
    source.emitCastTo(gen, type);
    emitAssignOp(gen, type);
    type.emitCastTo(gen, dest);
    if (needsPush()) {
      getDest().createPushAssignmentResult(gen);
    }
    getDest().emitStore(gen);
  }

  // Generate code for String addition assignment expression.
  public void AssignPlusExpr.createBCode(CodeGeneration gen) {
    TypeDecl dest = getDest().type();
    if (dest.isString()) {
      TypeDecl stringType = typeString();
      TypeDecl builderType = lookupType("java.lang", "StringBuilder");

      getDest().createAssignLoadDest(gen);

      // Create new StringBuilder instance.
      String classname = builderType.constantPoolName();
      String desc;
      int index;
      TypeDecl argumentType;
      gen.NEW(builderType);
      gen.DUP();
      desc = "()V";
      index = gen.constantPool().addMethodref(classname, "<init>", desc);
      gen.INVOKESPECIAL_void(index, 1); // StringBuilder.<init>()
      gen.initializedRef(builderType);

      gen.SWAP();

      // Call append(dest).
      argumentType = dest.stringPromotion();
      getDest().emitCastTo(gen, argumentType);
      desc = "(" + argumentType.typeDescriptor() + ")" + builderType.typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "append", desc);
      gen.INVOKEVIRTUAL(index, 2, builderType);

      getSource().createBCode(gen);

      // Call append(source).
      argumentType = getSource().type().stringPromotion();
      getSource().emitCastTo(gen, argumentType);
      desc = "(" + argumentType.typeDescriptor() + ")" + builderType.typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "append", desc);
      gen.INVOKEVIRTUAL(index, 2, builderType);

      // Call toString().
      desc = "()" + type().typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "toString", desc);
      gen.INVOKEVIRTUAL(index, 1, stringType);

      if (needsPush()) {
        getDest().createPushAssignmentResult(gen);
      }
      getDest().emitStore(gen);
    } else {
      super.createBCode(gen);
    }
  }

  // Shift assignment expression.
  public void AssignExpr.emitShiftExpr(CodeGeneration gen) {
    TypeDecl dest = getDest().type();
    TypeDecl source = getSource().type();
    TypeDecl type = dest.unaryNumericPromotion();
    getDest().createAssignLoadDest(gen);
    dest.emitCastTo(gen, type);
    getSource().createBCode(gen);
    source.emitCastTo(gen, typeInt());
    emitAssignOp(gen, type);
    type.emitCastTo(gen, dest);
    if (needsPush()) {
      getDest().createPushAssignmentResult(gen);
    }
    getDest().emitStore(gen);
  }

  public void AssignLShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  public void AssignRShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  public void AssignURShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  // Load left hand side of destination in a simple assign expression.
  public void Expr.createAssignSimpleLoadDest(CodeGeneration gen) {
  }

  public void Dot.createAssignSimpleLoadDest(CodeGeneration gen) {
    lastAccess().createAssignSimpleLoadDest(gen);
  }

  public void VarAccess.createAssignSimpleLoadDest(CodeGeneration gen) {
    createLoadQualifier(gen, decl());
  }

  public void ArrayAccess.createAssignSimpleLoadDest(CodeGeneration gen) {
    prevExpr().createBCode(gen);
    getExpr().createBCode(gen);
  }

  /**
   * Duplicate top value on stack and store below destination element.
   */
  public void Expr.createPushAssignmentResult(CodeGeneration gen) {
  }

  public void Dot.createPushAssignmentResult(CodeGeneration gen) {
    lastAccess().createPushAssignmentResult(gen);
  }

  public void VarAccess.createPushAssignmentResult(CodeGeneration gen) {
    if (hostType().needsAccessorFor(decl())) {
      return;
    }
    if (decl().isInstanceVariable()) {
      gen.DUP_X1(type());
    } else {
      gen.DUP(type());
    }
  }

  public void ArrayAccess.createPushAssignmentResult(CodeGeneration gen) {
    gen.DUP_X2(type());
  }

  // Load left hand side of destination in a compound assign expression.
  public void Expr.createAssignLoadDest(CodeGeneration gen) {
  }

  public void Dot.createAssignLoadDest(CodeGeneration gen) {
    lastAccess().createAssignLoadDest(gen);
  }

  /**
   * Generates bytecode to access the target for an assignment operation.
   *
   * <p>This may involve loading an object reference to store a field in the object.
   */
  public void VarAccess.createAssignLoadDest(CodeGeneration gen) {
    createLoadQualifier(gen, decl());
    Variable v = decl();
    if (v.isInstanceVariable()) {
      gen.DUP();
    }
    if (v instanceof VariableDeclarator) {
      VariableDeclarator var = (VariableDeclarator) v;
      var.type().emitLoadLocal(gen, var.localNum());
    } else if (v.isField()) {
      if (requiresAccessor()) {
        fieldQualifierType().fieldAccessor(v).emitInvokeMethod(gen, fieldQualifierType());
      } else {
        v.emitLoadField(gen, fieldQualifierType());
      }
    } else if (v instanceof ParameterDeclaration) {
      ParameterDeclaration decl = (ParameterDeclaration) v;
      decl.type().emitLoadLocal(gen, decl.localNum());
    }
  }

  public void ArrayAccess.createAssignLoadDest(CodeGeneration gen) {
    prevExpr().createBCode(gen);
    gen.DUP();
    getExpr().createBCode(gen);
    gen.DUP_X1(typeInt());
    type().emitArrayLoad(gen);
  }

  /** Select the typed operation for a compound assign expression. */
  public void AssignExpr.emitAssignOp(CodeGeneration gen, TypeDecl type) {
    throw new Error("Operation emitAssignOp is not implemented for type " + getClass().getName());
  }

  public void AssignMulExpr.emitAssignOp(CodeGeneration gen, TypeDecl type)     { type.mul(gen); }
  public void AssignDivExpr.emitAssignOp(CodeGeneration gen, TypeDecl type)     { type.div(gen); }
  public void AssignModExpr.emitAssignOp(CodeGeneration gen, TypeDecl type)     { type.rem(gen); }
  public void AssignPlusExpr.emitAssignOp(CodeGeneration gen, TypeDecl type)    { type.add(gen); }
  public void AssignMinusExpr.emitAssignOp(CodeGeneration gen, TypeDecl type)   { type.sub(gen); }
  public void AssignLShiftExpr.emitAssignOp(CodeGeneration gen, TypeDecl type)  { type.shl(gen); }
  public void AssignRShiftExpr.emitAssignOp(CodeGeneration gen, TypeDecl type)  { type.shr(gen); }
  public void AssignURShiftExpr.emitAssignOp(CodeGeneration gen, TypeDecl type) { type.ushr(gen); }
  public void AssignAndExpr.emitAssignOp(CodeGeneration gen, TypeDecl type)     { type.bitand(gen); }
  public void AssignXorExpr.emitAssignOp(CodeGeneration gen, TypeDecl type)     { type.bitxor(gen); }
  public void AssignOrExpr.emitAssignOp(CodeGeneration gen, TypeDecl type)      { type.bitor(gen); }

  public void Dot.createBCode(CodeGeneration gen) {
    if (transformed() != this) {
      transformed().createBCode(gen);
    } else {
      getRight().createBCode(gen);
    }
  }

  public void VarAccess.createBCode(CodeGeneration gen) {
    decl().emitLoadVariable(gen, this);
  }

  /**
   * Generate bytecode to load a field, local variable, or parameter.
   *
   * @param gen bytecode output.
   * @param access the access for which the variable load is to be generated.
   */
  void Variable.emitLoadVariable(CodeGeneration gen, Access access);

  // TODO(joqvist): remove this - added to fix build problem with JastAdd 2.2.2.
  // See https://bitbucket.org/jastadd/jastadd2/issues/282/abstract-interface-methods-are-added-to
  public void Declarator.emitLoadVariable(CodeGeneration gen, Access access) {
    throw new Error("Missing implementation for emitLoadVariable in " + getClass().getName());
  }

  public void VariableDeclarator.emitLoadVariable(CodeGeneration gen, Access access) {
    if (hostType() == access.hostType()) {
      type().emitLoadLocal(gen, localNum());
    } else {
      access.emitLoadLocalInNestedClass(gen, this);
    }
  }

  public void FieldDeclarator.emitLoadVariable(CodeGeneration gen, Access access) {
    access.createLoadQualifier(gen, this);
    if (isConstant() && (type().isPrimitive() || type().isString())) {
      if (!isStatic()) {
        gen.POP(access.fieldQualifierType());
      }
      constant().createBCode(gen);
    } else if (access.requiresAccessor()) {
      access.fieldQualifierType().fieldAccessor(this).emitInvokeMethod(gen,
          access.fieldQualifierType());
    } else {
      emitLoadField(gen, access.fieldQualifierType());
    }
  }

  public void ParameterDeclaration.emitLoadVariable(CodeGeneration gen, Access access) {
    if (hostType() == access.hostType()) {
      type().emitLoadLocal(gen, localNum());
    } else {
      access.emitLoadLocalInNestedClass(gen, this);
    }
  }

  syn boolean TypeDecl.needsAccessorFor(Variable v) {
    if (!(v instanceof FieldDeclarator)) {
      return false;
    }
    if (v.isConstant() && (v.type().isPrimitive() || v.type().isString())) {
      return false;
    }
    return v.isPrivate() && !hasField(v.name());
  }

  inh boolean Access.inExplicitConstructorInvocation();

  protected void Access.emitLoadLocalInNestedClass(CodeGeneration gen, Variable v) {
    if (inExplicitConstructorInvocation() && enclosingBodyDecl() instanceof ConstructorDecl) {
      ConstructorDecl c = (ConstructorDecl) enclosingBodyDecl();
      v.type().emitLoadLocal(gen, c.localIndexOfEnclosingVariable(v));
    } else {
      String classname = hostType().constantPoolName();
      String      name = "val$" + v.name();
      int index = gen.constantPool().addFieldref(classname, name, v.type());
      gen.ALOAD(0, hostType());
      gen.GETFIELD(index, v.type());
    }
  }

  /**
   * Generate bytecode to push on the stack the qualifier to access the variable v.
   */
  protected void Access.createLoadQualifier(CodeGeneration gen, Variable v) {
    if (v.isField()) {
      if (hasPrevExpr()) {
        // Load explicit qualifier.
        prevExpr().createBCode(gen);
        // Pop qualifier stack element for class variables.
        // This qualifier must be computed to ensure side effects are evaluated.
        if (!prevExpr().isTypeAccess() && v.isClassVariable()) {
          gen.POP(prevExpr().type());
        } else {
          prevExpr().emitCastTo(gen, fieldQualifierType());
        }
      } else if (v.isInstanceVariable()) {
        emitThis(gen, fieldQualifierType());
      }
    }
  }

  /**
   * Prints diagnostic error messages for debugging method binding errors.
   */
  public void MethodAccess.printDiagnosticMessages() {
    if (decl().type().isUnknown()) {
      System.err.format("Could not bind %s()%n", name());
      for (Expr arg : getArgList()) {
        System.err.format("Argument %d is of type %s%n",
            arg,
            arg.type().typeName());
        if (arg.varDecl() != null) {
          System.err.format("%s in %s%n",
              arg.varDecl().name(),
              arg.varDecl().hostType().typeName());
        }
      }
      if (isQualified()) {
        System.err.format("Qualifier %s is of type %s%n",
            qualifier().prettyPrint(),
            qualifier().type().typeName());
      }
      throw new Error(String.format("Could not bind %s()", name()));
    }
    if (decl().getNumParameter() != getNumArg()) {
      System.out.format("%s() does not have the same number of arguments as %s()%n",
          name(), decl().name());
    }
  }

  public void MethodAccess.createBCode(CodeGeneration gen) {
    if (transformed() != this) {
      // Ensure bytecode is generated for the transformed access.
      transformed().createBCode(gen);
      return;
    }
    createLoadQualifier(gen);

    if (program().options().hasOption("-debug")) {
      printDiagnosticMessages();
    }

    // Perform method invocation conversions.
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      getArg(i).emitCastTo(gen, decl().paramType(i));
    }

    if (!decl().isStatic() && isQualified() && prevExpr().isSuperAccess()
        || isSuperAccessor) {
      decl().emitInvokeSpecialMethod(gen, methodQualifierType());
    } else {
      decl().emitInvokeMethod(gen, methodQualifierType());
    }
  }

  protected void MethodAccess.createLoadQualifier(CodeGeneration gen) {
    MethodDecl m = decl();
    if (hasPrevExpr()) {
      // Load explicit qualifier
      prevExpr().createBCode(gen);
      // Pop qualifier stack element for class variables.
      // This qualifier must be computed to ensure side effects are evaluated.
      if (m.isStatic() && !prevExpr().isTypeAccess()) {
        gen.POP(prevExpr().type());
      } else {
        prevExpr().emitCastTo(gen, methodQualifierType());
      }
    } else if (!m.isStatic()) {
      // Load implicit this qualifier.
      emitThis(gen, methodQualifierType());
    }
  }

  public void ArrayAccess.createBCode(CodeGeneration gen) {
    prevExpr().createBCode(gen);
    getExpr().createBCode(gen);
    type().emitArrayLoad(gen);
  }

  public void ThisAccess.createBCode(CodeGeneration gen) {
    emitThis(gen, decl());
  }

  public void SuperAccess.createBCode(CodeGeneration gen) {
    emitThis(gen, decl());
  }

  // Load this where hostType is the target this instance
  // supporting inner classes and in explicit contructor invocations.
  public void Access.emitThis(CodeGeneration gen, TypeDecl targetDecl) {
    if (targetDecl == hostType()) {
      gen.ALOAD(0, hostType());
    } else {
      TypeDecl enclosing = hostType();
      if (inExplicitConstructorInvocation()) {
        gen.ALOAD(1, enclosing.enclosing());
        enclosing = enclosing.enclosing();
      } else {
        gen.ALOAD(0, enclosing);
      }
      while (enclosing != targetDecl) {
        String classname = enclosing.constantPoolName();
        enclosing = enclosing.enclosingType();
        int index = gen.constantPool().addFieldref(classname, "this$0", enclosing);
        gen.GETFIELD(index, enclosing);
      }
    }
  }

  public void ConstructorAccess.createBCode(CodeGeneration gen) {
    if (transformed() != this) {
      // Ensure bytecode is generated for the transformed access.
      transformed().createBCode(gen);
      return;
    }

    ConstructorDecl decl = decl().bytecodeTarget();
    int index = 0;
    // Push this argument.
    gen.ALOAD(index++, VerificationTypes.UNINITIALIZED_THIS);
    // Push this$0 argument.
    if (decl.needsEnclosing()) {
      gen.ALOAD(index++, hostType().enclosing());
    }
    if (decl.needsSuperEnclosing()) {
      gen.ALOAD(index++, hostType().superEnclosing());
    }
    // Push formal arguments.
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      // Method invocation conversion:
      getArg(i).emitCastTo(gen, decl.paramType(i));
    }
    // Push enclosing variable arguments.
    for (Variable var : decl.hostType().enclosingVariables()) {
      var.emitLoadVariable(gen, this);
    }
    if (decl.isPrivate() && decl.hostType() != hostType()) {
      gen.ACONST_NULL();
      decl.createAccessor().emitInvokeConstructor(gen);
    } else {
      decl.emitInvokeConstructor(gen);
    }
  }

  public void SuperConstructorAccess.createBCode(CodeGeneration gen) {
    if (transformed() != this) {
      // Ensure bytecode is generated for the transformed access.
      transformed().createBCode(gen);
      return;
    }

    ConstructorDecl decl = decl().bytecodeTarget();

    // Push this argument.
    gen.ALOAD(0, VerificationTypes.UNINITIALIZED_THIS);

    if (decl.needsEnclosing()) {
      if (hasPrevExpr() && !prevExpr().isTypeAccess()) {
        prevExpr().createBCode(gen);
        gen.DUP();
        int index = gen.constantPool().addMethodref("java/lang/Object", "getClass",
            "()Ljava/lang/Class;");
        gen.INVOKEVIRTUAL(index, 1, lookupType("java.lang", "Class"));
        gen.POP();
      } else {
        if (hostType().needsSuperEnclosing()) {
          if (hostType().needsEnclosing()) {
            gen.ALOAD(2, hostType().enclosing());
          } else {
            gen.ALOAD(1, hostType());
          }
        } else {
          emitThis(gen, superConstructorQualifier(decl.hostType().enclosingType()));
        }
      }
    }

    // Push formal arguments.
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      // Method invocation conversion:
      getArg(i).emitCastTo(gen, decl.paramType(i));
    }
    // Push enclosing variable arguments.
    for (Variable var : decl.hostType().enclosingVariables()) {
      var.emitLoadVariable(gen, this);
    }
    if (decl.isPrivate() && decl.hostType() != hostType()) {
      gen.ACONST_NULL();
      decl.createAccessor().emitInvokeConstructor(gen);
    } else {
      decl.emitInvokeConstructor(gen);
    }
  }

  // 15.9.2
  private void ClassInstanceExpr.emitLocalEnclosing(CodeGeneration gen, TypeDecl localClass) {
    if (!localClass.inStaticContext()) {
      emitThis(gen, localClass.enclosingType());
    }
  }

  private void ClassInstanceExpr.emitInnerMemberEnclosing(CodeGeneration gen, TypeDecl innerClass) {
    if (hasPrevExpr()) {
      prevExpr().createBCode(gen);
      gen.DUP();
      int index = gen.constantPool()
          .addMethodref("java/lang/Object", "getClass", "()Ljava/lang/Class;");
      gen.INVOKEVIRTUAL(index, 1, lookupType("java.lang", "Class"));
      gen.POP();
    } else {
      TypeDecl enclosing = hostType();
      while (enclosing != null && !enclosing.hasType(innerClass.name())) {
        enclosing = enclosing.enclosingType();
      }
      if (enclosing == null) {
        throw new Error(errorPrefix() + "Could not find enclosing for " + this);
      } else {
        emitThis(gen, enclosing);
      }
    }
  }

  public void ClassInstanceExpr.createBCode(CodeGeneration gen) {
    if (transformed() != this) {
      // Ensure bytecode is generated for the transformed access.
      transformed().createBCode(gen);
      return;
    }

    gen.NEW(type());
    gen.DUP(type());

    // 15.9.2 first part
    if (type().isAnonymous()) {
      if (isAnonymousInNonStaticContext()) {
        if (type().inExplicitConstructorInvocation()) {
          gen.ALOAD(1, type().enclosing());
        } else {
          gen.ALOAD(0, type());
        }
      }
      // 15.9.2 second part
      ClassDecl C = (ClassDecl) type();
      TypeDecl S = C.superclass();
      if (S.isLocalClass()) {
        if (!type().inStaticContext()) {
          emitLocalEnclosing(gen, S);
        }
      } else if (S.isInnerType()) {
        emitInnerMemberEnclosing(gen, S);
      }
    } else if (type().isLocalClass()) {
      if (!type().inStaticContext()) {
        emitLocalEnclosing(gen, type());
      }
    } else if (type().isInnerType()) {
      emitInnerMemberEnclosing(gen, type());
    }

    ConstructorDecl decl = decl().bytecodeTarget();

    // Push formal arguments.
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      // Method invocation conversion:
      getArg(i).emitCastTo(gen, decl.paramType(i));
    }
    // Push enclosing variable arguments.
    for (Variable var : decl.hostType().enclosingVariables()) {
      var.emitLoadVariable(gen, this);
    }

    if (decl.isPrivate() && type() != hostType()) {
      gen.ACONST_NULL();
      decl.createAccessor().emitInvokeConstructor(gen);
    } else {
      decl.emitInvokeConstructor(gen);
    }
    // Mark the top stack reference as initialized.
    gen.initializedRef(type());
  }

  /**
   * The constructor that is called in bytecode.
   */
  syn ConstructorDecl ConstructorDecl.bytecodeTarget() = this;

  public void ArrayCreationExpr.createBCode(CodeGeneration gen) {
    if (hasArrayInit()){
      getArrayInit().createBCode(gen);
    } else {
      getTypeAccess().createBCode(gen); // Push array sizes.
      if (type().componentType().isPrimitive()) {
        gen.NEWARRAY(type());
      } else {
        if (numArrays() == 1) {
          gen.ANEWARRAY(type());
        } else {
          gen.MULTIANEWARRAY(type(), numArrays());
        }
      }
    }
  }

  public void ArrayInit.createBCode(CodeGeneration gen) {
    IntegerLiteral.push(gen, getNumInit());
    if (type().componentType().isPrimitive()) {
      gen.NEWARRAY(type());
    } else {
      gen.ANEWARRAY(type());
    }
    for (int i = 0; i < getNumInit(); i++) {
      gen.DUP();
      IntegerLiteral.push(gen, i);
      getInit(i).createBCode(gen);
      if (getInit(i) instanceof ArrayInit) {
        gen.AASTORE();
      } else {
        getInit(i).emitAssignConvTo(gen, expectedType());
        expectedType().emitArrayStore(gen);
      }
    }
  }

  public void ArrayTypeAccess.createBCode(CodeGeneration gen) {
    getAccess().createBCode(gen);
  }
  public void ArrayTypeWithSizeAccess.createBCode(CodeGeneration gen) {
    getAccess().createBCode(gen);
    getExpr().createBCode(gen);
  }

  syn String TypeDecl.arrayTypeDescriptor() { throw new Error("Operation not supported"); }
  eq ArrayDecl.arrayTypeDescriptor() = typeDescriptor();
  eq ClassDecl.arrayTypeDescriptor() = constantPoolName();
  eq InterfaceDecl.arrayTypeDescriptor() = constantPoolName();

  syn int TypeDecl.arrayPrimitiveTypeDescriptor() {
    codeGenError("primitive array type descriptor");
    // Unreachable:
    return -1;
  }
  eq BooleanType.arrayPrimitiveTypeDescriptor() = 4;  // T_BOOLEAN
  eq CharType.arrayPrimitiveTypeDescriptor()    = 5;  // T_CHAR
  eq FloatType.arrayPrimitiveTypeDescriptor()   = 6;  // T_FLOAT
  eq DoubleType.arrayPrimitiveTypeDescriptor()  = 7;  // T_DOUBLE
  eq ByteType.arrayPrimitiveTypeDescriptor()    = 8;  // T_BYTE
  eq ShortType.arrayPrimitiveTypeDescriptor()   = 9;  // T_SHORT
  eq IntType.arrayPrimitiveTypeDescriptor()     = 10; // T_INT
  eq LongType.arrayPrimitiveTypeDescriptor()    = 11; // T_LONG

  public void Unary.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    emitOperation(gen);
  }

  public void CastExpr.createBCode(CodeGeneration gen) {
    getExpr().createBCode(gen);
    getExpr().emitCastTo(gen, type());
  }

  // TODO(joqvist): consider using IINC or WIDE, IINC.

  public void Unary.emitPostfix(CodeGeneration gen, int constant) {
    Expr operand = getOperand();
    while (operand instanceof ParExpr) {
      operand = ((ParExpr) operand).getExpr();
    }
    Access access = ((Access) operand).lastAccess();
    access.createAssignLoadDest(gen);
    if (needsPush()) {
      access.createPushAssignmentResult(gen);
    }
    TypeDecl type = access.type().binaryNumericPromotion(typeInt());
    type.emitPushConstant(gen, constant);
    type.add(gen);
    type.emitCastTo(gen, access.type());
    access.emitStore(gen);
  }

  public void PostIncExpr.createBCode(CodeGeneration gen) {
    emitPostfix(gen, 1);
  }

  public void PostDecExpr.createBCode(CodeGeneration gen) {
    emitPostfix(gen, -1);
  }

  public void Unary.emitPrefix(CodeGeneration gen, int constant) {
    Expr operand = getOperand();
    while (operand instanceof ParExpr) {
      operand = ((ParExpr) operand).getExpr();
    }
    Access access = ((Access) operand).lastAccess();
    access.createAssignLoadDest(gen);
    TypeDecl type = access.type().binaryNumericPromotion(typeInt());
    type.emitPushConstant(gen, constant);
    type.add(gen);
    type.emitCastTo(gen, access.type());
    if (needsPush()) {
      access.createPushAssignmentResult(gen);
    }
    access.emitStore(gen);
  }

  public void PreIncExpr.createBCode(CodeGeneration gen) {
    emitPrefix(gen, 1);
  }

  public void PreDecExpr.createBCode(CodeGeneration gen) {
    emitPrefix(gen, -1);
  }

  public void Binary.createBCode(CodeGeneration gen) {
    getLeftOperand().createBCode(gen);
    getLeftOperand().emitCastTo(gen, type()); // Binary numeric promotion.
    getRightOperand().createBCode(gen);
    getRightOperand().emitCastTo(gen, type()); // Binary numeric promotion.
    emitOperation(gen);
  }

  public void Binary.emitShiftExpr(CodeGeneration gen) {
    getLeftOperand().createBCode(gen);
    getLeftOperand().emitCastTo(gen, type()); // Binary numeric promotion.
    getRightOperand().createBCode(gen);
    getRightOperand().emitCastTo(gen, typeInt());
    emitOperation(gen);
  }

  public void LShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  public void RShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  public void URShiftExpr.createBCode(CodeGeneration gen) {
    emitShiftExpr(gen);
  }

  public void AddExpr.createBCode(CodeGeneration gen) {
    if (!type().isString()) {
      super.createBCode(gen);
    } else if (isConstant()) {
      StringLiteral.push(gen, constant().stringValue());
    } else {
      TypeDecl stringType = typeString();
      TypeDecl builderType = lookupType("java.lang", "StringBuilder");

      String classname = builderType.constantPoolName();
      String desc;
      int index;
      TypeDecl argumentType;
      if (firstStringAddPart()) {
        gen.NEW(builderType); // new StringBuilder()
        gen.DUP();
        desc = "()V";
        index = gen.constantPool().addMethodref(classname, "<init>", desc);
        gen.INVOKESPECIAL_void(index, 1); // StringBuilder.<init>()
        gen.initializedRef(builderType);
        getLeftOperand().createBCode(gen);
        argumentType = getLeftOperand().type().stringPromotion();
        getLeftOperand().emitCastTo(gen, argumentType);
        desc = "(" + argumentType.typeDescriptor() + ")" + builderType.typeDescriptor();
        index = gen.constantPool().addMethodref(classname, "append", desc);
        gen.INVOKEVIRTUAL(index, 2, builderType); // StringBuilder.append(left)
      } else {
        getLeftOperand().createBCode(gen);
      }
      getRightOperand().createBCode(gen);
      argumentType = getRightOperand().type().stringPromotion();
      getRightOperand().emitCastTo(gen, argumentType);
      desc = "(" + argumentType.typeDescriptor() + ")" + builderType.typeDescriptor();
      index = gen.constantPool().addMethodref(classname, "append", desc);
      gen.INVOKEVIRTUAL(index, 2, builderType);
      if (lastStringAddPart()) {
        desc = "()" + type().typeDescriptor();
        index = gen.constantPool().addMethodref(classname, "toString", desc);
        gen.INVOKEVIRTUAL(index, 1, stringType);
      }
    }
  }

  syn boolean Expr.canBeTrue() = !isFalse();
  eq CastExpr.canBeTrue() = getExpr().canBeTrue();
  eq ParExpr.canBeTrue() = getExpr().canBeTrue();
  eq Dot.canBeTrue() = lastAccess().canBeTrue();
  eq OrLogicalExpr.canBeTrue() = getLeftOperand().canBeTrue() || getRightOperand().canBeTrue();
  eq AndLogicalExpr.canBeTrue() = getLeftOperand().canBeTrue() && getRightOperand().canBeTrue();
  eq ConditionalExpr.canBeTrue() =
      type().isBoolean()
      && (getCondition().canBeTrue() && getTrueExpr().canBeTrue()
          || getCondition().canBeFalse() && getFalseExpr().canBeTrue());
  eq LogNotExpr.canBeTrue() = getOperand().canBeFalse();

  syn boolean Expr.canBeFalse() = !isTrue();
  eq CastExpr.canBeFalse() = getExpr().canBeFalse();
  eq ParExpr.canBeFalse() = getExpr().canBeFalse();
  eq Dot.canBeFalse() = lastAccess().canBeFalse();
  eq OrLogicalExpr.canBeFalse() = getLeftOperand().canBeFalse() && getRightOperand().canBeFalse();
  eq AndLogicalExpr.canBeFalse() = getLeftOperand().canBeFalse() || getRightOperand().canBeFalse();
  eq ConditionalExpr.canBeFalse() =
      type().isBoolean()
      && (getCondition().canBeTrue() && getTrueExpr().canBeFalse()
          || getCondition().canBeFalse() && getFalseExpr().canBeFalse());
  eq LogNotExpr.canBeFalse() = getOperand().canBeTrue();

  public void RelationalExpr.createBCode(CodeGeneration gen) { emitBooleanCondition(gen); }
  public void LogNotExpr.createBCode(CodeGeneration gen) { emitBooleanCondition(gen); }
  public void LogicalExpr.createBCode(CodeGeneration gen) { emitBooleanCondition(gen); }

  protected void Expr.emitBooleanCondition(CodeGeneration gen) {
    int end_label = -1;
    int false_label = -1;
    if (!isConstant()) {
      false_label = gen.constantPool().newLabel();
      branchFalse(gen, false_label);
    }
    if (canBeTrue()) {
      BooleanLiteral.push(gen, true);
      if (canBeFalse()) {
        end_label = gen.constantPool().newLabel();
        gen.GOTO(end_label);
      }
    }
    if (false_label != -1) {
      gen.addLabel(false_label);
    }
    if (canBeFalse()) {
      BooleanLiteral.push(gen, false);
    }
    if (end_label != -1) {
      gen.addLabel(end_label);
    }
  }

  public void ConditionalExpr.createBCode(CodeGeneration gen) {
    int end_label = -1;
    int false_label = -1;
    if (!getCondition().isConstant()) {
      false_label = gen.constantPool().newLabel();
      getCondition().branchFalse(gen, false_label);
    }
    if (getCondition().canBeTrue()) {
      getTrueExpr().createBCode(gen);
      getTrueExpr().emitCastTo(gen, type());
      if (getCondition().canBeFalse()) {
        end_label = gen.constantPool().newLabel();
        gen.GOTO(end_label);
      }
    }
    if (false_label != -1) {
      gen.addLabel(false_label);
    }
    if (getCondition().canBeFalse()) {
      getFalseExpr().createBCode(gen);
      getFalseExpr().emitCastTo(gen, type());
    }
    if (end_label != -1) {
      gen.addLabel(end_label);
    }
  }

  /**
   * Generate a conditional branch statement. The branch should be taken if the
   * expression evaluates to true. May in some cases not result in an actual
   * branch statement if the branch would never be taken.
   * @param gen code generator
   * @param target target label to jump to if the condition was true
   */
  public void Expr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    if (isConstant()) {
      if (isTrue()) {
        gen.GOTO(target);
      }
    } else {
      createBCode(gen);
      gen.IFNE(target);
    }
  }

  public void ParExpr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    getExpr().branchTrue(gen, target);
  }

  public void Dot.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    lastAccess().branchTrue(gen, target);
  }

  public void LogNotExpr.branchTrue(CodeGeneration gen, int target)  {
    // Branch when true.
    getOperand().branchFalse(gen, target);
  }

  public void AndLogicalExpr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    Expr left = getLeftOperand();
    Expr right = getRightOperand();
    int skip_lbl = -1;
    if (!left.isConstant()) {
      skip_lbl = gen.constantPool().newLabel();
      left.branchFalse(gen, skip_lbl);
    }
    if (left.canBeTrue()) {
      right.branchTrue(gen, target);
    }
    if (skip_lbl != -1) {
      gen.addLabel(skip_lbl);
    }
  }

  public void OrLogicalExpr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    Expr left = getLeftOperand();
    Expr right = getRightOperand();
    if (!left.isFalse()) {
      left.branchTrue(gen, target);
    }
    if (left.canBeFalse()) {
      right.branchTrue(gen, target);
    }
  }

  public void ConditionalExpr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    int else_label = -1;
    int end_label = -1;
    if (!getCondition().isConstant()) {
      else_label = gen.constantPool().newLabel();
      getCondition().branchFalse(gen, else_label);
    }
    if (getCondition().canBeTrue()) {
      getTrueExpr().branchTrue(gen, target);
      if (getCondition().canBeFalse() && getTrueExpr().canBeFalse()) {
        end_label = gen.constantPool().newLabel();
        gen.GOTO(end_label);
      }
    }
    if (else_label != -1) {
      gen.addLabel(else_label);
    }
    if (getCondition().canBeFalse()) {
      getFalseExpr().branchTrue(gen, target);
    }
    if (end_label != -1) {
      gen.addLabel(end_label);
    }
  }

  public void RelationalExpr.branchTrue(CodeGeneration gen, int target) {
    // Branch when true.
    if (isConstant()) {
      if (isTrue()) {
        gen.GOTO(target);
      }
    } else {
      TypeDecl type = getLeftOperand().type();
      if (type.isNumericType()) {
        type = binaryNumericPromotedType();
        getLeftOperand().createBCode(gen);
        getLeftOperand().emitCastTo(gen, type); // Binary numeric promotion.
        getRightOperand().createBCode(gen);
        getRightOperand().emitCastTo(gen, type); // Binary numeric promotion.
      } else {
        getLeftOperand().createBCode(gen);
        getRightOperand().createBCode(gen);
      }
      compareBranch(gen, target, type);
    }
  }

  /**
   * Generate a conditional branch statement. The branch should be taken if the
   * expression evaluates to false. May in some cases not result in an actual
   * branch statement if the branch would never be taken.
   * @param gen code generator
   * @param target target label to jump to if the condition was false
   */
  public void Expr.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    if (isConstant()) {
      if (isFalse()) {
        gen.GOTO(target);
      }
    } else {
      createBCode(gen);
      gen.IFEQ(target);
    }
  }

  public void ParExpr.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    getExpr().branchFalse(gen, target);
  }

  public void Dot.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    lastAccess().branchFalse(gen, target);
  }

  public void LogNotExpr.branchFalse(CodeGeneration gen, int target)  {
    // Branch when false.
    getOperand().branchTrue(gen, target);
  }

  public void AndLogicalExpr.branchFalse(CodeGeneration gen, int target) {
    // branch when false
    Expr left = getLeftOperand();
    Expr right = getRightOperand();
    if (!left.isTrue()) {
      left.branchFalse(gen, target);
    }
    if (left.canBeTrue()) {
      right.branchFalse(gen, target);
    }
  }

  public void OrLogicalExpr.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    Expr left = getLeftOperand();
    Expr right = getRightOperand();
    int skip_lbl = -1;
    if (!left.isConstant()) {
      skip_lbl = gen.constantPool().newLabel();
      left.branchTrue(gen, skip_lbl);
    }
    if (left.canBeFalse()) {
      right.branchFalse(gen, target);
    }
    if (skip_lbl != -1) {
      gen.addLabel(skip_lbl);
    }
  }

  public void ConditionalExpr.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    int else_label = -1;
    int end_label = -1;
    if (!getCondition().isConstant()) {
      else_label = gen.constantPool().newLabel();
      getCondition().branchFalse(gen, else_label);
    }
    if (getCondition().canBeTrue()) {
      getTrueExpr().branchFalse(gen, target);
      if (getCondition().canBeFalse() && getTrueExpr().canBeTrue()) {
        end_label = gen.constantPool().newLabel();
        gen.GOTO(end_label);
      }
    }
    if (else_label != -1) {
      gen.addLabel(else_label);
    }
    if (getCondition().canBeFalse()) {
      getFalseExpr().branchFalse(gen, target);
    }
    if (end_label != -1) {
      gen.addLabel(end_label);
    }
  }

  public void RelationalExpr.branchFalse(CodeGeneration gen, int target) {
    // Branch when false.
    if (isConstant()) {
      if (isFalse()) {
        gen.GOTO(target);
      }
    } else {
      TypeDecl type = getLeftOperand().type();
      if (type.isNumericType()) {
        type = binaryNumericPromotedType();
        getLeftOperand().createBCode(gen);
        getLeftOperand().emitCastTo(gen, type); // Binary numeric promotion.
        getRightOperand().createBCode(gen);
        getRightOperand().emitCastTo(gen, type); // Binary numeric promotion.
      } else {
        getLeftOperand().createBCode(gen);
        getRightOperand().createBCode(gen);
      }
      compareNotBranch(gen, target, type);
    }
  }

  public void RelationalExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    throw new Error("compareBranch not implemented for " + getClass().getName());
  }

  public void LTExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchLT(gen, label);
  }

  public void LEExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchLE(gen, label);
  }

  public void GEExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchGE(gen, label);
  }

  public void GTExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchGT(gen, label);
  }

  public void EQExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchEQ(gen, label);
  }

  public void NEExpr.compareBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchNE(gen, label);
  }

  public void RelationalExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    throw new Error("compareNotBranch not implemented for " + getClass().getName());
  }

  public void LTExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchGEInv(gen, label);
  }

  public void LEExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchGTInv(gen, label);
  }

  public void GEExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchLTInv(gen, label);
  }

  public void GTExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchLEInv(gen, label);
  }

  public void EQExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchNE(gen, label);
  }

  public void NEExpr.compareNotBranch(CodeGeneration gen, int label, TypeDecl typeDecl) {
    typeDecl.branchEQ(gen, label);
  }

  public void InstanceOfExpr.createBCode(CodeGeneration gen) {
    getExpr().createBCode(gen);
    gen.INSTANCEOF(getTypeAccess().type());
  }

  public void Stmt.createBCode(CodeGeneration gen) {
    gen.addLineNumberEntryAtCurrentPC(this);
  }

  public void Block.createBCode(CodeGeneration gen) {
    for (Stmt stmt : getStmtList()) {
      try {
        stmt.createBCode(gen);
      } catch (Exception e) {
        e.printStackTrace();
        System.err.println(dumpTree());
        throw new Error("Error generating code for " + errorPrefix() + " " + stmt);
      }
    }
    gen.addVariableScopeLabel(variableScopeEndLabel(gen));
  }

  public void EmptyStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
  }

  syn lazy int LabeledStmt.label() = hostType().constantPool().newLabel();

  syn lazy int LabeledStmt.end_label() = hostType().constantPool().newLabel();

  public void LabeledStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    gen.addLabel(label());
    getStmt().createBCode(gen);
    gen.addLabel(end_label());
  }

  public void ExprStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    getExpr().createBCode(gen);
    if (needsPop()) {
      gen.POP(getExpr().type());
    }
  }

  /**
   * @return a reference to the default case lable, or {@code null}
   * if there is no default case.
   */
  syn lazy DefaultCase SwitchStmt.defaultCase() {
    for (int i= 0; i < getBlock().getNumStmt(); i++) {
      if (getBlock().getStmt(i) instanceof DefaultCase) {
        return (DefaultCase) getBlock().getStmt(i);
      }
    }
    return null;
  }

  syn lazy int SwitchStmt.end_label() = hostType().constantPool().newLabel();

  public void SwitchStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    int switch_label = gen.constantPool().newLabel();

    getExpr().createBCode(gen);

    ArrayList<CaseLabel> cases = new ArrayList<CaseLabel>();
    for (Stmt stmt : getBlock().getStmts()) {
      if (stmt instanceof ConstCase) {
        cases.add(new CaseLabel((ConstCase) stmt));
      }
    }

    gen.SWITCH(cases, defaultLabel());

    getBlock().createBCode(gen);

    gen.addLabel(end_label());
  }

  syn int SwitchStmt.numCase() {
    int result = 0;
    for (int i = 0; i < getBlock().getNumStmt(); i++) {
      if (getBlock().getStmt(i) instanceof Case) {
        result++;
      }
    }
    return result;
  }

  /**
   * @return label to be used as default target in switch bytecode instruction
   */
  private int SwitchStmt.defaultLabel() {
    DefaultCase defaultCase = defaultCase();
    if (defaultCase != null) {
      return defaultCase.label();
    } else {
      return end_label();
    }
  }

  syn lazy int Case.label() = hostType().constantPool().newLabel();

  public void Case.createBCode(CodeGeneration gen) {
    gen.addLabel(label());
  }

  syn lazy int IfStmt.else_branch_label() = hostType().constantPool().newLabel();

  syn lazy int IfStmt.then_branch_label() = hostType().constantPool().newLabel();

  syn lazy int IfStmt.end_label() = hostType().constantPool().newLabel();

  public void IfStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    int elseBranch = else_branch_label();
    int thenBranch = then_branch_label();
    int endBranch = end_label();
    if (!getCondition().isConstant()) {
      getCondition().branchFalse(gen, elseBranch);
    }
    gen.addLabel(thenBranch);
    if (getCondition().canBeTrue()) {
      getThen().createBCode(gen);
      if (getThen().canCompleteNormally() && hasElse() && getCondition().canBeFalse()) {
        gen.GOTO(endBranch);
      }
    }
    gen.addLabel(elseBranch);
    if (hasElse() && getCondition().canBeFalse()) {
      getElse().createBCode(gen);
    }
    gen.addLabel(endBranch);
  }

  syn lazy int WhileStmt.cond_label() = hostType().constantPool().newLabel();
  syn lazy int WhileStmt.end_label() = hostType().constantPool().newLabel();
  syn lazy int WhileStmt.stmt_label() = hostType().constantPool().newLabel();

  public void WhileStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    gen.addLabel(cond_label());
    if (!getCondition().isConstant()) {
      getCondition().branchFalse(gen, end_label());
    }
    gen.addLabel(stmt_label());
    if (getCondition().canBeTrue()) {
      getStmt().createBCode(gen);
      if (getStmt().canCompleteNormally()) {
        gen.GOTO(cond_label());
      }
    }
    gen.addLabel(end_label());
  }

  syn lazy int DoStmt.begin_label() = hostType().constantPool().newLabel();
  syn lazy int DoStmt.cond_label() = hostType().constantPool().newLabel();
  syn lazy int DoStmt.end_label() = hostType().constantPool().newLabel();

  public void DoStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    gen.addLabel(begin_label());
    getStmt().createBCode(gen);
    gen.addLabel(cond_label());
    getCondition().branchTrue(gen, begin_label());
    gen.addLabel(end_label());
  }

  syn lazy int ForStmt.cond_label() = hostType().constantPool().newLabel();
  syn lazy int ForStmt.begin_label() = hostType().constantPool().newLabel();
  syn lazy int ForStmt.update_label() = hostType().constantPool().newLabel();
  syn lazy int ForStmt.end_label() = hostType().constantPool().newLabel();

  public void ForStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    for (Stmt stmt : getInitStmtList()) {
      stmt.createBCode(gen);
    }
    gen.addLabel(cond_label());
    if (hasCondition() && !getCondition().isConstant()) {
      getCondition().branchFalse(gen, end_label());
    }
    if (!hasCondition() || getCondition().canBeTrue()) {
      gen.addLabel(begin_label());
      getStmt().createBCode(gen);
      gen.addLabel(update_label());
      for (Stmt stmt : getUpdateStmtList()) {
        stmt.createBCode(gen);
      }
      gen.GOTO(cond_label());
    }
    gen.addLabel(end_label());
    gen.addVariableScopeLabel(variableScopeEndLabel(gen));
  }

  syn int Stmt.break_label() {
    throw new UnsupportedOperationException("Can not break at this statement of type "
        + getClass().getName());
  }
  eq ForStmt.break_label() = end_label();
  eq WhileStmt.break_label() = end_label();
  eq DoStmt.break_label() = end_label();
  eq LabeledStmt.break_label() = end_label();
  eq SwitchStmt.break_label() = end_label();
  eq TryStmt.break_label() =  label_end();
  syn lazy int SynchronizedStmt.start_label() = hostType().constantPool().newLabel();

  public void BreakStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    if (hasFinally()) {
      int nextRange = gen.constantPool().newLabel();
      getFinally().createBCode(gen);
      gen.GOTO(targetStmt().break_label());
      gen.addLabel(nextRange);
      gen.monitorRangesStart(this, nextRange);
    } else {
      gen.GOTO(targetStmt().break_label());
    }
  }

  syn int Stmt.continue_label() {
    throw new UnsupportedOperationException("Can not continue at this statement");
  }
  eq ForStmt.continue_label() = update_label();
  eq WhileStmt.continue_label() = cond_label();
  eq DoStmt.continue_label() = cond_label();
  eq LabeledStmt.continue_label() = getStmt().continue_label();

  // TODO(joqvist): test continue in try-statement!
  eq TryStmt.continue_label() = label_end();

  public void ContinueStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    if (hasFinally()) {
      int nextRange = gen.constantPool().newLabel();
      getFinally().createBCode(gen);
      gen.GOTO(targetStmt().continue_label());
      gen.addLabel(nextRange);
      gen.monitorRangesStart(this, nextRange);
    } else {
      gen.GOTO(targetStmt().continue_label());
    }
  }

  public void ReturnStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    if (hasResult()) {
      TypeDecl type = null;
      BodyDecl b = enclosingBodyDecl();
      if (b instanceof MethodDecl) {
        type = ((MethodDecl) b).type();
      } else {
        throw new Error("Can not create code that returns value within non method");
      }
      getResult().createBCode(gen);
      getResult().emitCastTo(gen, type);
      if (hasFinally()) {
        int nextRange = gen.constantPool().newLabel();
        type.emitStoreLocal(gen, resultSaveLocalNum());
        getFinally().createBCode(gen);
        type.emitLoadLocal(gen, resultSaveLocalNum());
        type.emitReturn(gen);
        gen.addLabel(nextRange);
        gen.monitorRangesStart(this, nextRange);
      } else {
        type.emitReturn(gen);
      }
    } else {
      if (hasFinally()) {
        int nextRange = gen.constantPool().newLabel();
        getFinally().createBCode(gen);
        gen.RETURN();
        gen.addLabel(nextRange);
        gen.monitorRangesStart(this, nextRange);
      } else {
        gen.RETURN();
      }
    }
  }

  public void ThrowStmt.createBCode(CodeGeneration gen) {
    super.createBCode(gen);
    getExpr().createBCode(gen);
    gen.ATHROW();
  }

  syn lazy int TryStmt.fallthrough_label() =
      hasNonEmptyFinally() ? hostType().constantPool().newLabel() : label_end();

  public void TryStmt.createBCode(CodeGeneration gen) {
    int block_top_lbl = gen.constantPool().newLabel();
    int block_end_lbl = gen.constantPool().newLabel();
    int fallthrough_lbl = fallthrough_label();
    int handler_lbl = gen.constantPool().newLabel();
    boolean needsHandler = false;

    super.createBCode(gen);
    gen.addLabel(block_top_lbl);
    getBlock().createBCode(gen);
    gen.addLabel(block_end_lbl);

    if (getBlock().canCompleteNormally()) {
      gen.GOTO(fallthrough_lbl);
    }

    for (int i = 0; i < getNumCatchClause(); i++) {
      CatchClause cc = getCatchClause(i);
      cc.createBCode(gen);
      cc.exceptionTableEntries(gen, block_top_lbl, block_end_lbl);
      if (cc.getBlock().canCompleteNormally()) {
        gen.GOTO(fallthrough_lbl);
      }
      if (hasNonEmptyFinally()) {
        int cc_end_lbl = gen.constantPool().newLabel();
        gen.addLabel(cc_end_lbl);
        needsHandler = true;
        gen.addCatchAll(cc.label(), cc_end_lbl, handler_lbl);
      }
    }

    if (hasNonEmptyFinally()) {

      emitExceptionHandler(gen, block_top_lbl, block_end_lbl, handler_lbl, needsHandler);

      // Fallthrough finally.
      gen.addLabel(fallthrough_lbl);
      getFinally().createBCode(gen);
    }

    gen.addLabel(label_end());
  }

  /**
   * Outer finally host with a finally block that can complete normally.
   */
  syn FinallyHost TryStmt.outerFinallyHost() {
    // Find outer finally block.
    FinallyHost outer = this;
    Iterator<FinallyHost> iter = finallyIterator();
    while (iter.hasNext()) {
      outer = iter.next();
    }
    return outer;
  }

  /**
   * Generate catch-all (finally).
   */
  public void TryStmt.emitExceptionHandler(CodeGeneration gen, int start_lbl, int end_lbl,
      int handler_lbl, boolean needsHandler) {
    int top_pc = gen.addressOf(start_lbl);
    int end_pc = gen.addressOf(end_lbl);
    if (needsHandler || top_pc != end_pc) {
      // Catch-all exception handler (finally).
      gen.addLabel(handler_lbl);
      int num = getBlock().localNum();
      gen.ASTORE(num, VerificationTypes.THROWABLE);
      getExceptionHandler().createBCode(gen);
      gen.ALOAD(num, VerificationTypes.THROWABLE);
      gen.ATHROW();
      gen.addCatchAll(start_lbl, end_lbl, handler_lbl);
    }
  }

  public void SynchronizedStmt.emitMonitorEnter(CodeGeneration gen) {
    gen.DUP();
    int num = localNum();
    gen.ASTORE(num, VerificationTypes.OBJECT);
    gen.MONITORENTER();
  }

  syn lazy int CatchClause.label() = hostType().constantPool().newLabel();
  public void BasicCatch.createBCode(CodeGeneration gen) {
    gen.addLabel(label());
    getParameter().type().emitStoreLocal(gen, getParameter().localNum());
    getBlock().createBCode(gen);
  }

  protected int SynchronizedStmt.monitorId = -1;

  public void SynchronizedStmt.createBCode(CodeGeneration gen) {
    int lbl_start = gen.constantPool().newLabel();
    super.createBCode(gen);
    getExpr().createBCode(gen);

    monitorId = gen.monitorEnter(this);
    gen.addLabel(lbl_start);
    gen.monitorRangeStart(monitorId, lbl_start);

    getBlock().createBCode(gen);

    if (getBlock().canCompleteNormally()) {
      getMonitorExit().createBCode(gen);
      gen.GOTO(label_end());
    }

    gen.monitorExit();

    gen.addLabel(label_end());
  }

  /**
   * Checks if the branch statement leaves the monitor.
   * @return <code>true</code> if the branch leaves the monitor
   */
  inh boolean Stmt.leavesMonitor(Stmt branch, SynchronizedStmt monitor);

  eq BodyDecl.getChild().leavesMonitor(Stmt branch, SynchronizedStmt monitor) {
    throw new Error("Enclosing monitor not found!");
  }

  eq SynchronizedStmt.getChild().leavesMonitor(Stmt branch, SynchronizedStmt monitor) {
    if (monitor == this) {
      return true;
    } else {
      return leavesMonitor(branch, monitor);
    }
  }

  eq BranchTargetStmt.getChild().leavesMonitor(Stmt branch, SynchronizedStmt monitor) {
    if (potentialTargetOf(branch)) {
      return false;
    } else {
      return leavesMonitor(branch, monitor);
    }
  }

  /**
   * Assert statement bytecode is generated through the transformed
   * version of the assert statement.
   */
  public void AssertStmt.createBCode(CodeGeneration gen) {
    transformed().createBCode(gen);
  }

  public void LocalClassDeclStmt.createBCode(CodeGeneration gen) {
  }

  public void ClassAccess.createBCode(CodeGeneration gen) {
    if (prevExpr().type().isPrimitiveType() || prevExpr().type().isVoid()) {
      TypeDecl typeDecl = lookupType("java.lang", prevExpr().type().primitiveClassName());
      SimpleSet<Variable> fields = typeDecl.memberFields("TYPE");
      Variable f = fields.iterator().next();
      f.emitLoadField(gen, typeDecl);
    } else {
      gen.LDC(prevExpr().type());
    }
  }

  /**
   * Generate bytecode for the monitor exit call.
   */
  public void MonitorExit.createBCode(CodeGeneration gen) {
    gen.monitorRangeEnd(monitor.monitorId, hostType().constantPool().newLabel());
  }

  /**
   * Generate exception handler for monitor closing.
   * @param gen
   */
  public void MonitorExit.emitMonitorExitHandler(CodeGeneration gen) {
    int handler_lbl = handler_label();
    int end_lbl = handler_end_label();

    int num = localNum() + 1;

    // Handler start.
    gen.addLabel(handler_lbl);

    gen.ASTORE(num, VerificationTypes.THROWABLE);

    gen.ALOAD(monitor.localNum(), VerificationTypes.OBJECT);
    gen.MONITOREXIT();

    // Handler end.
    gen.addLabel(end_lbl);

    gen.ALOAD(num, VerificationTypes.THROWABLE);
    gen.ATHROW();

    // Add exception handler for the monitor closing.
    // See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4414101.
    gen.addCatchAll(handler_lbl, end_lbl, handler_lbl);
  }
}
