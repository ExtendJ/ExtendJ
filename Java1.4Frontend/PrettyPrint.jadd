aspect PrettyPrint {
  // Helper for indentation
  
  protected static int ASTNode.indent = 0;
  
  public static String ASTNode.indent() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < indent; i++) {
      s.append("  ");
    }
    return s.toString();
  }

  // Default output
  
  public String ASTNode.toString() {
    StringBuffer s = new StringBuffer();
    toString(s);
    return s.toString().trim();
  }
  
  public void ASTNode.toString(StringBuffer s) {
  }

  public void Program.toString(StringBuffer s) {
    for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
      CompilationUnit cu = (CompilationUnit)iter.next();
      if(cu.fromSource()) { 
        cu.toString(s);
      }
    }
  }
        
  public void CompilationUnit.toString(StringBuffer s) {
    try {
      if(getNumPackageDecl() > 0) {
        s.append("package ");
        getPackageDecl(0).toString(s);
        for(int i = 1; i < getNumPackageDecl(); i++) {
          s.append(".");
          getPackageDecl(i).toString(s);
        }
        s.append(";\n");
      }
      for(int i = 0; i < getNumImportDecl(); i++) {
        getImportDecl(i).toString(s);
        s.append("\n");
      }
      for(int i = 0; i < getNumTypeDecl(); i++) {
        getTypeDecl(i).toString(s);
        s.append("\n");
      }
    } catch (NullPointerException e) {
      System.out.print("Error in compilation unit hosting " + getTypeDecl(0).typeName());
      throw e;
    }
  }

  public void SingleTypeImportDecl.toString(StringBuffer s) {
    s.append("import ");
    getAccess().toString(s);
    s.append(";\n");
  }

  public void TypeImportOnDemandDecl.toString(StringBuffer s) {
    s.append("import ");
    getAccess().toString(s);
    s.append(".*;\n");
  }


    
  public void ClassDecl.toString(StringBuffer s) {
    getModifiers().toString(s);
    s.append("class " + name());
    if(hasSuperClassAccess()) {
      s.append(" extends ");
      s.append(getSuperClassAccess().type().name());
    }
    if(getNumImplements() > 0) {
      s.append(" implements ");
      getImplements(0).toString(s);
      for(int i = 1; i < getNumImplements(); i++) {
        s.append(", ");
        getImplements(i).toString(s);
      }
    }
    s.append(" {\n");
    indent++;
    for(int i=0; i < getNumBodyDecl(); i++) {
      getBodyDecl(i).toString(s);
    }

    indent--;
    s.append(indent() + "}\n");
  }
  
  public void InterfaceDecl.toString(StringBuffer s) {
    getModifiers().toString(s);
    s.append(" interface " + name());
    if(getNumSuperInterfaceId() > 0) {
      s.append(" extends ");
      getSuperInterfaceId(0).toString(s);
      for(int i = 1; i < getNumSuperInterfaceId(); i++) {
        s.append(", ");
        getSuperInterfaceId(i).toString(s);
      }
    }
    s.append(" {\n");
    indent++;
    for(int i=0; i < getNumBodyDecl(); i++) {
      getBodyDecl(i).toString(s);
    }
    
    indent--;
    s.append(indent() + "}\n");
  }

  // Type body decl

  public void InstanceInitializer.toString(StringBuffer s) {
    s.append(indent());
    getBlock().toString(s);
  }

  public void StaticInitializer.toString(StringBuffer s) {
    s.append(indent());
    s.append("static ");
    getBlock().toString(s);
  }
  
  public void ConstructorDecl.toString(StringBuffer s) {
    s.append(indent());
    getModifiers().toString(s);
    s.append(name() + "(");
    if(getNumParameter() > 0) {
      getParameter(0).toString(s);
      for(int i = 1; i < getNumParameter(); i++) {
        s.append(", ");
        getParameter(i).toString(s);
      }
    }
    s.append(")");
    if(getNumException() > 0) {
      s.append(" throws ");
      getException(0).toString(s);
      for(int i = 1; i < getNumException(); i++) {
        s.append(", ");
        getException(i).toString(s);
      }
    }
    
    s.append("{\n");
    indent++;
    if(hasConstructorInvocation()) {
      s.append(indent());
      getConstructorInvocation().toString(s);
    }
    for(int i = 0; i < getBlock().getNumStmt(); i++) {
      s.append(indent());
      getBlock().getStmt(i).toString(s);
    }
    indent--;
    s.append(indent());
    s.append("}\n");
  }

  // Type members 

  public void FieldDecl.toString(StringBuffer s) {
    s.append(indent());
    getModifiers().toString(s);
    getTypeAccess().toString(s);
    s.append(" ");
    getVariableDecl(0).toString(s);
    for(int i = 1; i < getNumVariableDecl(); i++) {
      s.append(", ");
      getVariableDecl(i).toString(s);
    }
    s.append(";/* error */\n");
  }
  
  public void FieldDeclaration.toString(StringBuffer s) {
    s.append(indent());
    getModifiers().toString(s);
    getTypeAccess().toString(s);
    s.append(" " + name());
    if(hasInit()) {
      s.append(" = ");
      getInit().toString(s);
    }
    s.append(";\n");
  }

  public void MethodDecl.toString(StringBuffer s) {
    s.append(indent());
    getModifiers().toString(s);
    getTypeAccess().toString(s);
    s.append(" " + name() + "(");
    if(getNumParameter() > 0) {
      getParameter(0).toString(s);
      for(int i = 1; i < getNumParameter(); i++) {
        s.append(", ");
        getParameter(i).toString(s);
      }
    }
    s.append(")");
    for(int i = 0; i < getNumEmptyBracket(); i++) {
      s.append("[]");
    }
    if(getNumException() > 0) {
      s.append(" throws ");
      getException(0).toString(s);
      for(int i = 1; i < getNumException(); i++) {
        s.append(", ");
        getException(i).toString(s);
      }
    }
    if(hasBlock()) {
      s.append(" ");
      getBlock().toString(s);
    }
    else {
      s.append(";\n");
    }
  }

  public void MemberClassDecl.toString(StringBuffer s) {
    s.append(indent());
    getClassDecl().toString(s);
  }

  public void MemberInterfaceDecl.toString(StringBuffer s) {
    s.append(indent());
    getInterfaceDecl().toString(s);
  }

  //
  
  public void VariableDecl.toString(StringBuffer s) {
    s.append(name());
    for(int i = 0; i < getNumEmptyBracket(); i++) {
      s.append("[]");
    }
    if(hasInit()) {
      s.append(" = ");
      getInit().toString(s);
    }
  }

  public void ArrayInit.toString(StringBuffer s) {
    s.append("{ ");
    if(getNumInit() > 0) {
      getInit(0).toString(s);
      for(int i = 1; i < getNumInit(); i++) {
        s.append(", ");
        getInit(i).toString(s);
      }
    }
    s.append(" } ");
  }

  public void ParameterDeclaration.toString(StringBuffer s) {
    getModifiers().toString(s);
    getTypeAccess().toString(s);
    s.append(" " + name());
    for(int i = 0; i < getNumEmptyBracket(); i++) {
      s.append("[]");
    }
  }

  public void IdDecl.toString(StringBuffer s) {
    s.append(getID());
  }

  public void IdUse.toString(StringBuffer s) {
    s.append(getID());
  }

  // Assign Expression

  public void AssignExpr.toString(StringBuffer s) {
    getDest().toString(s);
    printOp(s);
    getSource().toString(s);
  }

  public void AssignExpr.printOp(StringBuffer s) {
    s.append(" = ");
  }

  public void AssignSimpleExpr.printOp(StringBuffer s) {
    s.append(" = ");
  }

  public void AssignMulExpr.printOp(StringBuffer s) {
    s.append(" *= ");
  }

  public void AssignDivExpr.printOp(StringBuffer s) {
    s.append(" /= ");
  }

  public void AssignModExpr.printOp(StringBuffer s) {
    s.append(" %= ");
  }

  public void AssignPlusExpr.printOp(StringBuffer s) {
    s.append(" += ");
  }

  public void AssignMinusExpr.printOp(StringBuffer s) {
    s.append(" -= ");
  }

  public void AssignLShiftExpr.printOp(StringBuffer s) {
    s.append(" <<= ");
  }

  public void AssignRShiftExpr.printOp(StringBuffer s) {
    s.append(" >>= ");
  }

  public void AssignURShiftExpr.printOp(StringBuffer s) {
    s.append(" >>>= ");
  }

  public void AssignAndExpr.printOp(StringBuffer s) {
    s.append(" &= ");
  }

  public void AssignXorExpr.printOp(StringBuffer s) {
    s.append(" ^= ");
  }

  public void AssignOrExpr.printOp(StringBuffer s) {
    s.append(" |= ");
  }

  // Literals
    
  public void Literal.toString(StringBuffer s) {
    s.append(getLITERAL());
  }
  
  public void StringLiteral.toString(StringBuffer s) {
    s.append("\"" + escape(getLITERAL()) + "\"");
  }
  
  public void CharacterLiteral.toString(StringBuffer s) {
    s.append("'" + escape(getLITERAL()) + "'");
  }

  protected static String Literal.escape(String s) {
    StringBuffer result = new StringBuffer();
    for (int i=0; i < s.length(); i++) {
      switch(s.charAt(i)) {
        case '\b' : result.append("\\b"); break;
        case '\t' : result.append("\\t"); break;
        case '\n' : result.append("\\n"); break;
        case '\f' : result.append("\\f"); break;
        case '\r' : result.append("\\r"); break;
        case '\"' : result.append("\\\""); break;
        case '\'' : result.append("\\\'"); break;
        case '\\' : result.append("\\\\"); break;
        case 'å'  : result.append("å"); break;
        case 'ä'  : result.append("ä"); break;
        case 'ö'  : result.append("ö"); break;
        case 'Å'  : result.append("Å"); break;
        case 'Ä'  : result.append("Ä"); break;
        case 'Ö'  : result.append("Ö"); break;
        default:
          int value = (int)s.charAt(i);
          if(value < 0x20 || (value > 0x7e))
            result.append(asEscape(value));
          else
            result.append(s.charAt(i));
      }
    }
    return result.toString();
  }
  protected static String Literal.asEscape(int value) {
    StringBuffer s = new StringBuffer("\\u");
    String hex = Integer.toHexString(value);
    for(int i = 0; i < 4-hex.length(); i++)
      s.append("0");
    s.append(hex);
    return s.toString();
  }

  public void ParExpr.toString(StringBuffer s) {
    s.append("(");
    getExpr().toString(s);
    s.append(")");
  }


  public void ClassInstanceExpr.toString(StringBuffer s) {
    s.append("new ");
    getAccess().toString(s);
    s.append("(");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append(", ");
        getArg(i).toString(s);
      }
    }
    s.append(")");

    if(hasTypeDecl()) {
      TypeDecl decl = getTypeDecl();
      decl.toString(s);
      /*
      s.append(" {\n");
      indent++;
      for(int i=0; i < decl.getNumBodyDecl(); i++) {
        decl.getBodyDecl(i).toString(s);
      }
      indent--;
      s.append(indent());
      s.append("}\n");
      */
    }
  }

  public void ArrayCreationExpr.toString(StringBuffer s) {
    s.append("new ");
    getTypeAccess().toString(s);

    for(int i = 0; i < getNumDims(); i++) {
      getDims(i).toString(s);
    }
    
    if(hasArrayInit()) {
      getArrayInit().toString(s);
    }
  }

  public void Dims.toString(StringBuffer s) {
    s.append("[");
    if(hasExpr())
      getExpr().toString(s);
    s.append("]");
  }

  // Pre and post operations for unary expression
  
  public void Unary.toString(StringBuffer s) {
    printPreOp(s);
    getOperand().toString(s);
    printPostOp(s);
  }

  public void Unary.printPreOp(StringBuffer s) {
  }

  public void Unary.printPostOp(StringBuffer s) {
  }

  public void PostIncExpr.printPostOp(StringBuffer s) {
    s.append("++");
  }

  public void PostDecExpr.printPostOp(StringBuffer s) {
    s.append("--");
  }

  public void PreIncExpr.printPreOp(StringBuffer s) {
    s.append("++");
  }

  public void PreDecExpr.printPreOp(StringBuffer s) {
    s.append("--");
  }

  public void MinusExpr.printPreOp(StringBuffer s) {
    s.append("-");
  }

  public void PlusExpr.printPreOp(StringBuffer s) {
    s.append("+");
  }

  public void BitNotExpr.printPreOp(StringBuffer s) {
    s.append("~");
  }

  public void LogNotExpr.printPreOp(StringBuffer s) {
    s.append("!");
  }

  public void CastExpr.toString(StringBuffer s) {
    s.append("(");
    getTypeAccess().toString(s);
    s.append(")");
    getExpr().toString(s);
  }

  // Binary Expr

  public void Binary.toString(StringBuffer s) {
    getLeftOperand().toString(s);
    printOp(s);
    getRightOperand().toString(s);
  }

  public abstract void Binary.printOp(StringBuffer s);

  public void MulExpr.printOp(StringBuffer s) {
    s.append(" * ");
  }

  public void DivExpr.printOp(StringBuffer s) {
    s.append(" / ");
  }

  public void ModExpr.printOp(StringBuffer s) {
    s.append(" % ");
  }

  public void AddExpr.printOp(StringBuffer s) {
    s.append(" + ");
  }

  public void SubExpr.printOp(StringBuffer s) {
    s.append(" - ");
  }

  public void LShiftExpr.printOp(StringBuffer s) {
    s.append(" << ");
  }

  public void RShiftExpr.printOp(StringBuffer s) {
    s.append(" >> ");
  }

  public void URShiftExpr.printOp(StringBuffer s) {
    s.append(" >>> ");
  }

  public void AndBitwiseExpr.printOp(StringBuffer s) {
    s.append(" & ");
  }

  public void OrBitwiseExpr.printOp(StringBuffer s) {
    s.append(" | ");
  }

  public void XorBitwiseExpr.printOp(StringBuffer s) {
    s.append(" ^ ");
  }

  public void LTExpr.printOp(StringBuffer s) {
    s.append(" < ");
  }

  public void GTExpr.printOp(StringBuffer s) {
    s.append(" > ");
  }

  public void LEExpr.printOp(StringBuffer s) {
    s.append(" <= ");
  }

  public void GEExpr.printOp(StringBuffer s) {
    s.append(" >= ");
  }

  public void InstanceOfExpr.printOp(StringBuffer s) {
    s.append(" instanceof ");
  }
  
  public void InstanceOfExpr.toString(StringBuffer s) {
    getExpr().toString(s);
    printOp(s);
    getTypeAccess().toString(s);
  }

  public void EQExpr.printOp(StringBuffer s) {
    s.append(" == ");
  }

  public void NEExpr.printOp(StringBuffer s) {
    s.append(" != ");
  }

  public void AndLogicalExpr.printOp(StringBuffer s) {
    s.append(" && ");
  }

  public void OrLogicalExpr.printOp(StringBuffer s) {
    s.append(" || ");
  }

  public void ConditionalExpr.toString(StringBuffer s) {
    getCondition().toString(s);
    s.append(" ? ");
    getTrueExpr().toString(s);
    s.append(" : ");
    getFalseExpr().toString(s);
  }

  public void Modifiers.toString(StringBuffer s) {
    for(int i = 0; i < getNumModifier(); i++) {
      getModifier(i).toString(s);
      s.append(" ");
    }
  }
     
  public void Modifier.toString(StringBuffer s) {
    s.append(getID());
  }

  public void AbstractDot.toString(StringBuffer s) {
    getLeft().toString(s);
    if(!getRight().isArrayAccess())
      s.append(".");
    getRight().toString(s);
  }
  
  public void TypeAccess.toString(StringBuffer s) {
    if(!isUnknown())
      s.append(isQualified() ? decl().name() : decl().typeName());
    else
      s.append(name());
  }

  public void PackageAccess.toString(StringBuffer s) {
    s.append(getPackage(0).getID());
    for(int i = 1; i < getNumPackage(); i++)
      s.append("." + getPackage(i).getID());
  }
  
  public void ArrayTypeAccess.toString(StringBuffer s) {
    super.toString(s);
  }

  public void ThisAccess.toString(StringBuffer s) {
    s.append("this");
  }
  
  public void SuperAccess.toString(StringBuffer s) {
    s.append("super");
  }

  public void ArrayAccess.toString(StringBuffer s) {
    s.append("[");
    getExpr().toString(s);
    s.append("]");
  }

  public void VarAccess.toString(StringBuffer s) {
    s.append(name());
  }

  public void MethodAccess.toString(StringBuffer s) {
    s.append(name());
    s.append("(");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append(", ");
        getArg(i).toString(s);
      }
    }
    s.append(")");
  }

  public void ConstructorAccess.toString(StringBuffer s) {
    s.append(name());
    s.append("(");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append(", ");
        getArg(i).toString(s);
      }
    }
    s.append(")");
  }

  public void ClassAccess.toString(StringBuffer s) {
    s.append("class");
  }


  // Stmts

  public void Block.toString(StringBuffer s) {
    s.append("{\n");
    indent++;
    for(int i = 0; i < getNumStmt(); i++) {
      s.append(indent());
      getStmt(i).toString(s);
    }
    indent--;
    s.append(indent());
    s.append("}\n");
  }

  public void EmptyStmt.toString(StringBuffer s) {
    s.append(";\n");
  }

  public void LabeledStmt.toString(StringBuffer s) {
    getLabel().toString(s);
    s.append(":\n");
    s.append(indent());
    getStmt().toString(s);
  }

  public void ExprStmt.toString(StringBuffer s) {
    getExpr().toString(s);
    s.append(";\n");
  }

  public void SwitchStmt.toString(StringBuffer s) {
    s.append("switch (");
    getExpr().toString(s);
    s.append(")");

    s.append(" {\n");
    indent++;
    for(int i = 0; i < getNumCase(); i++) {
      getCase(i).toString(s);
    }
    indent--;
    s.append(indent());
    s.append("}\n");
  }

  public void ConstCase.toString(StringBuffer s) {
    s.append(indent());
    s.append("case ");
    getValue().toString(s);
    s.append(":\n");
    indent++;
    for(int i = 0; i < getNumStmt(); i++) {
      s.append(indent());
      getStmt(i).toString(s);
    }
    indent--;
  }

  public void DefaultCase.toString(StringBuffer s) {
    s.append(indent());
    s.append("default:\n");
    indent++;
    for(int i = 0; i < getNumStmt(); i++) {
      s.append(indent());
      getStmt(i).toString(s);
    }
    indent--;
  }

  public void IfStmt.toString(StringBuffer s) {
    s.append("if(");
    getCondition().toString(s);
    s.append(") ");
    getThen().toString(s);
    if(hasElse()) {
      s.append(indent());
      s.append("else ");
      getElse().toString(s);
    }
  }

  public void WhileStmt.toString(StringBuffer s) {
    s.append("while(");
    getCondition().toString(s);
    s.append(") ");
    getStmt().toString(s);
  }

  public void DoStmt.toString(StringBuffer s) {
    s.append("do ");
    getStmt().toString(s);
    s.append("while(");
    getCondition().toString(s);
    s.append(");\n");
  }

  public void ForStmt.toString(StringBuffer s) {
    s.append("for(");
    
    if(getNumInitStmt() > 0) {
      if(getInitStmt(0) instanceof VariableDeclaration) {
        VariableDeclaration var = (VariableDeclaration)getInitStmt(0);
        var.getModifiers().toString(s);
        var.getTypeAccess().toString(s);
        s.append(" " + var.name());
        for(int i = 1; i < getNumInitStmt(); i++) {
          s.append(", ");
          s.append(((VariableDeclaration)getInitStmt(i)).name());
        }
      }
      else {
        if(!(getInitStmt(0) instanceof ExprStmt)) {
          System.err.println("Found unexpected type: " + getInitStmt(0).getClass().getName());
        }
        ExprStmt stmt = (ExprStmt)getInitStmt(0);
        stmt.getExpr().toString(s);
        for(int i = 1; i < getNumInitStmt(); i++) {
          s.append(", ");
          stmt = (ExprStmt)getInitStmt(i);
          stmt.getExpr().toString(s);
        }
      }
    }
    
    s.append("; ");
    if(hasCondition()) {
      getCondition().toString(s);
    }
    s.append("; ");

    if(getNumUpdateStmt() > 0) {
      ExprStmt stmt = (ExprStmt)getUpdateStmt(0);
      stmt.getExpr().toString(s);
      for(int i = 1; i < getNumUpdateStmt(); i++) {
        s.append(", ");
        stmt = (ExprStmt)getUpdateStmt(i);
        stmt.getExpr().toString(s);
      }
    }
    
    s.append(") ");
    getStmt().toString(s);
  }

  public void BreakStmt.toString(StringBuffer s) {
    s.append("break ");
    if(hasLabel())
      getLabel().toString(s);
    s.append(";\n");
  }

  public void ContinueStmt.toString(StringBuffer s) {
    s.append("continue ");
    if(hasLabel())
      getLabel().toString(s);
    s.append(";\n");
  }

  public void ReturnStmt.toString(StringBuffer s) {
    s.append("return ");
    if(hasResult()) {
      getResult().toString(s);
    }
    s.append(";\n");
  }

  public void ThrowStmt.toString(StringBuffer s) {
    s.append("throw ");
    getExpr().toString(s);
    s.append(";\n");
  }

  public void SynchronizedStmt.toString(StringBuffer s) {
    s.append("synchronized(");
    getExpr().toString(s);
    s.append(") ");
    getBlock().toString(s);
  }

  public void TryStmt.toString(StringBuffer s) {
    s.append("try ");
    getBlock().toString(s);
    for(int i = 0; i < getNumCatchClause(); i++) {
      s.append(indent());
      getCatchClause(i).toString(s);
    }
    if(hasFinally()) {
      s.append(indent());
      s.append("finally ");
      getFinally().toString(s);
    }
  }

  public void CatchClause.toString(StringBuffer s) {
    s.append("catch (");
    getParameter().toString(s);
    s.append(") ");
    getBlock().toString(s);
  }

  public void VarDeclStmt.toString(StringBuffer s) {
    getModifiers().toString(s);
    getTypeAccess().toString(s);
    s.append(" ");
    getVariableDecl(0).toString(s);
    for(int i = 1; i < getNumVariableDecl(); i++) {
      s.append(", ");
      getVariableDecl(i).toString(s);
    }
    s.append(";\n");
  }

  public void VariableDeclaration.toString(StringBuffer s) {
    getModifiers().toString(s);
    getTypeAccess().toString(s);
    s.append(" " + name());
    if(hasInit()) {
      s.append(" = ");
      getInit().toString(s);
    }
    s.append(";\n");
  }
  
  
  public void LocalClassDeclStmt.toString(StringBuffer s) {
    getClassDecl().toString(s);
  }

  // dump the AST to standard output

  public void ASTNode.dumpTree(int j) {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < j; i++) {
      s.append("  ");
    }
    System.out.println(s.toString() + getClass().getName());
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).dumpTree(j + 1);
  }
  public void IdDecl.dumpTree(int j) {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < j; i++) {
      s.append("  ");
    }
    System.out.println(s.toString() + getClass().getName() + ": " + getID());
  }
  public void IdUse.dumpTree(int j) {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < j; i++) {
      s.append("  ");
    }
    System.out.println(s.toString() + getClass().getName() + ": " + getID());
  }
  public void Program.dumpTree() {
    for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
      CompilationUnit cu = (CompilationUnit)iter.next();
      if(cu.fromSource()) { 
        cu.dumpTree(0);
      }
    }
  }

}

