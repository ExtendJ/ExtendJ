/* Copyright (c) 2005-2008, Torbjorn Ekman
 *               2013-2017, Jesper Ã–qvist <jesper.oqvist@cs.lth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package org.extendj.ast;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.PrintStream;

/**
 * Helper class to generate bytecode instructions.
 *
 * <p>Stores the generated bytecodes in an internal byte array.
 * The generated bytecode is output by calling {@code write(DataOutputStream)}.
 */
@SuppressWarnings({"javadoc","unchecked","rawtypes"})
public class CodeGeneration {
  private static final boolean DEBUG =
      System.getProperty("extendj.bytecode.debug", "").equals("true");

  /**
   * An exception of this type is thrown during code generation if the code
   * generator tried to generate a jump that did not fit in a short jump offset
   * (2 bytes).  Code generation should then be retried with wide gotos (4 byte
   * offsets).
   */
  public static class JumpOffsetError extends Error {
    public JumpOffsetError() {
      super("Trying to generate a bytecode jump that does not fit in a 2 byte offset.");
    }
  }

  static class LocalVariableEntry {
    int start_pc;
    int length;
    int name_index;
    int descriptor_index;
    int index;
  }

  class ExceptionEntry {
    public static final int CATCH_ALL = 0;

    int start_pc;
    int end_pc;
    int handler_lbl;
    int catch_type;

    VerificationType type;
    BasicBlock handler;

    public ExceptionEntry(int start_pc, int end_pc, int handler_lbl, int catch_type,
        VerificationType type) {
      this.start_pc = start_pc;
      this.end_pc = end_pc;
      this.handler_lbl = handler_lbl;
      this.catch_type = catch_type;
      this.type = type;
    }

    public int handlerPC() {
      return addressOf(handler_lbl);
    }

    @Override public String toString() {
      return String.format("%d..%d => L%d", start_pc, end_pc, handler_lbl);
    }
  }

  static class LineNumberEntry {
    int start_pc;
    int line_number;
  }

  static class ExceptionRange {
    int start;
    int end;

    ExceptionRange(int start, int end) {
      this.start = start;
      this.end = end;
    }
  }

  static class Monitor {
    java.util.List<ExceptionRange> ranges = new ArrayList<ExceptionRange>();
    final SynchronizedStmt mon;
    int start_lbl = -1;

    Monitor(SynchronizedStmt mon) {
      this.mon = mon;
    }

    void rangeStart(int label) {
      start_lbl = label;
    }

    void rangeEnd(int label) {
      if (start_lbl != -1) {
        ranges.add(new ExceptionRange(start_lbl, label));
        start_lbl = -1;
      }
    }

    void monitorEnter(CodeGeneration gen) {
      gen.DUP();
      gen.ASTORE(mon.localNum(), VerificationTypes.OBJECT);
      gen.MONITORENTER();
    }

    void monitorExit(CodeGeneration gen) {
      MonitorExit monExit = mon.getMonitorExit();
      monExit.emitMonitorExitHandler(gen);
      if (start_lbl != -1
          && gen.addressOf(start_lbl) != gen.addressOf(monExit.handler_label())) {
        rangeEnd(monExit.handler_end_label());
      }
      for (ExceptionRange range: ranges) {
        gen.addException(range.start, range.end,
            monExit.handler_label(),
            CodeGeneration.ExceptionEntry.CATCH_ALL,
            VerificationTypes.THROWABLE);
      }
    }
  }


  public static class Jump {
    public int loc; // Offset position.
    public int offset; // Offset PC.
    public int target; // Target PC (or label, before back-patch).
    public boolean wide;
    public BasicBlock bb;
  }

  /** Bytecode buffer. */
  private final ByteArray bytes = new ByteArray();

  private final ConstantPool constantPool;

  private final ASTNode context;

  private final boolean wideGotos;

  private int variableScopeLabel = 1;

  private Map<Integer, Collection<LocalVariableEntry>> variableScopeLabelUses =
      new HashMap<Integer, Collection<LocalVariableEntry>>();

  public Collection<LocalVariableEntry> localVariableTable = new ArrayList<LocalVariableEntry>();

  public Collection<LineNumberEntry> lineNumberTable = new ArrayList<LineNumberEntry>();

  private int prevLine = -1;

  public Collection<ExceptionEntry> exceptions = new ArrayList<ExceptionEntry>();

  private Map<Integer, Integer> address = new HashMap<Integer, Integer>();

  private Map<Integer, Collection<Jump>> uses = new HashMap<Integer, Collection<Jump>>();

  private ArrayList<Jump> jumps = new ArrayList<Jump>();

  private java.util.List<Monitor> monitors = new ArrayList<Monitor>();

  /** Maps bytecode locations to basic blocks. */
  private ArrayList<BasicBlock> blocks = new ArrayList<BasicBlock>();

  private int nextBlock = 1;

  /** Maps labels to basic blocks. */
  private Map<Integer, BasicBlock> blockLabels = new HashMap<Integer, BasicBlock>();

  /** Entry block. */
  private final BasicBlock entry;

  private boolean afterAbrupt = false;

  /**
   * Current basic block.
   */
  private BasicBlock block;

  private boolean computedStackFrames = false;
  private int maxStack;
  private int maxLocals;
  private ArrayList<StackFrame> stackFrames = new ArrayList<StackFrame>();

  /**
   * Initializes code generation with narrow jumps. This will cause addLabel
   * and emitGoto to throw a JumpOffsetError if the required jump (or
   * back-patched jump) does not fit inside a 2-byte offset.
   */
  public CodeGeneration(ConstantPool constantPool, ASTNode context) {
    this(constantPool, context, false);
  }

  /**
   * If the wideGotos parameter is {@code true} then code generation is
   * initialized to use wide gotos where possible. This can prevent
   * JumpOffsetError from being thrown during code generation, but will
   * generate slightly larger bytecode.
   */
  public CodeGeneration(ConstantPool constantPool, ASTNode context, boolean wideGotos) {
    this.constantPool = constantPool;
    this.context = context;
    this.wideGotos = wideGotos;
    entry = new BasicBlock(-1, 0);
    entry.entryStack = new StackFrame();
    block = entry;
  }

  public ConstantPool constantPool() {
    return constantPool;
  }

  public int variableScopeLabel() {
    return variableScopeLabel++;
  }

  public void addVariableScopeLabel(int label) {
    Integer label_object = label;
    // Update all reference to this label.
    if (variableScopeLabelUses.containsKey(label_object)) {
      Collection<LocalVariableEntry> array = variableScopeLabelUses.get(label_object);
      for (LocalVariableEntry e : array) {
        e.length = pos() - e.start_pc;
      }
    }
  }

  public void addLocalVariableEntryAtCurrentPC(String name, TypeDecl type,
      int localNum, int variableScopeEndLabel) {
    LocalVariableEntry e = new LocalVariableEntry();
    e.start_pc = pos();
    e.length = 0;
    e.name_index = constantPool().addUtf8(name);
    e.descriptor_index = constantPool().addUtf8(type.typeDescriptor());
    e.index = localNum;
    localVariableTable.add(e);
    Integer label_object = variableScopeEndLabel;
    if (!variableScopeLabelUses.containsKey(label_object)) {
      variableScopeLabelUses.put(label_object, new ArrayList<LocalVariableEntry>());
    }
    variableScopeLabelUses.get(label_object).add(e);
  }

  public void addLineNumberEntryAtCurrentPC(ASTNode node) {
    int line = node.sourceLineNumber();
    if (line != -1 && line != 65535 && line != prevLine) {
      prevLine = line;
      LineNumberEntry e = new LineNumberEntry();
      e.start_pc = pos();
      e.line_number = line;
      lineNumberTable.add(e);
    }
  }

  /**
   * Adds an exception handler for the given exception type
   * for the given instruction range.
   *
   * @param startLbl start label for the exception range.
   * @param endLbl end label for the exception range.
   * @param handlerLbl label for the exception handler.
   * @param catchType the exception type to catch.
   */
  public void addExceptionHandler(int startLbl, int endLbl, int handlerLbl, TypeDecl catchType) {
    addException(startLbl, endLbl, handlerLbl,
        constantPool().addClass(catchType.constantPoolName()),
        catchType.verificationType());
  }

  /**
   * Adds an exception handler to catch any exception
   * for the given instruction range.
   *
   * @param startLbl start label for the exception range.
   * @param endLbl end label for the exception range.
   * @param handlerLbl label for the exception handler.
   */
  public void addCatchAll(int startLbl, int endLbl, int handlerLbl) {
    addException(startLbl, endLbl, handlerLbl, ExceptionEntry.CATCH_ALL,
        VerificationTypes.THROWABLE);
  }

  /**
   * Adds an exception handler for the given exception type.
   * If catch_type is zero then this handler catches any exception.
   */
  private void addException(int startLbl, int endLbl, int handlerLbl, int catchType,
      VerificationType type) {
    int startPc = addressOf(startLbl);
    int endPc = addressOf(endLbl);
    if (startPc != endPc) {
      exceptions.add(new ExceptionEntry(startPc, endPc, handlerLbl, catchType, type));
    }
  }

  public void addParameter(int localNum, TypeDecl type) {
    addParameter(localNum, type.verificationType());
  }

  public void addParameter(int localNum, VerificationType type) {
    entry.entryStack.allocate(localNum, type);
  }

  /**
   * Marks an uninitialized this reference at the given local variable index
   * as initialized by changing recorded type for the variable.
   *
   * @param index local variable index of the this reference to change.
   * @param type the initialized type of the this reference.
   */
  public void initializedThis(int index, TypeDecl type) {
    block.allocate(index, type.verificationType());
  }

  /**
   * Marks the top stack reference as initialized.
   *
   * @param type the initialized type of the reference.
   */
  public void initializedRef(TypeDecl type) {
    block.pop();
    block.push(type.verificationType());
  }

  /**
   * Add a label at the current PC.
   *
   * <p>This back-patches the label address to previous jumps that use this
   * label. May throw a JumpOffsetError if the offset to this label does not
   * fit in a any previous jump.
   *
   * @return the offset to the target label from current PC, or zero if the target
   * address is not yet known.
   */
  public void addLabel(int label) {
    Integer key = Integer.valueOf(label);
    address.put(key, pos());
    if (uses.containsKey(key)) {
      // Update all jumps to this label.
      for (Jump jump : uses.get(key)) {
        jump.target = pos();
        patch(jump);
      }
    }
    if (block.start != pos()) {
      // Create a new basic block here.
      afterAbrupt = false;
      closeBlock();
    }
    block.label = label;
    blockLabels.put(label, block);
  }

  private void patch(Jump jump) {
    if (jump.wide) {
      setAddress32(jump.loc, jump.target - jump.offset);
    } else {
      setAddress(jump.loc, jump.target - jump.offset);
    }
  }

  /**
   * Returns the address of the given label.
   */
  public int addressOf(int label) {
    Integer label_object = label;
    if (!address.containsKey(label_object)) {
      throw new Error("Can not compute address of unplaced label (id: " + label + ")");
    }
    return address.get(label_object);
  }

  /**
   * Calculate the jump offset to reach a label.
   *
   * @param location jump source PC (where the jump offset is written).
   * @param offset jump offset PC (the jump offset is calculated from this).
   * @param label jump target label.
   * @param wide if this jump uses a 4-byte offset instead of a 2-byte offset.
   * @return the offset from the source PC to the label, or 0 if the label has
   * not been placed yet.
   */
  private int jump(int location, int offset, int label, boolean wide) {
    Jump jump = new Jump();
    jump.bb = block;
    jump.loc = location;
    jump.offset = offset;
    jump.wide = wide;
    Integer key = Integer.valueOf(label);
    Integer val = address.get(key);
    if (val != null) {
      // Jump address is available now.
      jump.target = val;
      jumps.add(jump);
      int diff = val - offset;
      if (diff > Short.MAX_VALUE || diff < Short.MIN_VALUE) {
        // Jump offset is too large - restart with wide jumps.
        throw new JumpOffsetError();
      }
      return diff;
    } else {
      // Add this PC to list of jumps to be back-patched for the given label.
      jump.target = label;
      Collection<Jump> jumps = uses.get(key);
      if (jumps == null) {
        jumps = new ArrayList<Jump>();
        uses.put(key, jumps);
      }
      jumps.add(jump);
      this.jumps.add(jump);
      return 0;
    }
  }

  /**
   * Relative jump in switch table generation.
   * NB: offsetLbl must already be generated.
   */
  private int relativeJump(int offsetLbl, int target) {
    return jump(pos(), addressOf(offsetLbl), target, true);
  }

  private void setAddress(int position, int address) {
    if (address > Short.MAX_VALUE || address < Short.MIN_VALUE) {
      throw new JumpOffsetError();
    }
    bytes.set(position,     (byte) ((address & 0xff00)>>8));
    bytes.set(position + 1, (byte) (address & 0xff));
  }

  private void setAddress32(int position, int address) {
    bytes.set(position,     (byte) (address >> 24 & 0xff));
    bytes.set(position + 1, (byte) (address >> 16 & 0xff));
    bytes.set(position + 2, (byte) (address >> 8 & 0xff));
    bytes.set(position + 3, (byte) (address & 0xff));
  }

  public int maxStackDepth() {
    computeStackFrames();
    return maxStack;
  }

  public int maxLocals() {
    computeStackFrames();
    return maxLocals;
  }

  /**
   * Pus a new monitor to the monitor stack.
   * @param mon the monitor local number
   * @return the monitor id
   */
  public int monitorEnter(SynchronizedStmt mon) {
    Monitor monitor = new Monitor(mon);
    monitor.monitorEnter(this);
    monitors.add(monitor);
    return monitors.size() - 1;
  }

  /**
   * Exit the current top monitor.
   */
  public void monitorExit() {
    if (monitors.isEmpty()) {
      throw new Error("Monitor stack is empty!");
    }
    Monitor monitor = monitors.remove(monitors.size() - 1);
    monitor.monitorExit(this);
  }

  /**
   * Start a monitor exception range.
   * @param monitorId the monitor id
   */
  public void monitorRangeStart(int monitorId, int label) {
    monitors.get(monitorId).rangeStart(label);
  }

  public void monitorRangesStart(Stmt branch, int label) {
    for (Monitor monitor : monitors) {
      if (branch.leavesMonitor(branch, monitor.mon)) {
        monitor.rangeStart(label);
      }
    }
  }

  /**
   * End a monitor exception range.
   * @param monitorId the monitor id
   */
  public void monitorRangeEnd(int monitorId, int label) {
    Monitor monitor = monitors.get(monitorId);
    ALOAD(monitor.mon.localNum(), VerificationTypes.OBJECT);
    MONITOREXIT();
    addLabel(label);
    monitor.rangeEnd(label);
  }

  public void NOP() {
    instr(Bytecode.NOP);
  }

  public void NEW(TypeDecl type) {
    block.push(new VerificationTypes.Uninitialized(pos()));
    int constantIndex = constantPool().addClass(type.constantPoolName());
    instr(Bytecode.NEW);
    bytes.add2(constantIndex);
  }

  public void NEWARRAY(TypeDecl arrayType) {
    TypeDecl componentType = arrayType.componentType();
    instr(Bytecode.NEWARRAY);
    bytes.add(componentType.arrayPrimitiveTypeDescriptor());
    block.pop();
    block.push(arrayType.verificationType());
  }

  public void ANEWARRAY(TypeDecl arrayType) {
    TypeDecl componentType = arrayType.componentType();
    instr(Bytecode.ANEWARRAY);
    bytes.add2(constantPool().addClass(componentType.arrayTypeDescriptor()));
    block.pop();
    block.push(arrayType.verificationType());
  }

  /**
   * @param arrayType array type
   * @param dimensions array dimensions
   */
  public void MULTIANEWARRAY(TypeDecl arrayType, int dimensions) {
    instr(Bytecode.MULTIANEWARRAY);
    bytes.add2(constantPool().addClass(arrayType.arrayTypeDescriptor()));
    bytes.add(dimensions);
    block.pop(dimensions);
    block.push(arrayType.verificationType());
  }

  public void ISTORE(int pos) {
    switch (pos) {
      case 0:
        instr(Bytecode.ISTORE_0);
        break;
      case 1:
        instr(Bytecode.ISTORE_1);
        break;
      case 2:
        instr(Bytecode.ISTORE_2);
        break;
      case 3:
        instr(Bytecode.ISTORE_3);
        break;
      default:
        if (pos < 256) {
          instr(Bytecode.ISTORE);
          bytes.add(pos);
        } else {
          instr(Bytecode.WIDE);
          bytes.add(Bytecode.ISTORE);
          bytes.add2(pos);
        }
        break;
    }
    block.store(pos, VerificationTypes.INT);
  }

  public void LSTORE(int pos) {
    switch (pos) {
      case 0:
        instr(Bytecode.LSTORE_0);
        break;
      case 1:
        instr(Bytecode.LSTORE_1);
        break;
      case 2:
        instr(Bytecode.LSTORE_2);
        break;
      case 3:
        instr(Bytecode.LSTORE_3);
        break;
      default:
        if (pos < 256) {
          instr(Bytecode.LSTORE);
          bytes.add(pos);
        } else {
          instr(Bytecode.WIDE);
          bytes.add(Bytecode.LSTORE);
          bytes.add2(pos);
        }
        break;
    }
    block.store(pos, VerificationTypes.LONG);
  }

  public void FSTORE(int pos) {
    switch (pos) {
      case 0:
        instr(Bytecode.FSTORE_0);
        break;
      case 1:
        instr(Bytecode.FSTORE_1);
        break;
      case 2:
        instr(Bytecode.FSTORE_2);
        break;
      case 3:
        instr(Bytecode.FSTORE_3);
        break;
      default:
        if (pos < 256) {
          instr(Bytecode.FSTORE);
          bytes.add(pos);
        } else {
          instr(Bytecode.WIDE);
          bytes.add(Bytecode.FSTORE);
          bytes.add2(pos);
        }
        break;
    }
    block.store(pos, VerificationTypes.FLOAT);
  }

  public void DSTORE(int pos) {
    switch (pos) {
      case 0:
        instr(Bytecode.DSTORE_0);
        break;
      case 1:
        instr(Bytecode.DSTORE_1);
        break;
      case 2:
        instr(Bytecode.DSTORE_2);
        break;
      case 3:
        instr(Bytecode.DSTORE_3);
        break;
      default:
        if (pos < 256) {
          instr(Bytecode.DSTORE);
          bytes.add(pos);
        } else {
          instr(Bytecode.WIDE);
          bytes.add(Bytecode.DSTORE);
          bytes.add2(pos);
        }
        break;
    }
    block.store(pos, VerificationTypes.DOUBLE);
  }

  public void ASTORE(int pos, TypeDecl type) {
    ASTORE(pos, type.verificationType());
  }

  public void ASTORE(int pos, VerificationType type) {
    switch (pos) {
      case 0:
        instr(Bytecode.ASTORE_0);
        break;
      case 1:
        instr(Bytecode.ASTORE_1);
        break;
      case 2:
        instr(Bytecode.ASTORE_2);
        break;
      case 3:
        instr(Bytecode.ASTORE_3);
        break;
      default:
        if (pos < 256) {
          instr(Bytecode.ASTORE);
          bytes.add(pos);
        } else {
          instr(Bytecode.WIDE);
          bytes.add(Bytecode.ASTORE);
          bytes.add2(pos);
        }
        break;
    }
    block.store(pos, type);
  }

  /**
   * Load a local variable and push it on the operand stack.
   */
  public void ILOAD(int pos) {
    switch (pos) {
      case 0:
        instr(Bytecode.ILOAD_0);
        break;
      case 1:
        instr(Bytecode.ILOAD_1);
        break;
      case 2:
        instr(Bytecode.ILOAD_2);
        break;
      case 3:
        instr(Bytecode.ILOAD_3);
        break;
      default:
        if (pos < 256) {
          instr(Bytecode.ILOAD);
          bytes.add(pos);
        } else {
          instr(Bytecode.WIDE);
          bytes.add(Bytecode.ILOAD);
          bytes.add2(pos);
        }
        break;
    }
    block.push(VerificationTypes.INT);
  }

  /**
   * Load a local variable and push it on the operand stack.
   */
  public void LLOAD(int pos) {
    switch (pos) {
      case 0:
        instr(Bytecode.LLOAD_0);
        break;
      case 1:
        instr(Bytecode.LLOAD_1);
        break;
      case 2:
        instr(Bytecode.LLOAD_2);
        break;
      case 3:
        instr(Bytecode.LLOAD_3);
        break;
      default:
        if (pos < 256) {
          instr(Bytecode.LLOAD);
          bytes.add(pos);
        } else {
          instr(Bytecode.WIDE);
          bytes.add(Bytecode.LLOAD);
          bytes.add2(pos);
        }
        break;
    }
    block.push(VerificationTypes.LONG);
  }

  /**
   * Load a local variable and push it on the operand stack.
   */
  public void FLOAD(int pos) {
    switch (pos) {
      case 0:
        instr(Bytecode.FLOAD_0);
        break;
      case 1:
        instr(Bytecode.FLOAD_1);
        break;
      case 2:
        instr(Bytecode.FLOAD_2);
        break;
      case 3:
        instr(Bytecode.FLOAD_3);
        break;
      default:
        if (pos < 256) {
          instr(Bytecode.FLOAD);
          bytes.add(pos);
        } else {
          instr(Bytecode.WIDE);
          bytes.add(Bytecode.FLOAD);
          bytes.add2(pos);
        }
        break;
    }
    block.push(VerificationTypes.FLOAT);
  }

  /**
   * Load a local variable and push it on the operand stack.
   */
  public void DLOAD(int pos) {
    switch (pos) {
      case 0:
        instr(Bytecode.DLOAD_0);
        break;
      case 1:
        instr(Bytecode.DLOAD_1);
        break;
      case 2:
        instr(Bytecode.DLOAD_2);
        break;
      case 3:
        instr(Bytecode.DLOAD_3);
        break;
      default:
        if (pos < 256) {
          instr(Bytecode.DLOAD);
          bytes.add(pos);
        } else {
          instr(Bytecode.WIDE);
          bytes.add(Bytecode.DLOAD);
          bytes.add2(pos);
        }
        break;
    }
    block.push(VerificationTypes.DOUBLE);
  }

  /**
   * Load a local variable and push it on the operand stack.
   */
  public void ALOAD(int pos, TypeDecl type) {
    ALOAD(pos, type.verificationType());
  }

  public void ALOAD(int pos, VerificationType type) {
    switch (pos) {
      case 0:
        instr(Bytecode.ALOAD_0);
        break;
      case 1:
        instr(Bytecode.ALOAD_1);
        break;
      case 2:
        instr(Bytecode.ALOAD_2);
        break;
      case 3:
        instr(Bytecode.ALOAD_3);
        break;
      default:
        if (pos < 256) {
          instr(Bytecode.ALOAD);
          bytes.add(pos);
        } else {
          instr(Bytecode.WIDE);
          bytes.add(Bytecode.ALOAD);
          bytes.add2(pos);
        }
        break;
    }
    block.push(type);
  }

  /**
   * @param componentType the component type of the array
   */
  public void AALOAD(TypeDecl componentType) {
    instr(Bytecode.AALOAD);
    block.pop(2);
    block.push(componentType.verificationType());
  }

  public void IALOAD() {
    instr(Bytecode.IALOAD);
    block.pop(2);
    block.push(VerificationTypes.INT);
  }

  public void LALOAD() {
    instr(Bytecode.LALOAD);
    block.pop(2);
    block.push(VerificationTypes.LONG);
  }

  public void FALOAD() {
    instr(Bytecode.FALOAD);
    block.pop(2);
    block.push(VerificationTypes.FLOAT);
  }

  public void DALOAD() {
    instr(Bytecode.DALOAD);
    block.pop(2);
    block.push(VerificationTypes.DOUBLE);
  }

  public void BALOAD() {
    instr(Bytecode.BALOAD);
    block.pop(2);
    block.push(VerificationTypes.INT);
  }

  public void CALOAD() {
    instr(Bytecode.CALOAD);
    block.pop(2);
    block.push(VerificationTypes.INT);
  }

  public void SALOAD() {
    instr(Bytecode.SALOAD);
    block.pop(2);
    block.push(VerificationTypes.INT);
  }

  public void AASTORE() {
    instr(Bytecode.AASTORE);
    block.pop(3);
  }

  public void IASTORE() {
    instr(Bytecode.IASTORE);
    block.pop(3);
  }

  public void LASTORE() {
    instr(Bytecode.LASTORE);
    block.pop(3);
  }

  public void FASTORE() {
    instr(Bytecode.FASTORE);
    block.pop(3);
  }

  public void DASTORE() {
    instr(Bytecode.DASTORE);
    block.pop(3);
  }

  public void BASTORE() {
    instr(Bytecode.BASTORE);
    block.pop(3);
  }

  public void CASTORE() {
    instr(Bytecode.CASTORE);
    block.pop(3);
  }

  public void SASTORE() {
    instr(Bytecode.SASTORE);
    block.pop(3);
  }

  public void ARRAYLENGTH() {
    instr(Bytecode.ARRAYLENGTH);
    block.pop();
    block.push(VerificationTypes.INT);
  }

  public void GETSTATIC(int constantIndex, TypeDecl fieldType) {
    instr(Bytecode.GETSTATIC);
    bytes.add2(constantIndex);
    block.push(fieldType.verificationType());
  }

  public void GETFIELD(int constantIndex, TypeDecl fieldType) {
    instr(Bytecode.GETFIELD);
    bytes.add2(constantIndex);
    block.pop();
    block.push(fieldType.verificationType());
  }

  /**
   * Store operand in static field.
   */
  public void PUTSTATIC(int constantIndex) {
    instr(Bytecode.PUTSTATIC);
    bytes.add2(constantIndex);
    block.pop();
  }

  /**
   * Store operand in field.
   */
  public void PUTFIELD(int constantIndex) {
    instr(Bytecode.PUTFIELD);
    bytes.add2(constantIndex);
    block.pop(2);
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  public void INVOKEINTERFACE(int constantIndex, int numArg, int argSize, TypeDecl returnType) {
    INVOKEINTERFACE(constantIndex, numArg, argSize);
    if (!returnType.isVoid()) {
      block.push(returnType.verificationType());
    }
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  public void INVOKEINTERFACE_void(int constantIndex, int numArg, int argSize) {
    INVOKEINTERFACE(constantIndex, numArg, argSize);
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   * @param numArg the number of individual arguments.
   * @param argSize the total size of arguments (double and long have size 2).
   */
  private void INVOKEINTERFACE(int constantIndex, int numArg, int argSize) {
    instr(Bytecode.INVOKEINTERFACE);
    bytes.add2(constantIndex);
    bytes.add(argSize);
    bytes.add(0);
    block.pop(numArg);
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  public void INVOKESTATIC(int constantIndex, int numArg, TypeDecl returnType) {
    INVOKESTATIC(constantIndex, numArg);
    if (!returnType.isVoid()) {
      block.push(returnType.verificationType());
    }
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  public void INVOKESTATIC_void(int constantIndex, int numArg) {
    INVOKESTATIC(constantIndex, numArg);
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  private void INVOKESTATIC(int constantIndex, int numArg) {
    instr(Bytecode.INVOKESTATIC);
    bytes.add2(constantIndex);
    block.pop(numArg);
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  public void INVOKEVIRTUAL(int constantIndex, int numArg, TypeDecl returnType) {
    INVOKEVIRTUAL(constantIndex, numArg);
    if (!returnType.isVoid()) {
      block.push(returnType.verificationType());
    }
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  public void INVOKEVIRTUAL_void(int constantIndex, int numArg) {
    INVOKEVIRTUAL(constantIndex, numArg);
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  private void INVOKEVIRTUAL(int constantIndex, int numArg) {
    instr(Bytecode.INVOKEVIRTUAL);
    bytes.add2(constantIndex);
    block.pop(numArg);
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  public void INVOKESPECIAL(int constantIndex, int numArg, TypeDecl returnType) {
    INVOKESPECIAL(constantIndex, numArg);
    if (!returnType.isVoid()) {
      block.push(returnType.verificationType());
    }
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  public void INVOKESPECIAL_void(int constantIndex, int numArg) {
    INVOKESPECIAL(constantIndex, numArg);
  }

  /**
   * @param constantIndex Constant index of method descriptor.
   */
  private void INVOKESPECIAL(int constantIndex, int numArg) {
    instr(Bytecode.INVOKESPECIAL);
    bytes.add2(constantIndex);
    block.pop(numArg);
  }

  /**
   * Push an integer constant on the operand stack.
   */
  public void ICONST(int value) {
    switch (value) {
      case -1:
        instr(Bytecode.ICONST_M1);
        break;
      case 0:
        instr(Bytecode.ICONST_0);
        break;
      case 1:
        instr(Bytecode.ICONST_1);
        break;
      case 2:
        instr(Bytecode.ICONST_2);
        break;
      case 3:
        instr(Bytecode.ICONST_3);
        break;
      case 4:
        instr(Bytecode.ICONST_4);
        break;
      case 5:
        instr(Bytecode.ICONST_5);
        break;
      default:
        if (value >= -128 && value <= 127) {
          instr(Bytecode.BIPUSH);
          bytes.add(value);
        } else if(value >= -32768 && value <= 32767) {
          instr(Bytecode.SIPUSH);
          bytes.add2(value);
        } else {
          int index = constantPool().addConstant(value);
          if (index < 256) {
            instr(Bytecode.LDC);
            bytes.add(index);
          } else {
            instr(Bytecode.LDC_W);
            bytes.add2(index);
          }
        }
        break;
    }
    block.push(VerificationTypes.INT);
  }

  /**
   * Push a long integer constant on the operand stack.
   */
  public void LCONST(long value) {
    if (value == 0) {
      instr(Bytecode.LCONST_0);
    } else if(value == 1) {
      instr(Bytecode.LCONST_1);
    } else {
      int index = constantPool().addConstant(value);
      instr(Bytecode.LDC2_W);
      bytes.add2(index);
    }
    block.push(VerificationTypes.LONG);
  }

  /**
   * Push a single precision floating-point constant on the operand
   * stack.
   */
  public void FCONST(float value) {
    if (value == 0) {
      instr(Bytecode.FCONST_0);
    } else if (value == 1) {
      instr(Bytecode.FCONST_1);
    } else if (value == 2) {
      instr(Bytecode.FCONST_2);
    } else {
      int index = constantPool().addConstant(value);
      if (index < 256) {
        instr(Bytecode.LDC);
        bytes.add(index);
      } else {
        instr(Bytecode.LDC_W);
        bytes.add2(index);
      }
    }
    block.push(VerificationTypes.FLOAT);
  }

  /**
   * Push a double precision floating-point constant on the operand
   * stack.
   */
  public void DCONST(double value) {
    if (value == 0) {
      instr(Bytecode.DCONST_0);
    } else if (value == 1) {
      instr(Bytecode.DCONST_1);
    } else {
      int index = constantPool().addConstant(value);
      instr(Bytecode.LDC2_W);
      bytes.add2(index);
    }
    block.push(VerificationTypes.DOUBLE);
  }

  /**
   * Push a boolean constant on the operand stack.
   */
  public void ICONST(boolean value) {
    instr(value ? Bytecode.ICONST_1 : Bytecode.ICONST_0);
    block.push(VerificationTypes.INT);
  }

  /**
   * Push a null reference.
   */
  public void ACONST_NULL() {
    instr(Bytecode.ACONST_NULL);
    block.push(VerificationTypes.NULL);
  }

  /**
   * Push a string literal on the operand stack.
   */
  public void pushString(String value) {
    LDC(value);
  }

  /**
   * Push a string literal on the operand stack.
   */
  public void LDC(String value) {
    int index = constantPool().addConstant(value);
    if (index < 256) {
      instr(Bytecode.LDC);
      bytes.add(index);
    } else {
      instr(Bytecode.LDC_W);
      bytes.add2(index);
    }
    block.push(VerificationTypes.STRING);
  }

  /**
   * Push a class literal on the operand stack.
   */
  public void pushClassObject(TypeDecl clazz) {
    LDC(clazz);
  }

  /**
   * Push a class literal on the operand stack.
   */
  public void LDC(TypeDecl clazz) {
    int index = constantPool().addClass(clazz.jvmName());
    if (index < 256) {
      instr(Bytecode.LDC);
      bytes.add(index);
    } else {
      instr(Bytecode.LDC_W);
      bytes.add2(index);
    }
    block.push(VerificationTypes.CLASS);
  }

  public void I2L() {
    instr(Bytecode.I2L);
    block.pop();
    block.push(VerificationTypes.LONG);
  }

  public void I2F() {
    instr(Bytecode.I2F);
    block.pop();
    block.push(VerificationTypes.FLOAT);
  }

  public void I2D() {
    instr(Bytecode.I2D);
    block.pop();
    block.push(VerificationTypes.DOUBLE);
  }

  public void I2S() {
    instr(Bytecode.I2S);
  }

  public void I2B() {
    instr(Bytecode.I2B);
  }

  public void I2C() {
    instr(Bytecode.I2C);
  }

  public void L2I() {
    instr(Bytecode.L2I);
    block.pop();
    block.push(VerificationTypes.INT);
  }

  public void L2F() {
    instr(Bytecode.L2F);
    block.pop();
    block.push(VerificationTypes.FLOAT);
  }

  public void L2D() {
    instr(Bytecode.L2D);
    block.pop();
    block.push(VerificationTypes.DOUBLE);
  }

  public void F2I() {
    instr(Bytecode.F2I);
    block.pop();
    block.push(VerificationTypes.INT);
  }

  public void F2L() {
    instr(Bytecode.F2L);
    block.pop();
    block.push(VerificationTypes.LONG);
  }

  public void F2D() {
    instr(Bytecode.F2D);
    block.pop();
    block.push(VerificationTypes.DOUBLE);
  }

  public void D2I() {
    instr(Bytecode.D2I);
    block.pop();
    block.push(VerificationTypes.INT);
  }

  public void D2L() {
    instr(Bytecode.D2L);
    block.pop();
    block.push(VerificationTypes.LONG);
  }

  public void D2F() {
    instr(Bytecode.D2F);
    block.pop();
    block.push(VerificationTypes.FLOAT);
  }

  public void INEG() {
    instr(Bytecode.INEG);
  }

  public void LNEG() {
    instr(Bytecode.LNEG);
  }

  public void FNEG() {
    instr(Bytecode.FNEG);
  }

  public void DNEG() {
    instr(Bytecode.DNEG);
  }

  public void IINC(int pos, int value) {
    instr(Bytecode.IINC);
    bytes.add(pos);
    bytes.add(value);
  }

  public void IADD() {
    instr(Bytecode.IADD);
    block.pop();
  }

  public void LADD() {
    instr(Bytecode.LADD);
    block.pop();
  }

  public void FADD() {
    instr(Bytecode.FADD);
    block.pop();
  }

  public void DADD() {
    instr(Bytecode.DADD);
    block.pop();
  }

  public void ISUB() {
    instr(Bytecode.ISUB);
    block.pop();
  }

  public void LSUB() {
    instr(Bytecode.LSUB);
    block.pop();
  }

  public void FSUB() {
    instr(Bytecode.FSUB);
    block.pop();
  }

  public void DSUB() {
    instr(Bytecode.DSUB);
    block.pop();
  }

  public void IMUL() {
    instr(Bytecode.IMUL);
    block.pop();
  }

  public void LMUL() {
    instr(Bytecode.LMUL);
    block.pop();
  }

  public void FMUL() {
    instr(Bytecode.FMUL);
    block.pop();
  }

  public void DMUL() {
    instr(Bytecode.DMUL);
    block.pop();
  }

  public void IDIV() {
    instr(Bytecode.IDIV);
    block.pop();
  }

  public void LDIV() {
    instr(Bytecode.LDIV);
    block.pop();
  }

  public void FDIV() {
    instr(Bytecode.FDIV);
    block.pop();
  }

  public void DDIV() {
    instr(Bytecode.DDIV);
    block.pop();
  }

  public void IREM() {
    instr(Bytecode.IREM);
    block.pop();
  }

  public void LREM() {
    instr(Bytecode.LREM);
    block.pop();
  }

  public void FREM() {
    instr(Bytecode.FREM);
    block.pop();
  }

  public void DREM() {
    instr(Bytecode.DREM);
    block.pop();
  }

  public void ISHL() {
    instr(Bytecode.ISHL);
    block.pop();
  }

  public void LSHL() {
    instr(Bytecode.LSHL);
    block.pop();
  }

  public void ISHR() {
    instr(Bytecode.ISHR);
    block.pop();
  }

  public void LSHR() {
    instr(Bytecode.LSHR);
    block.pop();
  }

  public void IUSHR() {
    instr(Bytecode.IUSHR);
    block.pop();
  }

  public void LUSHR() {
    instr(Bytecode.LUSHR);
    block.pop();
  }

  public void IAND() {
    instr(Bytecode.IAND);
    block.pop();
  }

  public void LAND() {
    instr(Bytecode.LAND);
    block.pop();
  }

  public void IOR() {
    instr(Bytecode.IOR);
    block.pop();
  }

  public void LOR() {
    instr(Bytecode.LOR);
    block.pop();
  }

  public void IXOR() {
    instr(Bytecode.IXOR);
    block.pop();
  }

  public void LXOR() {
    instr(Bytecode.LXOR);
    block.pop();
  }

  public void RETURN() {
    instr(Bytecode.RETURN);
    afterAbrupt = true;
    closeBlock();
  }

  public void IRETURN() {
    instr(Bytecode.IRETURN);
    block.pop();
    afterAbrupt = true;
    closeBlock();
  }

  public void LRETURN() {
    instr(Bytecode.LRETURN);
    block.pop();
    afterAbrupt = true;
    closeBlock();
  }

  public void FRETURN() {
    instr(Bytecode.FRETURN);
    block.pop();
    afterAbrupt = true;
    closeBlock();
  }

  public void DRETURN() {
    instr(Bytecode.DRETURN);
    block.pop();
    afterAbrupt = true;
    closeBlock();
  }

  public void ARETURN() {
    instr(Bytecode.ARETURN);
    block.pop();
    afterAbrupt = true;
    closeBlock();
  }

  public void ATHROW() {
    instr(Bytecode.ATHROW);
    block.pop();
    afterAbrupt = true;
    closeBlock();
  }

  public void MONITORENTER() {
    instr(Bytecode.MONITORENTER);
    block.pop();
  }

  public void MONITOREXIT() {
    instr(Bytecode.MONITOREXIT);
    block.pop();
  }

  public void INSTANCEOF(TypeDecl type) {
    int offset = constantPool().addClass(type.isArrayDecl()
        ? type.typeDescriptor()
        : type.constantPoolName());
    instr(Bytecode.INSTANCEOF);
    bytes.add2(offset);
    block.pop();
    block.push(VerificationTypes.INT);
  }

  public void CHECKCAST(TypeDecl type) {
    int offset = constantPool().addClass(type.isArrayDecl()
        ? type.typeDescriptor()
        : type.constantPoolName());
    instr(Bytecode.CHECKCAST);
    bytes.add2(offset);
    block.pop();
    block.push(type.verificationType());
  }

  /**
   * Determines instruction from type width.
   */
  public void POP(TypeDecl type) {
    switch (type.variableSize()) {
      case 1:
        POP();
        break;
      case 2:
        POP2();
        break;
    }
  }

  public void POP() {
    instr(Bytecode.POP);
    block.pop();
  }

  public void POP2() {
    instr(Bytecode.POP2);
    block.pop();
  }

  /**
   * Determines instruction from type width.
   */
  public void DUP(TypeDecl type) {
    if (type.variableSize() > 1) {
      DUP2();
    } else {
      DUP();
    }
  }

  /**
   * Determines instruction from type width.
   */
  public void DUP_X1(TypeDecl type) {
    if (type.variableSize() > 1) {
      DUP2_X1();
    } else {
      DUP_X1();
    }
  }

  /**
   * Determines instruction from type width.
   */
  public void DUP_X2(TypeDecl type) {
    if (type.variableSize() > 1) {
      DUP2_X2();
    } else {
      DUP_X2();
    }
  }

  public void DUP() {
    // The top stack element must be a one-word type.
    instr(Bytecode.DUP);
    block.dup();
  }

  public void DUP_X1() {
    // The top stack element must be a one-word type.
    instr(Bytecode.DUP_X1);
    block.dup_x1();
  }

  public void DUP_X2() {
    // The top stack element must be a one-word type.
    instr(Bytecode.DUP_X2);
    block.dup_x2();
  }

  public void DUP2() {
    // The top stack element must be a two-word type.
    instr(Bytecode.DUP2);
    block.dup();
  }

  public void DUP2_X1() {
    // The top stack element must be a two-word type.
    instr(Bytecode.DUP2_X1);
    block.dup_x1();
  }

  public void DUP2_X2() {
    // The top stack element must be a two-word type.
    instr(Bytecode.DUP2_X2);
    block.dup_x2();
  }

  public void SWAP() {
    // The two top stack elements must be one-word types.
    instr(Bytecode.SWAP);
    block.swap();
  }

  public void GOTO(int label) {
    int offset = jump(pos() + 1, pos(), label, wideGotos);
    if (wideGotos) {
      bytes.add(Bytecode.GOTO_W);
      bytes.add4(offset);
    } else {
      bytes.add(Bytecode.GOTO);
      bytes.add2(offset);
    }
    block.addJump(label);
    afterAbrupt = true;
    closeBlock();
  }

  public void LCMP() {
    instr(Bytecode.LCMP);
    block.pop(2);
    block.push(VerificationTypes.INT);
  }

  public void FCMPG() {
    instr(Bytecode.FCMPG);
    block.pop(2);
    block.push(VerificationTypes.INT);
  }

  public void DCMPG() {
    instr(Bytecode.DCMPG);
    block.pop(2);
    block.push(VerificationTypes.INT);
  }

  public void FCMPL() {
    instr(Bytecode.FCMPL);
    block.pop(2);
    block.push(VerificationTypes.INT);
  }

  public void DCMPL() {
    instr(Bytecode.DCMPL);
    block.pop(2);
    block.push(VerificationTypes.INT);
  }

  public void IFLT(int target) {
    block.pop();
    condBranch(Bytecode.IFLT, target);
  }

  public void IFLE(int target) {
    block.pop();
    condBranch(Bytecode.IFLE, target);
  }

  public void IFGE(int target) {
    block.pop();
    condBranch(Bytecode.IFGE, target);
  }

  public void IFGT(int target) {
    block.pop();
    condBranch(Bytecode.IFGT, target);
  }

  public void IFEQ(int target) {
    block.pop();
    condBranch(Bytecode.IFEQ, target);
  }

  public void IFNE(int target) {
    block.pop();
    condBranch(Bytecode.IFNE, target);
  }

  public void IF_ICMPLT(int target) {
    block.pop(2);
    condBranch(Bytecode.IF_ICMPLT, target);
  }

  public void IF_ICMPLE(int target) {
    block.pop(2);
    condBranch(Bytecode.IF_ICMPLE, target);
  }

  public void IF_ICMPGE(int target) {
    block.pop(2);
    condBranch(Bytecode.IF_ICMPGE, target);
  }

  public void IF_ICMPGT(int target) {
    block.pop(2);
    condBranch(Bytecode.IF_ICMPGT, target);
  }

  public void IF_ICMPEQ(int target) {
    block.pop(2);
    condBranch(Bytecode.IF_ICMPEQ, target);
  }

  public void IF_ICMPNE(int target) {
    block.pop(2);
    condBranch(Bytecode.IF_ICMPNE, target);
  }

  public void IF_ACMPEQ(int target) {
    block.pop(2);
    condBranch(Bytecode.IF_ACMPEQ, target);
  }

  public void IF_ACMPNE(int target) {
    block.pop(2);
    condBranch(Bytecode.IF_ACMPNE, target);
  }

  public void IFNULL(int target) {
    block.pop();
    condBranch(Bytecode.IFNULL, target);
  }

  public void IFNONNULL(int target) {
    block.pop();
    condBranch(Bytecode.IFNONNULL, target);
  }

  private void condBranch(byte bytecode, int label) {
    int offset = jump(pos() + 1, pos(), label, false);
    instr(bytecode);
    bytes.add2(offset);
    block.addJump(label);
    afterAbrupt = false;
    closeBlock();
  }

  public int size() {
    return bytes.size();
  }

  public int pos() {
    return bytes.pos();
  }

  public void setPos(int pos) {
    bytes.setPos(pos);
  }

  public void skip(int num) {
    bytes.skip(num);
  }

  protected void instr(byte b) {
    bytes.add(b);
  }

  private static final Comparator<CaseLabel> labelComparator =
    new Comparator<CaseLabel>() {
      @Override
      public int compare(CaseLabel a, CaseLabel b) {
        return intCompare(a.value, b.value);
      }
    };

  /**
   * Generate a TABLESWITCH/LOOKUPSWITCH depending on labels.
   * @param cases ordered list of case labels
   * @param defaultLbl label for default block
   */
  public void SWITCH(Collection<? extends CaseLabel> cases, int defaultLbl) {
    ArrayList<CaseLabel> labels = new ArrayList<CaseLabel>(cases);
    Collections.sort(labels, labelComparator);

    int low = labels.isEmpty() ? 0 : labels.get(0).value;
    int high = labels.isEmpty() ? 0 : labels.get(labels.size()-1).value;

    // NB calculate sizes in long or else we may have overflow!!!
    long tableSwitchSize = 4L * (3L + ((long)high - (long)low + 1L));
    long lookupSwitchSize = 4L * (2L + 2L * labels.size());

    int switchLbl = constantPool().newLabel();
    addLabel(switchLbl);

    // Add successor blocks.
    block.addJump(defaultLbl);
    for (CaseLabel ca : labels) {
      block.addJump(ca.label);
    }

    // Select the switch type which produces the smallest switch instr.
    if (tableSwitchSize < lookupSwitchSize) {
      // TABLESWITCH
      block.pop(); // Pop switch argument.
      instr(Bytecode.TABLESWITCH);
      alignSwitch();
      bytes.add4(relativeJump(switchLbl, defaultLbl));
      bytes.add4(low);
      bytes.add4(high);
      int i = low;
      for (CaseLabel ca : labels) {
        while (i < ca.value) {
          bytes.add4(relativeJump(switchLbl, defaultLbl));
          i += 1;
        }
        bytes.add4(relativeJump(switchLbl, ca.label));
        i += 1;
      }
    } else {
      // LOOKUPSWITCH
      block.pop(); // Pop switch argument.
      instr(Bytecode.LOOKUPSWITCH);
      alignSwitch();
      bytes.add4(relativeJump(switchLbl, defaultLbl));
      bytes.add4(labels.size());
      for (CaseLabel ca : labels) {
        bytes.add4(ca.value);
        bytes.add4(relativeJump(switchLbl, ca.label));
      }
    }
    afterAbrupt = true;
    closeBlock();
  }

  protected static int intCompare(int a, int b) {
    // Compare without branches. (joqvist 2014)
    long p = (long)a - b;
    return (int) (p>>1 | p&-1>>>1);
  }

  /**
   * Pad with NOPs for switch table so that it is 4-byte aligned.
   */
  private void alignSwitch() {
    int pad = (4 - (pos() % 4)) % 4;
    for (int i = 0; i < pad; i++) {
      NOP();
    }
  }

  /**
   * Write bytes to output stream.
   * @throws IOException
   */
  public void write(DataOutputStream out) throws IOException {
    computeStackFrames();
    bytes.write(out);
  }

  /**
   * Prints bytecodes disassembly to a print stream.
   */
  public void printBytecodes(PrintStream out) throws IOException {
    BytecodeDebug.printBytecodes(out, bytes.toArray());
  }


  /**
   * Close current basic block.
   */
  private void closeBlock() {
    block.end = pos();
    blocks.add(block);
    BasicBlock prev = block;
    block = new BasicBlock(-nextBlock, pos());
    nextBlock += 1;
    if (!afterAbrupt) {
      prev.setNext(block);
    }
  }

  /**
   * Compute stack frames and NOP out dead blocks.
   */
  private void computeStackFrames() {
    if (computedStackFrames) {
      return;
    }
    computedStackFrames = true;

    // Connect basic blocks.
    for (BasicBlock bb : blocks) {
      for (int label : bb.jumps) {
        bb.connect(blockLabels.get(label));
      }
    }

    for (ExceptionEntry exception : exceptions) {
      BasicBlock handler = blockLabels.get(exception.handler_lbl);
      exception.handler = handler;
      for (BasicBlock bb : blocks) {
        if (bb.start >= exception.start_pc && bb.end <= exception.end_pc) {
          bb.excp.add(exception);
          handler.preds += 1;
        }
      }
    }

    // TODO: track max locals and max stack size.
    LinkedList<BasicBlock> worklist = new LinkedList<BasicBlock>();
    search(entry, worklist);

    while (!worklist.isEmpty()) {
      BasicBlock next = worklist.pop();
      next.working = false;
      propagate(next, worklist);
    }

    if (DEBUG) {
      System.out.print("Bytecode for ");
      if (context instanceof MethodDecl) {
        System.out.println(((MethodDecl) context).signature());
      } else if (context instanceof ConstructorDecl) {
          System.out.println(((ConstructorDecl) context).signature());
      } else if (context instanceof TypeDecl) {
        System.out.println(((TypeDecl) context).name() + "<init>");
      } else {
        System.out.println(context.sourceLocation());
      }
    }

    int prevOffset = 0;
    BasicBlock deleted = null;
    StackFrame prevFrame = entry.entryStack;
    maxLocals = entry.entryStack.maxLocals();
    for (BasicBlock bb : blocks) {
      if (DEBUG) {
        System.out.println("  " + bb);
      }
      if (bb.reachable) {
        if (DEBUG) {
          printBlock(bb);
        }
        if (deleted != null) {
          // The previous block was deleted. We will merge this block with the
          // previous block. All jumps to this block need to be updated to
          // point to the new start position.
          for (Jump jump : jumps) {
            if (jump.bb.reachable && jump.target == bb.start) {
              jump.target = deleted.start;
              patch(jump);
            }
          }
          // Extend exception ranges that start at this block.
          for (ExceptionEntry e : exceptions) {
            if (e.handler == bb) {
              e.handler_lbl = deleted.label;
            }
          }
          // Merge this block with the previous deleted block.
          bb.start = deleted.start;
          deleted = null;
        }
        if (bb.preds > 0) {
          StackFrame frame = new StackFrame(bb.entryStack);
          frame.offset = bb.start - prevOffset;
          prevOffset = bb.start + 1;
          if (DEBUG) {
            System.out.format("    @%d\t%s%n", bb.start, frame);
          }
          frame.prevFrame = prevFrame;
          stackFrames.add(frame);
          prevFrame = frame;
        }
        if (DEBUG) {
          System.out.format("    out\t%s%n", bb.exitStack());
          if (!bb.succ.isEmpty() || bb.next != null) {
            System.out.print("    ->");
            if (bb.next != null) {
              System.out.print(" " + bb.next.name());
            }
            for (BasicBlock succ : bb.succ) {
              System.out.print(" " + succ.name());
            }
            System.out.println();
          }
          bb.printOps();
        }

        maxLocals = Math.max(maxLocals, bb.maxLocals);
        maxStack = Math.max(maxStack, bb.exitStack().maxStack());
      } else {
        if (DEBUG) {
          System.out.println("  deleted");
        }
        delete(bb);
        if (deleted == null) {
          deleted = bb;
        } else {
          deleted.end = bb.end;
          bb = deleted;
        }
        // This block may be at the end of an exception range. If that is the case,
        // the exception range needs to be updated to exclude this block. This may
        // lead to the range becoming empty, and the exception handler should then
        // be removed.
        // If this block is at the start of an exception range, or in the
        // middle, then nothing needs to be updated: the following block is
        // still part of the exception range.
        Iterator<ExceptionEntry> iter = exceptions.iterator();
        while (iter.hasNext()) {
          ExceptionEntry e = iter.next();
          int eend = e.end_pc;
          if (eend > bb.start && eend <= bb.end) {
            e.end_pc = bb.start;
            if (e.end_pc <= e.start_pc) {
              iter.remove();
            }
          }
        }
      }
    }
    if (deleted != null) {
      // The deleted block was at the end of the bytecode, so we delete it by
      // just updating the end position.
      setPos(deleted.start);
      // Trim variable entry ranges.
      Iterator<LocalVariableEntry> viter = localVariableTable.iterator();
      while (viter.hasNext()) {
        LocalVariableEntry var = viter.next();
        int vstart = var.start_pc;
        int vend = var.start_pc + var.length;
        if (vstart >= pos()) {
          viter.remove();
        } else if (vend >= pos()) {
          var.length = pos() - 1 - vstart;
        }
      }
      // Trim line number table.
      Iterator<LineNumberEntry> liter = lineNumberTable.iterator();
      while (liter.hasNext()) {
        LineNumberEntry e = liter.next();
        if (e.start_pc >= pos()) {
          liter.remove();
        }
      }
    }

    if (DEBUG) {
      for (ExceptionEntry e : exceptions) {
        System.out.format("  exception %d..%d -> L%d%n", e.start_pc, e.end_pc, e.handler_lbl);
      }
    }
  }

  private void printBlock(BasicBlock bb) {
    BytecodeDebug.printBytecodes(System.out, bytes.toArray(), bb.start, bb.end);
  }

  /**
   * Deletes an unreachable block.
   */
  private void delete(BasicBlock bb) {
    for (int i = bb.start; i < bb.end; ++i) {
      bytes.set(i, Bytecode.NOP);
    }
  }

  private void search(BasicBlock block, LinkedList<BasicBlock> worklist) {
    if (block.reachable) {
      // Already visited.
      return;
    }

    block.reachable = true;
    propagate(block, worklist);
    if (block.next != null) {
      search(block.next, worklist);
    }
    for (BasicBlock bb : block.succ) {
      search(bb, worklist);
    }
    for (ExceptionEntry e : block.excp) {
      search(e.handler, worklist);
    }
  }

  private void propagate(BasicBlock block, LinkedList<BasicBlock> worklist) {
    block.reachable = true;
    if (block.next != null) {
      propagate(block, block.next, worklist);
    }
    for (BasicBlock bb : block.succ) {
      propagate(block, bb, worklist);
    }
    for (ExceptionEntry e : block.excp) {
      propagateException(block, e, worklist);
    }
  }

  private void propagate(BasicBlock from, BasicBlock next, LinkedList<BasicBlock> worklist) {
    if (next.entryStack == null) {
      next.entryStack = new StackFrame(from.exitStack());
    } else if (next.entryStack.merge(from.exitStack())) {
      if (!next.working) {
        next.working = true;
        worklist.add(next);
      }
    }
  }

  private void propagateException(BasicBlock from, ExceptionEntry e,
      LinkedList<BasicBlock> worklist) {
    BasicBlock next = e.handler;
    StackFrame frame = new StackFrame(from.entryStack);
    from.localSubset(frame);
    frame.clearStack();
    frame.push(e.type);
    if (next.entryStack == null) {
      next.entryStack = frame;
    } else if (next.entryStack.merge(frame)) {
      if (!next.working) {
        next.working = true;
        worklist.add(next);
      }
    }
  }

  public java.util.List<StackFrame> stackFrames() {
    computeStackFrames();
    return stackFrames;
  }
}
