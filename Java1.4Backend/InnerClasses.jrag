aspect InnerClasses {

  // The set of TypeDecls that has this TypeDecl as their directly enclosing TypeDecl.
  // I.e., NestedTypes, InnerTypes, AnonymousClasses, LocalClasses.
  private Collection TypeDecl.nestedTypes;
  public Collection TypeDecl.nestedTypes() {
    return nestedTypes != null ? nestedTypes : new HashSet();
  }
  public void TypeDecl.addNestedType(TypeDecl typeDecl) {
    if(nestedTypes == null) nestedTypes = new ArrayList();
    if(typeDecl != this)
      nestedTypes.add(typeDecl);
  }

  // The set of nested TypeDecls that are accessed in this TypeDecl
  private Collection TypeDecl.usedNestedTypes;
  public Collection TypeDecl.usedNestedTypes() {
    return usedNestedTypes != null ? usedNestedTypes : new HashSet();
  }
  public void TypeDecl.addUsedNestedType(TypeDecl typeDecl) {
    if(usedNestedTypes == null) usedNestedTypes = new HashSet();
    usedNestedTypes.add(typeDecl);
  }
  
  int TypeDecl.constantPoolNameIndex = 1;

  syn lazy String TypeDecl.constantPoolName() {
    if(!isNestedType()) {
      String packageName = packageName();
      if(!packageName.equals("")) {
        packageName = packageName.replace('.', '/') + "/";
      }
      return packageName + name();
    }
    else {
      String prefix = enclosingType().constantPoolName();
      if(isAnonymous()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index;
      }
      else if(isLocalClass()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index + name();
      }
      return prefix + "$" + name();
    }
  }

  syn lazy String ArrayDecl.constantPoolName() = typeDescriptor();

  syn lazy Collection TypeDecl.enclosingVariables() {
    HashSet set = new HashSet();
    for(TypeDecl e = this; e != null; e = e.enclosingType()) {
      if(e.isLocalClass() || e.isAnonymous()) {
        collectEnclosingVariables(set, e.enclosingType());
      }
    }
    if(isClassDecl()) {
      ClassDecl classDecl = (ClassDecl)this;
      if(classDecl.isNestedType() && classDecl.hasSuperclass())
        set.addAll(classDecl.superclass().enclosingVariables());
    }
    return set;
  }

  public void ASTNode.collectEnclosingVariables(HashSet set, TypeDecl typeDecl) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectEnclosingVariables(set, typeDecl);
  }
  public void VarAccess.collectEnclosingVariables(HashSet set, TypeDecl typeDecl) {
    Variable v = decl();
    if(!v.isInstanceVariable() && !v.isClassVariable() && v.hostType() == typeDecl) {
      //if(Program.verbose()) {
      //  System.out.println("Local variable " + v.name() + " in " + v.hostType().fullName() + " is used from " + hostType().fullName());
      //}
      set.add(v);
    }
    super.collectEnclosingVariables(set, typeDecl);
  }


  public int TypeDecl.accessorCounter = 0;

  syn boolean FieldDeclaration.needsAccessor() = accessorIndex != -1;
  syn lazy int FieldDeclaration.accessorIndex() = accessorIndex = hostType().accessorCounter++;
  private int FieldDeclaration.accessorIndex = -1;
  syn boolean FieldDeclaration.needsAccessorWrite() = accessorWriteIndex != -1;
  syn lazy int FieldDeclaration.accessorWriteIndex() = accessorWriteIndex = hostType().accessorCounter++;
  private int FieldDeclaration.accessorWriteIndex = -1;

  syn boolean ConstructorDecl.needsAccessor() = accessorIndex != -1;
  private String ConstructorDecl.anonymousJavaName;

  private boolean ConstructorDecl.accessorIndexVisited = false;
  syn lazy int ConstructorDecl.accessorIndex() {
    // rework treebuilding, final
    if(accessorIndexVisited)
      return accessorIndex;
    accessorIndexVisited = true;

    ClassDecl classDecl =
      new ClassDecl(
          new Modifiers(new List().add(new Modifier("synthetic"))),
          "Dummy",
          new Opt(),
          new List(),
          new List()
          );
    hostType().addUsedNestedType(classDecl);
    // add as LocalClassDeclStmt
    getBlock().addStmt(new LocalClassDeclStmt(classDecl)); 
    // force new subtree to be rewritten and final
    // TODO: why is this necessary?
    LocalClassDeclStmt stmt = (LocalClassDeclStmt)getBlock().getStmt(getBlock().getNumStmt()-1);
    classDecl = stmt.getClassDecl();
    classDecl.toString(new StringBuffer());

    accessorIndex = hostType().accessorCounter++;
    anonymousJavaName = classDecl.typeDescriptor();
    //classDecl.generateClassfile();
    return accessorIndex;
  }
  private int ConstructorDecl.accessorIndex = -1;

  public int TypeDecl.numAccessorMethods(Collection c) {
    int num = 0;
    for(Iterator iter = c.iterator(); iter.hasNext(); ) {
      Object o = iter.next();
      if(o instanceof ConstructorDecl) {
        ConstructorDecl m = (ConstructorDecl)o;
        if(m.needsAccessor())
          num++;
      }
    }
    return num;
  }

  public int TypeDecl.numAccessorFields(Collection c) {
    int num = 0;
    for(Iterator iter = c.iterator(); iter.hasNext(); ) {
      Object o = iter.next();
      if(o instanceof FieldDeclaration) {
        FieldDeclaration f = (FieldDeclaration)o;
        if(f.needsAccessor())
          num++;
        if(f.needsAccessorWrite())
          num++;
      }
    }
    return num;
  }

  public void FieldDeclaration.emitAccessor(ConstantPool cp, DataOutputStream out) throws java.io.IOException {
    out.writeChar(Modifiers.ACC_STATIC);
    out.writeChar(cp.addUtf8("access$" + accessorIndex()));
    out.writeChar(cp.addUtf8(accessorDescName()));
    out.writeChar(accessorAttributes().size());
    for(Iterator iter = accessorAttributes().iterator(); iter.hasNext(); ) {
      ((Attribute)iter.next()).emit(out);
    }
  }
  public void FieldDeclaration.emitAccessorWrite(ConstantPool cp, DataOutputStream out) throws java.io.IOException {
    out.writeChar(Modifiers.ACC_STATIC);
    out.writeChar(cp.addUtf8("access$" + accessorWriteIndex()));
    out.writeChar(cp.addUtf8(accessorWriteDescName()));
    out.writeChar(accessorAttributes().size());
    for(Iterator iter = accessorWriteAttributes().iterator(); iter.hasNext(); ) {
      ((Attribute)iter.next()).emit(out);
    }
  }

  public ArrayList FieldDeclaration.accessorAttributes() {
    ConstantPool cp = hostType().constantPool();
    ArrayList list = new ArrayList();
    CodeGeneration gen = new CodeGeneration(cp);
    int index = 0;
    if(!isStatic())
      gen.emitLoadReference(index++);
    emitLoadField(gen, hostType());
    type().emitReturn(gen);
    CodeAttribute a = new CodeAttribute(gen, null);
    list.add(a);
    list.add(new SyntheticAttribute(cp));
    return list;
  }

  public ArrayList FieldDeclaration.accessorWriteAttributes() {
    ConstantPool cp = hostType().constantPool();
    ArrayList list = new ArrayList();
    CodeGeneration gen = new CodeGeneration(cp);
    int index = 0;
    if(!isStatic())
      gen.emitLoadReference(index++);
    type().emitLoadLocal(gen, index);
    emitStoreField(gen, hostType());
    gen.emit(Bytecode.RETURN);
    CodeAttribute a = new CodeAttribute(gen, null);
    list.add(a);
    list.add(new SyntheticAttribute(cp));
    return list;
  }

  syn lazy MethodDecl MethodDecl.createAccessor() {
    int accessorIndex = hostType().accessorCounter++;
    // add synthetic flag to modifiers
    Modifiers modifiers = (Modifiers)getModifiers().fullCopy();
    modifiers.addModifier(new Modifier("synthetic"));
    // build accessor declaration
    MethodDecl m = new MethodAccessorDecl(
      modifiers,
      type().createQualifiedAccess(),
      "access$" + accessorIndex,
      (List)getParameterList().fullCopy(),
      new List(), // EmptyBracket*
      (List)getExceptionList().fullCopy(),
      new Opt(
        new Block(
          new List().add(
            createAccessorStmt()
          )
        )
      )
    );
    return hostType().addMemberMethod(m);
  }
  
  private Stmt MethodDecl.createAccessorStmt() {
    List argumentList = new List();
    for(int i = 0; i < getNumParameter(); i++)
      argumentList.add(new VarAccess(getParameter(i).name()));
    Access access = new MethodAccess(argumentList, name());
    if(!isStatic())
      access = new ThisAccess("this").qualifiesAccess(access);
    return isVoid() ? (Stmt) new ExprStmt(access) : new ReturnStmt(new Opt(access));
  }
  
  eq MethodAccessorDecl.descName() {
    StringBuffer b = new StringBuffer();
    b.append("(");
    if(!isStatic())
      b.append(hostType().typeDescriptor());
    for (int i=0; i<getNumParameter(); i++)
      b.append(getParameter(i).type().typeDescriptor());
    b.append(")");
    b.append(type().typeDescriptor());
    return b.toString();
  }

  public void MethodAccessorDecl.emitInvokeMethod(CodeGeneration gen, TypeDecl hostType) {
    // compute operation stack height change
    int size = type().variableSize();
    if(!isStatic())
      size -= 1;
    for(int i = 0; i < getNumParameter(); i++)
      size -= getParameter(i).type().variableSize();
    // invoke method
    int index = gen.constantPool().addMethodref(hostType().constantPoolName(), name(), descName());
    gen.emit(Bytecode.INVOKESTATIC, size).add2(index);
  }

  eq MethodAccessorDecl.flags() = (super.flags() | Modifiers.ACC_STATIC) & (~Modifiers.ACC_PRIVATE);
  
  public void ConstructorDecl.emitAccessor(ConstantPool cp, DataOutputStream out) throws java.io.IOException {
    accessorIndex();
    out.writeChar(0);
    out.writeChar(cp.addUtf8("<init>"));
    out.writeChar(cp.addUtf8(accessorDescName()));
    out.writeChar(accessorAttributes().size());
    for(Iterator iter = accessorAttributes().iterator(); iter.hasNext(); ) {
      ((Attribute)iter.next()).emit(out);
    }
  }

  syn boolean ConstructorDecl.needsEnclosing() = hostType().needsEnclosing();
  syn boolean ConstructorDecl.needsSuperEnclosing() = hostType().needsSuperEnclosing();
  
  syn boolean TypeDecl.isAnonymousInNonStaticContext() {
    return isAnonymous() && !((ClassInstanceExpr)getParent().getParent()).unqualifiedScope().inStaticContext();
  }
  
  syn boolean TypeDecl.needsEnclosing() {
    if(isAnonymous())
      return isAnonymousInNonStaticContext();
    else if(isLocalClass())
      return !inStaticContext();
    else if(isInnerType())
      return true;
    return false;
  }
  
  syn boolean TypeDecl.needsSuperEnclosing() {
    if(!isAnonymous())
      return false;
    TypeDecl superClass = ((ClassDecl)this).superclass();
    if(superClass.isLocalClass())
      return !superClass.inStaticContext();
    else if(superClass.isInnerType())
      return true;
    return false;
  }

  public ArrayList ConstructorDecl.accessorAttributes() {
    ConstantPool cp = hostType().constantPool();
    ArrayList list = new ArrayList();
    CodeGeneration gen = new CodeGeneration(cp);
    int index = 0;
    gen.emitLoadReference(index++);
    // this$0
    if(hostType().needsEnclosing())
      gen.emitLoadReference(index++);
    if(hostType().needsSuperEnclosing())
      gen.emitLoadReference(index++);

    // args
    for(int i = 0; i < getNumParameter(); i++) {
      getParameter(i).type().emitLoadLocal(gen, index);
      index += getParameter(i).type().variableSize();
    }
    // this$val
    for(Iterator iter = hostType().enclosingVariables().iterator(); iter.hasNext(); ) {
      Variable v = (Variable)iter.next();
      v.type().emitLoadLocal(gen, index);
      index += v.type().variableSize();
    }
    gen.maxLocals++; // Increase max locals to include dummy constructor argument for private constructors
    emitInvokeConstructor(gen);
    gen.emit(Bytecode.RETURN);
    CodeAttribute a = new CodeAttribute(gen, null);
    list.add(a);
    list.add(new SyntheticAttribute(cp));
    return list;
  }

  public void ConstructorDecl.emitInvokeConstructorAccessor(CodeGeneration gen) {
    accessorIndex();
    int size = -2; // take this and null (reference to anonymous class)
    for(int i = 0; i < getNumParameter(); i++)
      size -= getParameter(i).type().variableSize();
    if(hostType().needsEnclosing())
      size--;
    if(hostType().needsSuperEnclosing())
      size--;
    for(Iterator iter = hostType().enclosingVariables().iterator(); iter.hasNext(); ) {
      Variable v = (Variable)iter.next();
      size -= v.type().variableSize();
    }
    String classname = hostType().constantPoolName();
    String      desc = accessorDescName();
    String      name = "<init>";
    int index = gen.constantPool().addMethodref(classname, name, desc);
    gen.emit(Bytecode.INVOKESPECIAL, size).add2(index);
  }
  public void FieldDeclaration.emitInvokeFieldAccessor(CodeGeneration gen, TypeDecl hostType) {
    String classname = hostType.constantPoolName();
    String      desc = accessorDescName();
    String      name = "access$" + accessorIndex();
    int index = gen.constantPool().addMethodref(classname, name, desc);
    int size = isStatic() ? type().variableSize() : (type().variableSize() - 1);
    gen.emit(Bytecode.INVOKESTATIC, size).add2(index);
  }
  public void FieldDeclaration.emitInvokeFieldAccessorWrite(CodeGeneration gen, TypeDecl hostType) {
    String classname = hostType.constantPoolName();
    String      desc = accessorWriteDescName();
    String      name = "access$" + accessorWriteIndex();
    int index = gen.constantPool().addMethodref(classname, name, desc);
    int size = isStatic() ? -type().variableSize() : (-type().variableSize() - 1);
    gen.emit(Bytecode.INVOKESTATIC, size).add2(index);
  }

}
