aspect VariableArityParametersCodegen {
  /* Invocations of a variable arity method may contain more actual argument
  expressions than formal parameters. All the actual argument expressions that do
  not correspond to the formal parameters preceding the variable arity parameter
  will be evaluated and the results stored into an array that will be passed to
  the method invocation (§15.12.4.2)*/
  refine Transformations public void MethodAccess.transformation() {
    if(decl().isVariableArity() && !invokesVariableArityAsArray()) {
      // arguments to normal parameters
      List list = new List();
      for(int i = 0; i < decl().getNumParameter() - 1; i++)
        list.add(getArg(i));
      // arguments to variable arity parameters
      List last = new List();
      for(int i = decl().getNumParameter() - 1; i < getNumArg(); i++)
        last.add(getArg(i));
      // build an array holding arguments
      Access typeAccess = decl().lastParameter().type().elementType().createQualifiedAccess();
      List dims = new List();
      for(int i = 0; i < decl().lastParameter().type().dimension(); i++)
        dims.add(new Dims(new Opt()));
      list.add(new ArrayCreationExpr(typeAccess, dims, new Opt(new ArrayInit(last))));
      // replace argument list with augemented argument list
      setArgList(list);
    }
    Transformations.MethodAccess.transformation();
  }

  refine Transformations public void ClassInstanceExpr.transformation() {
    if(decl().isVariableArity() && !invokesVariableArityAsArray()) {
      // arguments to normal parameters
      List list = new List();
      for(int i = 0; i < decl().getNumParameter() - 1; i++)
        list.add(getArg(i));
      // arguments to variable arity parameters
      List last = new List();
      for(int i = decl().getNumParameter() - 1; i < getNumArg(); i++)
        last.add(getArg(i));
      // build an array holding arguments
      Access typeAccess = decl().lastParameter().type().elementType().createQualifiedAccess();
      List dims = new List();
      for(int i = 0; i < decl().lastParameter().type().dimension(); i++)
        dims.add(new Dims(new Opt()));
      list.add(new ArrayCreationExpr(typeAccess, dims, new Opt(new ArrayInit(last))));
      // replace argument list with augemented argument list
      setArgList(list);
    }
    Transformations.ClassInstanceExpr.transformation();
  }

  refine Transformations public void ConstructorAccess.transformation() {
    if(decl().isVariableArity() && !invokesVariableArityAsArray()) {
      // arguments to normal parameters
      List list = new List();
      for(int i = 0; i < decl().getNumParameter() - 1; i++)
        list.add(getArg(i));
      // arguments to variable arity parameters
      List last = new List();
      for(int i = decl().getNumParameter() - 1; i < getNumArg(); i++)
        last.add(getArg(i));
      // build an array holding arguments
      Access typeAccess = decl().lastParameter().type().elementType().createQualifiedAccess();
      List dims = new List();
      for(int i = 0; i < decl().lastParameter().type().dimension(); i++)
        dims.add(new Dims(new Opt()));
      list.add(new ArrayCreationExpr(typeAccess, dims, new Opt(new ArrayInit(last))));
      // replace argument list with augemented argument list
      setArgList(list);
    }
    Transformations.ConstructorAccess.transformation();
  }

  public static final int Modifiers.ACC_VARARGS = 0x0080;

  refine Flags eq MethodDecl.flags() {
    int res = Flags.MethodDecl.flags();
    if(isVariableArity())
      res |= Modifiers.ACC_VARARGS;
    return res;
  }
}
